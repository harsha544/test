diff --git a/README.md b/README.md
index 8a2c8dc..8e1bd8e 100644
--- a/README.md
+++ b/README.md
@@ -3,8 +3,6 @@ MultiChain
 
 [MultiChain](http://www.multichain.com/) is an open source platform for private blockchains, which offers a rich set of features including extensive configurability, rapid deployment, permissions management, native assets and data streams. Although it is designed to enable private blockchains, MultiChain provides maximal compatibility with the bitcoin ecosystem, including the peer-to-peer protocol, transaction/block formats and [Bitcoin Core](https://bitcoin.org/en/bitcoin-core/) APIs/runtime parameters.
 
-MultiChain is licensed under the GPLv3 open source license. We also offer commercial licenses for those wishing to integrate MultiChain into a proprietary software solution.
-
     Copyright (c) 2014-2017 Coin Sciences Ltd
     License: GNU General Public License version 3, see COPYING
 
diff --git a/src/Makefile.am b/src/Makefile.am
index 6305b14..7157ce5 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -157,8 +157,7 @@ JSON_H = \
   json/json_spirit_utils.h \
   json/json_spirit_value.h \
   json/json_spirit_writer.h \
-  json/json_spirit_writer_template.h \
-  json_spirit_ubjson.h
+  json/json_spirit_writer_template.h
 
 obj/build.h: FORCE
 	@$(MKDIR_P) $(builddir)/obj
@@ -179,8 +178,6 @@ libbitcoin_server_a_SOURCES = \
   core/main.cpp \
   protocol/multichaintx.cpp \
   protocol/multichainblock.cpp \
-  custom/custom_server.cpp \
-  protocol/relay.cpp \
   protocol/handshake.cpp \
   chain/merkleblock.cpp \
   miner/miner.cpp \
@@ -190,11 +187,7 @@ libbitcoin_server_a_SOURCES = \
   net/rest.cpp \
   utils/utilparse.cpp \
   json/json_spirit_ubjson.cpp \
-  rpc/rpcrawdata.cpp \
   rpc/rpcutils.cpp \
-  rpc/rpccache.cpp \
-  rpc/rpcchunks.cpp \
-  rpc/rpcdebug.cpp \
   rpc/rpchelp.cpp \
   rpc/rpcblockchain.cpp \
   rpc/rpcmining.cpp \
@@ -257,14 +250,10 @@ multichain_libbitcoin_multichain_a_SOURCES = \
   utils/tools.cpp \
   utils/utilwrapper.cpp \
   version/version.cpp \
-  custom/custom.cpp \
-  custom/custom_multichain.cpp \
   chainparams/params.cpp \
   protocol/multichainscript.cpp \
   utils/dbwrapper.cpp \
   wallet/wallettxdb.cpp \
-  wallet/chunkdb.cpp \
-  wallet/chunkcollector.cpp \
   permissions/permission.cpp \
   entities/asset.cpp
 
@@ -522,14 +511,10 @@ libbitcoinconsensus_la_SOURCES = \
   utils/utilwrapper.cpp \
   chainparams/buildgenesis.cpp \
   version/version.cpp \
-  custom/custom.cpp \
-  custom/custom_multichain.cpp \
   chainparams/chainparams.cpp \
   protocol/multichainscript.cpp \
   utils/dbwrapper.cpp \
   wallet/wallettxdb.cpp \
-  wallet/chunkdb.cpp \
-  wallet/chunkcollector.cpp \
   permissions/permission.cpp \
   entities/asset.cpp \
   structs/hash.cpp \
diff --git a/src/chainparams/buildgenesis.cpp b/src/chainparams/buildgenesis.cpp
index 13a8e14..2c8a966 100644
--- a/src/chainparams/buildgenesis.cpp
+++ b/src/chainparams/buildgenesis.cpp
@@ -125,11 +125,14 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
     root_stream_name_size=0;
     root_stream_name=NULL;
     
-    root_stream_name=(unsigned char *)GetParam("rootstreamname",&root_stream_name_size);        
-    if(IsProtocolMultichain() == 0)
+    if(mc_gState->m_Features->Streams())
     {
-        root_stream_name_size=0;
-    }    
+        root_stream_name=(unsigned char *)GetParam("rootstreamname",&root_stream_name_size);        
+        if(IsProtocolMultichain() == 0)
+        {
+            root_stream_name_size=0;
+        }    
+    }
     
     while(look_for_genesis)
     {                
@@ -138,7 +141,7 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
         
         txNew.vin.resize(1);
         
-        if(root_stream_name_size > 1)
+        if(root_stream_name_size > ( (mc_gState->m_Features->FixedIn10008() != 0) ? 1 : 0 ))
         {
             txNew.vout.resize(2);                        
         }
@@ -167,7 +170,14 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
             
             lpScript=new mc_Script;
             
-            lpScript->SetPermission(MC_PTP_GLOBAL_ALL,0,0xffffffff,timestamp);
+            if(mc_gState->m_Features->Streams())
+            {
+                lpScript->SetPermission(MC_PTP_GLOBAL_ALL,0,0xffffffff,timestamp);
+            }
+            else
+            {
+                lpScript->SetPermission(MC_PTP_ALL,0,0xffffffff,timestamp);                
+            }
             
             elem = lpScript->GetData(0,&elem_size);
             txNew.vout[0].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
@@ -175,7 +185,7 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
             delete lpScript;            
         }
 
-        if(root_stream_name_size > 1)
+        if(root_stream_name_size > ( (mc_gState->m_Features->FixedIn10008() != 0) ? 1 : 0 ))
         {        
             txNew.vout[1].nValue=0;
             lpDetails=new mc_Script;
@@ -186,9 +196,12 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
                 lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ANYONE_CAN_WRITE,&b,1);        
             }
             
-            if( (root_stream_name_size > 1) && (root_stream_name[root_stream_name_size - 1] == 0x00) )
+            if(mc_gState->m_Features->FixedIn10007())
             {
-                root_stream_name_size--;
+                if( (root_stream_name_size > 1) && (root_stream_name[root_stream_name_size - 1] == 0x00) )
+                {
+                    root_stream_name_size--;
+                }
             }
             
             lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,root_stream_name,root_stream_name_size);
@@ -199,11 +212,44 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
     
             lpDetailsScript=new mc_Script;
             
-            lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
+            if(mc_gState->m_Features->OpDropDetailsScripts())
+            {
+                lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
 
-            elem = lpDetailsScript->GetData(0,&elem_size);
-            txNew.vout[1].scriptPubKey=CScript();
-            txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                        
+                elem = lpDetailsScript->GetData(0,&elem_size);
+                txNew.vout[1].scriptPubKey=CScript();
+                txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                        
+            }
+            else
+            {                
+                lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM);
+
+                lpDetailsScript->SetGeneralDetails(script,bytes);
+                txNew.vout[1].scriptPubKey=CScript();
+
+                for(int e=0;e<lpDetailsScript->GetNumElements();e++)
+                {
+                    elem = lpDetailsScript->GetData(e,&elem_size);
+                    if(e == (lpDetailsScript->GetNumElements() - 1) )
+                    {
+                        if(elem_size > 0)
+                        {
+                            txNew.vout[1].scriptPubKey << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+                        }
+                        else
+                        {
+                            txNew.vout[1].scriptPubKey << OP_RETURN;
+                        }
+                    }
+                    else
+                    {
+                        if(elem_size > 0)
+                        {
+                            txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
+                        }                
+                    }
+                }
+            }
             
             delete lpDetails;
             delete lpDetailsScript;
@@ -264,6 +310,14 @@ int mc_MultichainParams::Build(const unsigned char* pubkey, int pubkey_size)
     {
         return err;
     }    
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        err=SetParam("genesisopreturnscript","[not set]",9);                        // Some value required to make parameter set valid, but valid value should start from OP_RETURN
+        if(err)
+        {
+            return err;
+        }    
+    }
     
     mc_HexToBin(hash,genesis.GetHash().ToString().c_str(),32);
     err=SetParam("genesishash",(const char*)hash,32);
diff --git a/src/chainparams/chainparams.cpp b/src/chainparams/chainparams.cpp
index dae7d88..4f3d305 100644
--- a/src/chainparams/chainparams.cpp
+++ b/src/chainparams/chainparams.cpp
@@ -554,14 +554,6 @@ public:
         }
     }
     
-    void SetMultiChainParam(const char*param_name,int64_t value)
-    {
-        if(strcmp(param_name,"targetblocktime") == 0)
-        {
-            nTargetSpacing=value;
-        }
-    }
-    
     void SetMultiChainRuntimeParams()
     {
         fMineBlocksOnDemand = GetBoolArg("-mineblocksondemand", false);
@@ -609,12 +601,16 @@ public:
         txNew.vin.resize(1);
 
         root_stream_name_size=0;
-        root_stream_name=(unsigned char *)mc_gState->m_NetworkParams->GetParam("rootstreamname",&root_stream_name_size);        
-        if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+        root_stream_name=NULL;
+        if(mc_gState->m_Features->Streams())
         {
-            root_stream_name_size=0;
-        }    
-        if(root_stream_name_size > 1)
+            root_stream_name=(unsigned char *)mc_gState->m_NetworkParams->GetParam("rootstreamname",&root_stream_name_size);        
+            if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+            {
+                root_stream_name_size=0;
+            }    
+        }
+        if(root_stream_name_size > ( (mc_gState->m_Features->FixedIn10008() != 0) ? 1 : 0 ) )
         {
             txNew.vout.resize(2);                        
         }
@@ -647,7 +643,14 @@ public:
             
             lpScript=new mc_Script;
             
-            lpScript->SetPermission(MC_PTP_GLOBAL_ALL,0,0xffffffff,(uint32_t)mc_gState->m_NetworkParams->GetInt64Param("genesistimestamp"));
+            if(mc_gState->m_Features->Streams())
+            {
+                lpScript->SetPermission(MC_PTP_GLOBAL_ALL,0,0xffffffff,(uint32_t)mc_gState->m_NetworkParams->GetInt64Param("genesistimestamp"));
+            }
+            else
+            {
+                lpScript->SetPermission(MC_PTP_ALL,0,0xffffffff,(uint32_t)mc_gState->m_NetworkParams->GetInt64Param("genesistimestamp"));                
+            }
             
             elem = lpScript->GetData(0,&elem_size);
             txNew.vout[0].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
@@ -655,7 +658,7 @@ public:
             delete lpScript;            
         }
         
-        if(root_stream_name_size > 1)
+        if(root_stream_name_size > ( (mc_gState->m_Features->FixedIn10008() != 0) ? 1 : 0 ))
         {        
             txNew.vout[1].nValue=0;
             lpDetails=new mc_Script;
@@ -667,10 +670,13 @@ public:
             }
 
 
-            if( (root_stream_name_size > 1) && (root_stream_name[root_stream_name_size - 1] == 0x00) )
+            if(mc_gState->m_Features->FixedIn10007())
             {
-                root_stream_name_size--;
-            }           
+                if( (root_stream_name_size > 1) && (root_stream_name[root_stream_name_size - 1] == 0x00) )
+                {
+                    root_stream_name_size--;
+                }           
+            }
 
             
             lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,root_stream_name,root_stream_name_size);
@@ -681,11 +687,44 @@ public:
     
             lpDetailsScript=new mc_Script;
             
-            lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
+            if(mc_gState->m_Features->OpDropDetailsScripts())
+            {
+                lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
 
-            elem = lpDetailsScript->GetData(0,&elem_size);
-            txNew.vout[1].scriptPubKey=CScript();
-            txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                        
+                elem = lpDetailsScript->GetData(0,&elem_size);
+                txNew.vout[1].scriptPubKey=CScript();
+                txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                        
+            }
+            else
+            {                            
+                lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM);
+
+                lpDetailsScript->SetGeneralDetails(script,bytes);
+                txNew.vout[1].scriptPubKey=CScript();
+
+                for(int e=0;e<lpDetailsScript->GetNumElements();e++)
+                {
+                    elem = lpDetailsScript->GetData(e,&elem_size);
+                    if(e == (lpDetailsScript->GetNumElements() - 1) )
+                    {
+                        if(elem_size > 0)
+                        {
+                            txNew.vout[1].scriptPubKey << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+                        }
+                        else
+                        {
+                            txNew.vout[1].scriptPubKey << OP_RETURN;
+                        }
+                    }
+                    else
+                    {
+                        if(elem_size > 0)
+                        {
+                            txNew.vout[1].scriptPubKey << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
+                        }                
+                    }
+                }
+            }
             
             delete lpDetails;
             delete lpDetailsScript;
@@ -742,12 +781,6 @@ void SetMultiChainParams()
     multiChainParams.SetMultiChainParams();
 }
 
-void SetMultiChainParam(const char*param_name,int64_t value)
-{
-    multiChainParams.SetMultiChainParam(param_name,value);
-}
-
-
 void SetMultiChainRuntimeParams()
 {
     multiChainParams.SetMultiChainRuntimeParams();
diff --git a/src/chainparams/chainparams.h b/src/chainparams/chainparams.h
index bd46317..51319d9 100644
--- a/src/chainparams/chainparams.h
+++ b/src/chainparams/chainparams.h
@@ -166,7 +166,6 @@ bool SelectParamsFromCommandLine();
 bool SelectMultiChainParams(const char *NetworkName);
 bool InitializeMultiChainParams();
 void SetMultiChainParams();
-void SetMultiChainParam(const char*param_name,int64_t value);
 void SetMultiChainRuntimeParams();
 
 
diff --git a/src/chainparams/globals.h b/src/chainparams/globals.h
index 0e55f38..35a6bf4 100644
--- a/src/chainparams/globals.h
+++ b/src/chainparams/globals.h
@@ -5,7 +5,6 @@
 #define	GLOBALS_H
 
 mc_State* mc_gState;
-unsigned int MIN_OFFCHAIN_FEE = 0;                                              // new
 unsigned int MIN_RELAY_TX_FEE = 1000;                                           // new
 unsigned int MAX_OP_RETURN_RELAY = 40;                                          // standard.h
 unsigned int MAX_BLOCK_SIZE = 1000000;                                          // block.h
@@ -16,20 +15,11 @@ unsigned int MAX_BLOCK_SIGOPS = 20000;
 unsigned int MAX_TX_SIGOPS = 4000;                                              // main.h
 int COINBASE_MATURITY = 100;                                                    // main.h
 unsigned int MAX_SIZE = 0x02000000;                                             // serialize,h
-unsigned int OFFCHAIN_MSG_PADDING = 2048;                                       // main.h
 int64_t COIN = 100000000;                                                       // amount.h
 int64_t CENT = 1000000;                                                         // amount.h
 int64_t MAX_MONEY = 21000000 * COIN;                                            // amount.h
 unsigned int MAX_SCRIPT_ELEMENT_SIZE=520;                                       // script.h
-int MIN_BLOCKS_BETWEEN_UPGRADES = 100;                                          
 int MAX_OP_RETURN_SHOWN=16384;
-int MAX_STREAM_QUERY_ITEMS=5000;
-int MAX_FORMATTED_DATA_DEPTH=100;
-unsigned int MAX_OP_RETURN_OP_DROP_COUNT=100000000;
-uint32_t JSON_NO_DOUBLE_FORMATTING=0;                             
-int JSON_DOUBLE_DECIMAL_DIGITS=-1;                             
-int MAX_CHUNK_SIZE = 1048576; 
-int MAX_CHUNK_COUNT = 1024; 
 
 int MCP_MAX_STD_OP_RETURN_COUNT=0;
 int64_t MCP_INITIAL_BLOCK_REWARD=0;
diff --git a/src/chainparams/paramlist.h b/src/chainparams/paramlist.h
index 9678e79..c52acf9 100644
--- a/src/chainparams/paramlist.h
+++ b/src/chainparams/paramlist.h
@@ -27,25 +27,13 @@ static const mc_OneMultichainParam MultichainParamArray[] =
                    "targetblocktime","",
                    "Content of the 'testnet' field of API responses, for compatibility."},
     { "targetblocktime"                        , "target-block-time"                    ,
-                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE | MC_PRM_TIME    , -1,        15,         2,     86400, 0.0, 10001, 0, "-mc-targetblocktime",
+                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE                  , -1,        15,         2,     86400, 0.0, 10001, 0, "-mc-targetblocktime",
                    "maximumblocksize","",
                    "Target time between blocks (transaction confirmation delay), seconds."},
     { "maximumblocksize"                       , "maximum-block-size"               , 
-                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE                  , -1,   8388608,       5000,1000000000, 0.0, 10001, 0, "-mc-maximumblocksize",
-                   "maximumchunksize","",
-                   "Maximum block size in bytes."},
-    { "maximumchunksize"                       , "maximum-chunk-size"               , 
-                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE                  , -1,   1048576,        256,  16777216, 0.0, 20003, 0, "-mc-maximumchunksize",
-                   "maximumchunkcount","",
-                   "Maximum chunk size for off-chain items in bytes."},
-    { "maximumchunkcount"                       , "maximum-chunk-count"               , 
-                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE                  , -1,      1024,         16,      2048, 0.0, 20003, 0, "-mc-maximumchunkcount",
-                   "timingupgrademingap","",
-                   "Maximum number of chunks in one off-chain item."},
-    { "timingupgrademingap"                        , "timing-upgrade-min-gap"                    ,
-                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE | MC_PRM_HIDDEN  , -1,        100,        1,     31536000, 0.0, 20002, 0, "-mc-timingupgrademingap",
+                   MC_PRM_UINT32  | MC_PRM_USER | MC_PRM_CLONE                  , -1,   8388608,       1000,1000000000, 0.0, 10001, 0, "-mc-maximumblocksize",
                    "defaultnetworkport","",
-                   "Minimal gap between time-related parameter upgrades. In blocks."},
+                   "Maximum block size in bytes."},
     { "defaultnetworkport"                , "default-network-port"              ,
                    MC_PRM_UINT32  | MC_PRM_GENERATED | MC_PRM_CLONE                  , -1, MC_DEFAULT_NETWORK_PORT,       1024,     65535, 0.0, 10001, 0, "-mc-defaultnetworkport",
                    "defaultrpcport","",
@@ -184,12 +172,8 @@ static const mc_OneMultichainParam MultichainParamArray[] =
                    "Minimum native currency per output (anti-dust), in raw units.\nIf set to -1, this is calculated from minimum-relay-fee."},
     { "maximumperoutput"                     , "maximum-per-output"                     , 
                    MC_PRM_INT64   | MC_PRM_USER | MC_PRM_CLONE                  , -1,         100000000000000,         0,1000000000000000000, 0.0, 10001, 0, "-mc-maximumperoutput",
-                   "minimumoffchainfee","",
-                   "Maximum native currency per output, in raw units."},
-    { "minimumoffchainfee"                     , "minimum-offchain-fee"                     ,
-                   MC_PRM_INT64   | MC_PRM_USER | MC_PRM_CLONE                  , -1,         0,          0,1000000000, 0.0, 20003, 0, "-mc-minimumoffchainfee",
                    "minimumrelayfee","",
-                   "Minimum fee for publishing off-chain data items, per 1000 bytes, in raw units of native currency."},
+                   "Maximum native currency per output, in raw units."},
     { "minimumrelayfee"                     , "minimum-relay-fee"                     ,
                    MC_PRM_INT64   | MC_PRM_USER | MC_PRM_CLONE                  , -1,         0,          0,1000000000, 0.0, 10001, 0, "-mc-minimumrelayfee",
                    "nativecurrencymultiple","",
@@ -238,7 +222,7 @@ static const mc_OneMultichainParam MultichainParamArray[] =
                    "maxstdelementsize","",
                    "Maximum number of OP_DROPs per output in standard transactions."},
     { "maxstdelementsize"                    , "max-std-element-size"                    ,
-                   MC_PRM_INT64   | MC_PRM_USER | MC_PRM_CLONE                  , -1,     40000,        128,     80000, 0.0, 10003, 0, "-mc-maxscriptelementsize",
+                   MC_PRM_INT64   | MC_PRM_USER | MC_PRM_CLONE                  , -1,      8192,        128,     32768, 0.0, 10003, 0, "-mc-maxscriptelementsize",
                    "maxstdopdropsize","",
                    "Maximum size of data elements in standard transactions, in bytes."},
  
diff --git a/src/chainparams/params.cpp b/src/chainparams/params.cpp
index 52d5b52..769e514 100644
--- a/src/chainparams/params.cpp
+++ b/src/chainparams/params.cpp
@@ -18,20 +18,14 @@ int mc_OneMultichainParam::IsRelevant(int version)
 {
     int ret=1;
     
-    int relevant_version=mc_gState->RelevantParamProtocolVersion();
-    if(relevant_version == 0)
-    {
-        relevant_version=version;
-    }
-    
-    if(m_ProtocolVersion > relevant_version)
+    if(m_ProtocolVersion > version)
     {
         ret=0;
     }
     
     if(m_Removed > 0)
     {
-        if(m_Removed <= relevant_version)
+        if(m_Removed <= version)
         {
             ret=0;
         }
@@ -50,7 +44,6 @@ void mc_MultichainParams::Zero()
     m_Size=0;
     m_IsProtocolMultiChain=1;
     m_ProtocolVersion=0;
-    m_RelevantProtocolVersion=0;
     
     m_AssetRefSize=MC_AST_SHORT_TXID_SIZE;
 }
@@ -102,32 +95,6 @@ int64_t mc_MultichainParams::GetInt64Param(const char *param)
     return mc_GetLE(ptr,size);
 }
 
-double mc_MultichainParams::Int64ToDecimal(int64_t value)
-{
-    if(value < 0)
-    {
-        return -((double)(-value) / MC_PRM_DECIMAL_GRANULARITY);
-    }
-    return (double)value / MC_PRM_DECIMAL_GRANULARITY;    
-}
-
-int64_t mc_MultichainParams::DecimalToInt64(double value)
-{
-    return (int64_t)(value*MC_PRM_DECIMAL_GRANULARITY+mc_gState->m_NetworkParams->ParamAccuracy());    
-}
-
-int mc_MultichainParams::GetParamFromScript(char* script,int64_t *value,int *size)
-{
-    char *ptr;    
-    ptr=script;
-    ptr+=strlen(ptr)+1;
-    *size=(int)mc_GetLE(ptr,MC_PRM_PARAM_SIZE_BYTES);
-    ptr+=MC_PRM_PARAM_SIZE_BYTES;
-    *value=mc_GetLE(ptr,*size);
-    ptr+=*size;
-    return ptr-script; 
-}
-
 double mc_MultichainParams::GetDoubleParam(const char *param)
 {
     int n=(int)mc_gState->m_NetworkParams->GetInt64Param(param);
@@ -163,128 +130,6 @@ void* mc_MultichainParams::GetParam(const char *param,int* size)
     return m_lpData+offset;
 }
 
-int mc_MultichainParams::IsParamUpgradeValueInRange(const mc_OneMultichainParam *param,int version,int64_t value)
-{
-    if(value >= param->m_MinIntegerValue)
-    {
-        if(value <= param->m_MaxIntegerValue)
-        {
-            return 1;
-        }        
-    }
-    return 0;
-}
-
-int mc_MultichainParams::CanBeUpgradedByVersion(const char *param,int version,int size)
-{
-    if(m_lpIndex == NULL)
-    {
-        return -MC_PSK_INTERNAL_ERROR;
-    }
-    int index=m_lpIndex->Get(param);
-    if(index<0)
-    {
-        return -MC_PSK_NOT_FOUND;
-    }   
-    int offset=m_lpCoord[2 * index + 0];
-    if(offset<0)
-    {
-        return -MC_PSK_NOT_FOUND;
-    }   
-    
-    if(size > 0)
-    {
-        if(size != m_lpCoord[2 * index + 1])
-        {
-            return -MC_PSK_WRONG_SIZE;
-        }
-    }
-    
-    if(version == 0)
-    {
-        return m_lpCoord[2 * index + 1];        
-    }
-    
-    if(strcmp(param,"maximumblocksize") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"targetblocktime") == 0)
-    {
-        if(GetInt64Param("targetadjustfreq") >= 0)
-        {
-            if(version >= 20002)
-            {
-                return m_lpCoord[2 * index + 1];
-            }
-        }
-    }
-    
-    if(strcmp(param,"maxstdtxsize") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maxstdopreturnscount") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maxstdopreturnsize") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maxstdopdropscount") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maxstdelementsize") == 0)
-    {
-        if(version >= 20002)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maximumchunksize") == 0)
-    {
-        if(version >= 20003)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    if(strcmp(param,"maximumchunkcount") == 0)
-    {
-        if(version >= 20003)
-        {
-            return m_lpCoord[2 * index + 1];
-        }
-    }
-    
-    
-    
-    return 0;
-}
-
 
 int mc_MultichainParams::SetParam(const char *param,const char* value,int size)
 {
@@ -418,7 +263,6 @@ int mc_MultichainParams::Create(const char* name,int version)
     mc_OneMultichainParam *param;
     char *ptrData;
     int num_sets;
-    int64_t override_int64;
     uint32_t network_port=MC_DEFAULT_NETWORK_PORT;
     uint32_t rpc_port=MC_DEFAULT_RPC_PORT;
     
@@ -497,14 +341,6 @@ int mc_MultichainParams::Create(const char* name,int version)
                             case MC_PRM_INT64:
                                 size=8;
                                 mc_PutLE(ptrData,&(param->m_DefaultIntegerValue),8);
-                                if(strcmp(param->m_Name,"maxstdelementsize") == 0)
-                                {
-                                    if(version<20003)
-                                    {
-                                        override_int64=8192;
-                                        mc_PutLE(ptrData,&override_int64,8);
-                                    }
-                                }                                   
                                 break;
                             case MC_PRM_DOUBLE:
                                 size=8;
@@ -611,19 +447,6 @@ double mc_MultichainParams::ParamAccuracy()
 }
 
 
-const mc_OneMultichainParam *mc_MultichainParams::FindParam(const char* param)
-{
-    int i;
-    for(i=0;i<m_Count;i++)
-    {
-        if(strcmp((MultichainParamArray+i)->m_Name,param) == 0)
-        {
-            return MultichainParamArray+i;
-        }        
-    }    
-    return NULL;
-}
-
 int mc_MultichainParams::Read(const char* name)
 {
     return Read(name,0,NULL,0);
@@ -637,7 +460,6 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
     mc_OneMultichainParam *param;
     char *ptrData;
     const char *ptr;
-    unsigned char custom_param[8];
     
     if(name == NULL)
     {
@@ -872,12 +694,7 @@ int mc_MultichainParams::Read(const char* name,int argc, char* argv[],int create
 
                 ptrData=m_lpData+offset+MC_PRM_PARAM_SIZE_BYTES;
 
-                ptr=(char*)custom_get_blockchain_default(param->m_Name,&size,custom_param);
-                if(ptr == NULL)
-                {
-                    ptr=(char*)lpDefaultParams->GetParam(param->m_Name,&size);                    
-                }
-                
+                ptr=(char*)lpDefaultParams->GetParam(param->m_Name,&size);
                 if(size)
                 {
                     memcpy(ptrData,ptr,size);
@@ -1270,20 +1087,23 @@ int mc_MultichainParams::Validate()
         if(isGenerated)
         {
             m_Status=MC_PRM_STATUS_GENERATED;
-            dv=2*(double)GetInt64Param("rewardhalvinginterval");
-            dv*=(double)GetInt64Param("initialblockreward");
-            iv=GetInt64Param("firstblockreward");
-            if(iv<0)
-            {
-                iv=GetInt64Param("initialblockreward");
-            }
-            dv+=(double)iv;
-            if(dv > 9.e+18)
+            iv=GetInt64Param("targetblocktime");
+            if(iv>0)
             {
-                printf("Total mining reward over blockchain's history is more than 2^63 raw units. Please reduce initial-block-reward or reward-halving-interval.\n");
-                return MC_ERR_INVALID_PARAMETER_VALUE;                                                                                    
-            }
-            
+                dv=2*(double)GetInt64Param("rewardhalvinginterval")/(double)iv;
+                dv*=(double)GetInt64Param("initialblockreward");
+                iv=GetInt64Param("firstblockreward");
+                if(iv<0)
+                {
+                    iv=GetInt64Param("initialblockreward");
+                }
+                dv+=(double)iv;
+                if(dv > 9.e+18)
+                {
+                    printf("Total mining reward over blockchain's history is more than 2^63 raw units. Please reduce initial-block-reward or reward-halving-interval.\n");
+                    return MC_ERR_INVALID_PARAMETER_VALUE;                                                                                    
+                }
+           }
             GetParam("chaindescription",&size);
             if(size-1 > 90)                                                     
             {
@@ -1312,7 +1132,7 @@ int mc_MultichainParams::Print(FILE* fileHan)
     int i,c,size;
     int version;
     int header_printed;
-    int set,chars_remaining,hidden;
+    int set,chars_remaining;
     void *ptr;
     char line[MC_PRM_DAT_FILE_LINE_SIZE+1+100];
     char *cptr;
@@ -1370,7 +1190,6 @@ int mc_MultichainParams::Print(FILE* fileHan)
             if( (((m_lpParams+i)->m_Type & MC_PRM_SOURCE_MASK) == param_sets[set]) && 
                     ((m_lpParams+i)->IsRelevant(version) > 0))
             {
-                hidden=0;
                 if(header_printed == 0)
                 {
                     fprintf(fileHan,"\n");
@@ -1531,13 +1350,6 @@ int mc_MultichainParams::Print(FILE* fileHan)
                             else
                             {
                                 sprintf(line+strlen(line),"%ld",mc_GetLE(ptr,4));                                                                
-                                if((m_lpParams+i)->m_Type & MC_PRM_HIDDEN)
-                                {
-                                    if(mc_GetLE(ptr,4) == (m_lpParams+i)->m_DefaultIntegerValue)
-                                    {
-                                        hidden=1;
-                                    }
-                                }
                             }
                             break;
                         case MC_PRM_INT64:
@@ -1552,79 +1364,76 @@ int mc_MultichainParams::Print(FILE* fileHan)
                 {
                     sprintf(line+strlen(line),"[null]");                                                                                    
                 }
-                if(hidden == 0)
+                if(chars_remaining == 0)
                 {
-                    if(chars_remaining == 0)
+                    fprintf(fileHan,"%s",line);
+                    chars_remaining=MC_PRM_DAT_FILE_LINE_SIZE-strlen(line)+1;
+                }
+                for(c=0;c<chars_remaining;c++)
+                {
+                    fprintf(fileHan," ");
+                }
+                cptr=(m_lpParams+i)->m_Description;
+                while(*cptr)
+                {
+                    c=0;
+                    
+                    while((c<(int)strlen(cptr)) && (cptr[c]!='\n'))
                     {
-                        fprintf(fileHan,"%s",line);
-                        chars_remaining=MC_PRM_DAT_FILE_LINE_SIZE-strlen(line)+1;
+                        c++;
                     }
-                    for(c=0;c<chars_remaining;c++)
+                    
+                    if(c<(int)strlen(cptr))
                     {
-                        fprintf(fileHan," ");
+                        cptr[c]=0x00;
+                        fprintf(fileHan,"# %s",cptr);
+                        memset(line,0x20,MC_PRM_DAT_FILE_LINE_SIZE);
+                        line[MC_PRM_DAT_FILE_LINE_SIZE]=0x00;
+                        fprintf(fileHan,"\n%s ",line);
+                        cptr+=c+1;
                     }
-                    cptr=(m_lpParams+i)->m_Description;
-                    while(*cptr)
+                    else
                     {
-                        c=0;
-
-                        while((c<(int)strlen(cptr)) && (cptr[c]!='\n'))
-                        {
-                            c++;
-                        }
-
-                        if(c<(int)strlen(cptr))
-                        {
-                            cptr[c]=0x00;
-                            fprintf(fileHan,"# %s",cptr);
-                            memset(line,0x20,MC_PRM_DAT_FILE_LINE_SIZE);
-                            line[MC_PRM_DAT_FILE_LINE_SIZE]=0x00;
-                            fprintf(fileHan,"\n%s ",line);
-                            cptr+=c+1;
-                        }
-                        else
-                        {
-                            fprintf(fileHan,"# %s",cptr);
-                            cptr+=c;
-                        }
+                        fprintf(fileHan,"# %s",cptr);
+                        cptr+=c;
                     }
+                }
 
-                    switch((m_lpParams+i)->m_Type & MC_PRM_DATA_TYPE_MASK)
-                    {
-                        case MC_PRM_INT32:
-                        case MC_PRM_INT64:
-                        case MC_PRM_UINT32:
-                            switch(param_sets[set])
-                            {
-                                case MC_PRM_COMMENT:
-                                case MC_PRM_USER:
-                                    if((m_lpParams+i)->m_MinIntegerValue <= (m_lpParams+i)->m_MaxIntegerValue)
+                switch((m_lpParams+i)->m_Type & MC_PRM_DATA_TYPE_MASK)
+                {
+                    case MC_PRM_INT32:
+                    case MC_PRM_INT64:
+                    case MC_PRM_UINT32:
+                        switch(param_sets[set])
+                        {
+                            case MC_PRM_COMMENT:
+                            case MC_PRM_USER:
+                                if((m_lpParams+i)->m_MinIntegerValue <= (m_lpParams+i)->m_MaxIntegerValue)
+                                {
+                                    if((m_lpParams+i)->m_Type & MC_PRM_DECIMAL)
                                     {
-                                        if((m_lpParams+i)->m_Type & MC_PRM_DECIMAL)
+                                        d1=0;
+                                        if((m_lpParams+i)->m_MinIntegerValue)
                                         {
-                                            d1=0;
-                                            if((m_lpParams+i)->m_MinIntegerValue)
-                                            {
-                                                d1=((double)((m_lpParams+i)->m_MinIntegerValue)+ParamAccuracy())/MC_PRM_DECIMAL_GRANULARITY;
-                                            }
-                                            d2=0;
-                                            if((m_lpParams+i)->m_MaxIntegerValue)
-                                            {
-                                                d2=((double)((m_lpParams+i)->m_MaxIntegerValue)+ParamAccuracy())/MC_PRM_DECIMAL_GRANULARITY;
-                                            }
-                                            fprintf(fileHan," (%0.6g - %0.6g)",d1,d2);                            
+                                            d1=((double)((m_lpParams+i)->m_MinIntegerValue)+ParamAccuracy())/MC_PRM_DECIMAL_GRANULARITY;
                                         }
-                                        else
+                                        d2=0;
+                                        if((m_lpParams+i)->m_MaxIntegerValue)
                                         {
-                                            fprintf(fileHan," (%ld - %ld)",(m_lpParams+i)->m_MinIntegerValue,(m_lpParams+i)->m_MaxIntegerValue);                            
+                                            d2=((double)((m_lpParams+i)->m_MaxIntegerValue)+ParamAccuracy())/MC_PRM_DECIMAL_GRANULARITY;
                                         }
+                                        fprintf(fileHan," (%0.6g - %0.6g)",d1,d2);                            
                                     }
-                                    break;
-                            }
-                            break;
-                    }
-                    fprintf(fileHan,"\n");                    
+                                    else
+                                    {
+                                        fprintf(fileHan," (%ld - %ld)",(m_lpParams+i)->m_MinIntegerValue,(m_lpParams+i)->m_MaxIntegerValue);                            
+                                    }
+                                }
+                                break;
+                        }
+                        break;
                 }
+                fprintf(fileHan,"\n");                    
             }
             
             if(strlen((m_lpParams+i)->m_Next))
@@ -1740,10 +1549,6 @@ const unsigned char* mc_MultichainParams::AddressCheckumValue()
 
 int mc_MultichainParams::ProtocolVersion()
 {
-    if(mc_gState->m_NetworkParams->m_RelevantProtocolVersion)
-    {
-        return mc_gState->m_NetworkParams->m_RelevantProtocolVersion;
-    }
     if(m_ProtocolVersion)
     {
         return m_ProtocolVersion;
@@ -1767,35 +1572,70 @@ int mc_Features::MinProtocolVersion()
     return 10004;
 }
 
+int mc_Features::ActivatePermission()                                           // This test is eliminated from the code as 10002 is not supported
+{
+    int ret=0;
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(protocol)
+    {
+        if(protocol >= 10003)
+        {
+            ret=1;
+        }
+    }
+    
+    return ret;
+}
+
 int mc_Features::LastVersionNotSendingProtocolVersionInHandShake()
 {
     return 10002;
 }
 
-int mc_Features::AnyoneCanReceiveEmpty()
+int mc_Features::VerifySizeOfOpDropElements()                                   // This test is still in the code to keep protocol!-multichain untouched
+{
+    
+    int ret=0;        
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return 1;
+    }
+    
+    if(protocol)
+    {
+        if(protocol >= 10003)
+        {
+            ret=1;
+        }
+    }
+    
+    return ret;
+}
+
+int mc_Features::PerEntityPermissions()                                         // This test is eliminated from the code as 10002 is not supported
 {
-    int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
     {
         return 0;
     }
+    int ret=0;
     int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
     
     if(protocol)
     {
-        if(protocol >= 10007)
+        if(protocol >= 10004)
         {
-            if(MCP_ANYONE_CAN_RECEIVE_EMPTY)                                
-            {
-                ret=1;
-            }
+            ret=1;
         }
     }
     
-    return ret;    
+    return ret;
 }
 
-int mc_Features::FormattedData()
+int mc_Features::FollowOnIssues()                                               // This test is eliminated from the code as 10002 is not supported
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1803,10 +1643,25 @@ int mc_Features::FormattedData()
         return 0;
     }
     int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    if(protocol)
+    {
+        if(protocol >= 10004)
+        {
+            ret=1;
+        }
+    }
+    
+    return ret;
+}
+
+int mc_Features::SpecialParamsInDetailsScript()                                 // This test is eliminated from the code as 10002 is not supported
+{
+    int ret=0;
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
     
     if(protocol)
     {
-        if(protocol >= 20001)
+        if(protocol >= 10004)
         {
             ret=1;
         }
@@ -1815,19 +1670,30 @@ int mc_Features::FormattedData()
     return ret;    
 }
 
-int mc_Features::FixedDestinationExtraction()
+int mc_Features::FixedGrantsInTheSameTx()                                       // This test is eliminated from the code as 10002 is not supported
 {
     int ret=0;
-    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(protocol)
     {
-        return 1;
+        if(protocol >= 10004)
+        {
+            ret=1;
+        }
     }
     
+    return ret;    
+}
+
+int mc_Features::UnconfirmedMinersCannotMine()
+{
+    int ret=0;
     int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
     
     if(protocol)
     {
-        if(protocol >= 10009)
+        if(protocol >= 10004)
         {
             ret=1;
         }
@@ -1836,18 +1702,18 @@ int mc_Features::FixedDestinationExtraction()
     return ret;    
 }
 
-int mc_Features::FixedIn1000920001()
+int mc_Features::Streams()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
     {
-        return 1;
+        return 0;
     }
     int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
     
     if(protocol)
     {
-        if(protocol >= 10009)
+        if(protocol >= 10006)
         {
             ret=1;
         }
@@ -1856,7 +1722,7 @@ int mc_Features::FixedIn1000920001()
     return ret;    
 }
 
-int mc_Features::MultipleStreamKeys()
+int mc_Features::OpDropDetailsScripts()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1867,7 +1733,7 @@ int mc_Features::MultipleStreamKeys()
     
     if(protocol)
     {
-        if(protocol >= 20001)
+        if(protocol >= 10007)
         {
             ret=1;
         }
@@ -1876,7 +1742,7 @@ int mc_Features::MultipleStreamKeys()
     return ret;    
 }
 
-int mc_Features::FixedIsUnspendable()
+int mc_Features::ShortTxIDInTx()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1887,7 +1753,7 @@ int mc_Features::FixedIsUnspendable()
     
     if(protocol)
     {
-        if(protocol >= 20001)
+        if(protocol >= 10007)
         {
             ret=1;
         }
@@ -1896,7 +1762,7 @@ int mc_Features::FixedIsUnspendable()
     return ret;    
 }
 
-int mc_Features::PerAssetPermissions()
+int mc_Features::CachedInputScript()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1907,7 +1773,7 @@ int mc_Features::PerAssetPermissions()
     
     if(protocol)
     {
-        if(protocol >= 20002)
+        if(protocol >= 10007)
         {
             ret=1;
         }
@@ -1916,7 +1782,7 @@ int mc_Features::PerAssetPermissions()
     return ret;    
 }
 
-int mc_Features::ParameterUpgrades()
+int mc_Features::AnyoneCanReceiveEmpty()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1927,7 +1793,30 @@ int mc_Features::ParameterUpgrades()
     
     if(protocol)
     {
-        if(protocol >= 20002)
+        if(protocol >= 10007)
+        {
+            if(MCP_ANYONE_CAN_RECEIVE_EMPTY)                                
+            {
+                ret=1;
+            }
+        }
+    }
+    
+    return ret;    
+}
+
+int mc_Features::FixedIn10007()
+{
+    int ret=0;
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return 0;
+    }
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(protocol)
+    {
+        if(protocol >= 10007)
         {
             ret=1;
         }
@@ -1936,7 +1825,7 @@ int mc_Features::ParameterUpgrades()
     return ret;    
 }
 
-int mc_Features::OffChainData()
+int mc_Features::Upgrades()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1947,7 +1836,7 @@ int mc_Features::OffChainData()
     
     if(protocol)
     {
-        if(protocol >= 20003)
+        if(protocol >= 10008)
         {
             ret=1;
         }
@@ -1956,7 +1845,7 @@ int mc_Features::OffChainData()
     return ret;    
 }
 
-int mc_Features::Chunks()
+int mc_Features::FixedIn10008()
 {
     int ret=0;
     if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
@@ -1967,7 +1856,7 @@ int mc_Features::Chunks()
     
     if(protocol)
     {
-        if(protocol >= 20003)
+        if(protocol >= 10008)
         {
             ret=1;
         }
@@ -1976,6 +1865,50 @@ int mc_Features::Chunks()
     return ret;    
 }
 
+int mc_Features::FixedDestinationExtraction()
+{
+    int ret=0;
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return 1;
+    }
+    
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(protocol)
+    {
+        if(protocol >= 10009)
+        {
+            ret=1;
+        }
+    }
+    
+    return ret;    
+}
+
+int mc_Features::FixedIn1000920001()
+{
+    int ret=0;
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return 1;
+    }
+    int protocol=mc_gState->m_NetworkParams->ProtocolVersion();
+    
+    if(protocol)
+    {
+        if(protocol >= 10009)
+        {
+            ret=1;
+        }
+    }
+    
+    return ret;    
+}
+
+
+
+
 
 int mc_Features::FixedIn1001020003()
 {
diff --git a/src/chainparams/params.h b/src/chainparams/params.h
index ba1390c..da1088c 100644
--- a/src/chainparams/params.h
+++ b/src/chainparams/params.h
@@ -37,8 +37,6 @@
 #define MC_PRM_NOHASH           0x00040000
 #define MC_PRM_MINIMAL          0x00080000
 #define MC_PRM_DECIMAL          0x00100000
-#define MC_PRM_HIDDEN           0x00200000
-#define MC_PRM_TIME             0x00400000
 
 
 #define MC_PRM_STATUS_EMPTY              0
@@ -48,26 +46,10 @@
 #define MC_PRM_STATUS_INVALID            4
 #define MC_PRM_STATUS_VALID              5
 
-#define MC_PSK_APPLIED                   0
-#define MC_PSK_INTERNAL_ERROR            1
-#define MC_PSK_NOT_FOUND                 2
-#define MC_PSK_WRONG_SIZE                3
-#define MC_PSK_OUT_OF_RANGE              4
-#define MC_PSK_FRESH_UPGRADE             5
-#define MC_PSK_DOUBLE_RANGE              6
-#define MC_PSK_NOT_SUPPORTED             7
-#define MC_PSK_NEW_NOT_DOWNGRADABLE      8
-#define MC_PSK_OLD_NOT_DOWNGRADABLE      9
-
-
-
-
 extern int MCP_MAX_STD_OP_RETURN_COUNT;
 extern int64_t MCP_INITIAL_BLOCK_REWARD;
 extern int64_t MCP_FIRST_BLOCK_REWARD;
 extern int MCP_TARGET_BLOCK_TIME;
-extern int MAX_CHUNK_SIZE; 
-extern int MAX_CHUNK_COUNT; 
 extern int MCP_ANYONE_CAN_ADMIN;
 extern int MCP_ANYONE_CAN_MINE;
 extern int MCP_ANYONE_CAN_CONNECT;
@@ -116,7 +98,6 @@ typedef struct mc_MultichainParams
     int m_Count;
     int m_IsProtocolMultiChain;
     int m_ProtocolVersion;
-    int m_RelevantProtocolVersion;
     
     int m_AssetRefSize;
     
@@ -144,24 +125,17 @@ typedef struct mc_MultichainParams
     int Write(int overwrite);
     int Print(FILE *);
     int SetGlobals();
-    int SetProtocolGlobals();
-    int SetUpgradedParamValue(const mc_OneMultichainParam *param,int64_t value);
     int Import(const char *name,const char *source_address);
     int Set(const char *name,const char *source,int source_size);
     
-    const mc_OneMultichainParam *FindParam(const char *param);
+    int FindParam(const char *param);
     void* GetParam(const char *param,int* size);
     int64_t GetInt64Param(const char *param);
     double GetDoubleParam(const char *param);
-    double Int64ToDecimal(int64_t value);
-    int64_t DecimalToInt64(double value);
-    int GetParamFromScript(char* ptr,int64_t *value,int *size);
     
     int SetParam(const char *param,const char* value,int size);
     int SetParam(const char *param,int64_t value);
     
-    int CanBeUpgradedByVersion(const char *param,int version,int size);
-    int IsParamUpgradeValueInRange(const mc_OneMultichainParam *param,int version,int64_t value);
     
     const char* Name();
     const unsigned char* DefaultMessageStart();
diff --git a/src/chainparams/state.h b/src/chainparams/state.h
index 7ba2641..bbe7ca4 100644
--- a/src/chainparams/state.h
+++ b/src/chainparams/state.h
@@ -34,8 +34,6 @@
 #define MC_NPS_INCOMING  0x00000002
 #define MC_NPS_MINING    0x00000004
 #define MC_NPS_REACCEPT  0x00000008
-#define MC_NPS_OFFCHAIN  0x00000010
-#define MC_NPS_CHUNKS    0x00000020
 #define MC_NPS_ALL       0xFFFFFFFF
 
 #define MC_WMD_NONE                  0x00000000
@@ -46,12 +44,8 @@
 #define MC_WMD_DEBUG                 0x01000000
 #define MC_WMD_AUTOSUBSCRIBE_STREAMS 0x02000000
 #define MC_WMD_AUTOSUBSCRIBE_ASSETS  0x04000000
-#define MC_WMD_NO_CHUNK_FLUSH        0x08000000
 #define MC_WMD_AUTO                  0x10000000
 
-#define MC_VCM_NONE                  0x00000000
-#define MC_VCM_1_0                   0x00000001
-
 
 #ifdef	__cplusplus
 extern "C" {
@@ -111,37 +105,27 @@ typedef struct mc_Params
     
 } mc_Params;
 
-typedef struct mc_UpgradeStatus
-{    
-    unsigned char m_EntityShortTxID[MC_ENT_KEY_SIZE];                                
-    uint32_t m_ApprovedBlock;
-    uint32_t m_AppliedBlock;
-    uint32_t m_FirstParam;
-    uint32_t m_LastParam;    
-} mc_UpgradeStatus;
-
-typedef struct mc_UpgradedParameter
-{    
-    const mc_OneMultichainParam *m_Param;
-    int64_t m_Value;    
-    uint32_t m_Block;
-    int32_t m_Skipped; 
-} mc_UpgradedParameter;
-
 typedef struct mc_Features
 {    
     int MinProtocolVersion();
+    int ActivatePermission();
     int LastVersionNotSendingProtocolVersionInHandShake();
+    int VerifySizeOfOpDropElements();
+    int PerEntityPermissions();
+    int FollowOnIssues();
+    int SpecialParamsInDetailsScript();
+    int FixedGrantsInTheSameTx();
+    int UnconfirmedMinersCannotMine();
+    int Streams();
+    int OpDropDetailsScripts();
+    int ShortTxIDInTx();
+    int CachedInputScript();
     int AnyoneCanReceiveEmpty();
-    int FormattedData();
+    int FixedIn10007();
+    int Upgrades();
+    int FixedIn10008();
     int FixedDestinationExtraction();
     int FixedIn1000920001();
-    int MultipleStreamKeys();
-    int FixedIsUnspendable();
-    int PerAssetPermissions();
-    int ParameterUpgrades();
-    int OffChainData();
-    int Chunks();
     int FixedIn1001020003();
     int FixedIn1001120003();
 } mc_Features;
@@ -176,11 +160,6 @@ typedef struct mc_TmpBuffers
     mc_Buffer               *m_RpcABNoMapBuffer1;
     mc_Buffer               *m_RpcABNoMapBuffer2;
     mc_Buffer               *m_RpcEntityRows;
-    mc_Buffer               *m_RpcEntityRowsToMerge;
-    mc_Buffer               *m_RpcEntityRowsFull;
-    mc_SHA256               *m_RpcHasher1;
-    mc_Script               *m_RpcChunkScript1;
-    mc_Script               *m_RelayTmpBuffer;
     
     void  Init()
     {
@@ -198,14 +177,7 @@ typedef struct mc_TmpBuffers
         m_RpcABNoMapBuffer2=new mc_Buffer;
         mc_InitABufferDefault(m_RpcABNoMapBuffer2);
         m_RpcEntityRows=new mc_Buffer;
-        m_RpcEntityRows->Initialize(MC_TDB_ENTITY_KEY_SIZE,MC_TDB_ROW_SIZE,MC_BUF_MODE_DEFAULT);     
-        m_RpcEntityRowsToMerge=new mc_Buffer;
-        m_RpcEntityRowsToMerge->Initialize(MC_TDB_ENTITY_KEY_SIZE,MC_TDB_ROW_SIZE,MC_BUF_MODE_DEFAULT);     
-        m_RpcEntityRowsFull=new mc_Buffer;
-        m_RpcEntityRowsFull->Initialize(MC_TDB_ENTITY_KEY_SIZE,MC_TDB_ROW_SIZE,MC_BUF_MODE_DEFAULT);     
-        m_RpcHasher1=new mc_SHA256();
-        m_RpcChunkScript1=new mc_Script();
-        m_RelayTmpBuffer=new mc_Script();
+        m_RpcEntityRows->Initialize(MC_TDB_ENTITY_KEY_SIZE,MC_TDB_ROW_SIZE,MC_BUF_MODE_DEFAULT);        
     }    
 
     void  Destroy()
@@ -220,11 +192,6 @@ typedef struct mc_TmpBuffers
         delete m_RpcABNoMapBuffer1;
         delete m_RpcABNoMapBuffer2;
         delete m_RpcEntityRows;
-        delete m_RpcEntityRowsToMerge;
-        delete m_RpcEntityRowsFull;
-        delete m_RpcHasher1;
-        delete m_RpcChunkScript1;
-        delete m_RelayTmpBuffer;
     }
     
 } mc_TmpBuffers;
@@ -252,15 +219,12 @@ typedef struct mc_State
     uint32_t m_WalletMode;
     int m_ProtocolVersionToUpgrade;
     void *m_pSeedNode;
-    uint32_t m_Compatibility;
     uint32_t m_SessionFlags;
-    unsigned char m_BurnAddress[20];
     
     mc_Script               *m_TmpScript;
     mc_Script               *m_TmpScript1;
     mc_Buffer               *m_TmpAssetsOut;
     mc_Buffer               *m_TmpAssetsIn;
-    mc_Buffer               *m_TmpAssetsTmp;
     
     mc_Buffer               *m_BlockHeaderSuccessors;
     
@@ -279,7 +243,6 @@ typedef struct mc_State
         m_NodePausedState=MC_NPS_NONE;
         m_ProtocolVersionToUpgrade=0;
         m_SessionFlags=MC_SSF_DEFAULT;
-        memset(m_BurnAddress,0,20);
         
         m_IPv4Address=0;
         m_WalletMode=0;
@@ -287,9 +250,6 @@ typedef struct mc_State
         mc_InitABufferMap(m_TmpAssetsOut);
         m_TmpAssetsIn=new mc_Buffer;
         mc_InitABufferMap(m_TmpAssetsIn);
-        m_TmpAssetsTmp=new mc_Buffer;
-        mc_InitABufferMap(m_TmpAssetsTmp);
-        m_Compatibility=MC_VCM_NONE;
         
         m_BlockHeaderSuccessors=new mc_Buffer;
         m_BlockHeaderSuccessors->Initialize(sizeof(mc_BlockHeaderInfo),sizeof(mc_BlockHeaderInfo),0);            
@@ -340,10 +300,6 @@ typedef struct mc_State
         {
             delete m_TmpAssetsIn;
         }
-        if(m_TmpAssetsTmp)
-        {
-            delete m_TmpAssetsTmp;
-        }
         if(m_BlockHeaderSuccessors)
         {
             delete m_BlockHeaderSuccessors;
@@ -354,16 +310,11 @@ typedef struct mc_State
         }
     }
     
-    int VersionInfo(int version);
+    const char* GetVersion();
+    const char* GetFullVersion();
     int GetNumericVersion();
     int GetWalletDBVersion();
     int GetProtocolVersion();
-    int MinProtocolVersion();
-    int MinProtocolDowngradeVersion();
-    int MinProtocolForbiddenDowngradeVersion();
-    int RelevantParamProtocolVersion();
-    int IsSupported(int version);
-    int IsDeprecated(int version);
     const char* GetSeedNode();
 } cs_State;
 
diff --git a/src/core/init-cold.cpp b/src/core/init-cold.cpp
index 14ef804..7e7d3f0 100644
--- a/src/core/init-cold.cpp
+++ b/src/core/init-cold.cpp
@@ -384,7 +384,7 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
 /* MCHN START */    
     if(mc_gState->m_NetworkParams->IsProtocolMultichain())
     {
-        LogPrintf("MultiChain offline version build %s protocol %s (%s)\n", mc_BuildDescription(mc_gState->GetNumericVersion()), mc_gState->GetProtocolVersion(), CLIENT_DATE);
+        LogPrintf("MultiChain offline version %s (%s)\n", mc_gState->GetFullVersion(), CLIENT_DATE);
     }
 
 /* MCHN END */    
@@ -462,7 +462,7 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
             char fileName[MC_DCT_DB_MAX_PATH];
             mc_GetFullFileName(mc_gState->m_Params->NetworkName(),"params", ".dat",MC_FOM_RELATIVE_TO_DATADIR,fileName);
             string seed_error=strprintf("Couldn't retrieve blockchain parameters from the seed node in offline mode.\n"
-                        "The file %s must be copied manually from an existing node.\n",                
+                        "The file %s must be copied manually from an existing node into empty blockchain directory.\n",                
                     fileName);
             return InitError(seed_error);                        
         }        
@@ -530,31 +530,33 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
         vector <mc_TxEntity> vSubscribedEntities;
         if(GetBoolArg("-reindex", false) || GetBoolArg("-rescan", false))
         {
-            pwalletTxsMain=new mc_WalletTxs;
-            if(pwalletTxsMain->Initialize(mc_gState->m_NetworkParams->Name(),MC_WMD_TXS | MC_WMD_ADDRESS_TXS) == MC_ERR_NOERROR)
+            if(mc_gState->m_Features->Streams())
             {
-                mc_Buffer *entity_list;
-                entity_list=pwalletTxsMain->GetEntityList();
-                for(int e=0;e<entity_list->GetCount();e++)
+                pwalletTxsMain=new mc_WalletTxs;
+                if(pwalletTxsMain->Initialize(mc_gState->m_NetworkParams->Name(),MC_WMD_TXS | MC_WMD_ADDRESS_TXS) == MC_ERR_NOERROR)
                 {
-                    mc_TxEntityStat *stat;
-                    stat=(mc_TxEntityStat *)entity_list->GetRow(e);
-                    switch(stat->m_Entity.m_EntityType & MC_TET_TYPE_MASK)
+                    mc_Buffer *entity_list;
+                    entity_list=pwalletTxsMain->GetEntityList();
+                    for(int e=0;e<entity_list->GetCount();e++)
                     {
-                        case MC_TET_PUBKEY_ADDRESS:
-                        case MC_TET_SCRIPT_ADDRESS:
-                        case MC_TET_STREAM:
-                        case MC_TET_STREAM_KEY:
-                        case MC_TET_STREAM_PUBLISHER:
-                            vSubscribedEntities.push_back(stat->m_Entity);
-                            break;
+                        mc_TxEntityStat *stat;
+                        stat=(mc_TxEntityStat *)entity_list->GetRow(e);
+                        switch(stat->m_Entity.m_EntityType & MC_TET_TYPE_MASK)
+                        {
+                            case MC_TET_PUBKEY_ADDRESS:
+                            case MC_TET_SCRIPT_ADDRESS:
+                            case MC_TET_STREAM:
+                            case MC_TET_STREAM_KEY:
+                            case MC_TET_STREAM_PUBLISHER:
+                                vSubscribedEntities.push_back(stat->m_Entity);
+                                break;
+                        }
                     }
+                    __US_Sleep(1000);
                 }
-                __US_Sleep(1000);
+                pwalletTxsMain->Destroy();
+                delete pwalletTxsMain;            
             }
-            pwalletTxsMain->Destroy();
-            delete pwalletTxsMain;            
-
             mc_RemoveDir(mc_gState->m_Params->NetworkName(),"wallet");            
             zap_wallet_txs=true;
         }
@@ -828,10 +830,11 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
     
     pwalletMain=NULL;
 
+    string rpc_threads_error="";
     if (fServer)
     {
         uiInterface.InitMessage.connect(SetRPCWarmupStatus);
-        StartRPCThreads();
+        StartRPCThreads(rpc_threads_error);
     }
 /* MCHN END*/        
     
@@ -953,7 +956,8 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
                 // If the loaded chain has a wrong genesis, bail out immediately
                 // (we're likely using a testnet datadir, or the other way around).
                 if (!mapBlockIndex.empty() && mapBlockIndex.count(Params().HashGenesisBlock()) == 0)
-                    return InitError(_("Incorrect or no genesis block found. Wrong datadir for network?"));
+                    return InitError(_("This blockchain was created with a different params.dat file, please restore the original."));
+//                    return InitError(_("Incorrect or no genesis block found. Wrong datadir for network?"));
 
                 // Initialize the block index (no-op if non-empty database was already loaded)
                 if (!InitBlockIndex()) {
@@ -1021,6 +1025,14 @@ bool AppInit2_Cold(boost::thread_group& threadGroup,int OutputPipe)
             bytes_written=write(OutputPipe,bufOutput,strlen(bufOutput));        
         }
     }
+    if(rpc_threads_error.size())
+    {
+        if(!GetBoolArg("-shortoutput", false))
+        {    
+            sprintf(bufOutput,"%s\n",rpc_threads_error.c_str());                            
+            bytes_written=write(OutputPipe,bufOutput,strlen(bufOutput));        
+        }            
+    }
     
 
     int version=mc_gState->m_NetworkParams->ProtocolVersion();
diff --git a/src/core/init.cpp b/src/core/init.cpp
index 07ea282..a3a23f1 100644
--- a/src/core/init.cpp
+++ b/src/core/init.cpp
@@ -36,8 +36,6 @@
 #include "structs/base58.h"
 #include "multichain/multichain.h"
 #include "wallet/wallettxs.h"
-#include "protocol/relay.h"
-
 std::string BurnAddress(const std::vector<unsigned char>& vchVersion);
 std::string SetBannedTxs(std::string txlist);
 std::string SetLockedBlock(std::string hash);
@@ -65,9 +63,7 @@ using namespace std;
 CWallet* pwalletMain = NULL;
 mc_WalletTxs* pwalletTxsMain = NULL;
 #endif
-mc_RelayManager* pRelayManager = NULL;
 bool fFeeEstimatesInitialized = false;
-extern int JSON_DOUBLE_DECIMAL_DIGITS;                             
 
 #ifdef WIN32
 // Win32 LevelDB doesn't use filedescriptors, and the ones used for
@@ -220,11 +216,6 @@ void Shutdown()
         delete pwalletTxsMain;
         pwalletTxsMain=NULL;
     }
-    if(pRelayManager)
-    {
-        delete pRelayManager;
-        pRelayManager=NULL;        
-    }
 /* MCHN END */  
 #endif
     globalVerifyHandle.reset();
@@ -327,7 +318,6 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += "  -datadir=<dir>         " + _("Specify data directory") + "\n";
     strUsage += "  -dbcache=<n>           " + strprintf(_("Set database cache size in megabytes (%d to %d, default: %d)"), nMinDbCache, nMaxDbCache, nDefaultDbCache) + "\n";
     strUsage += "  -loadblock=<file>      " + _("Imports blocks from external blk000??.dat file") + " " + _("on startup") + "\n";
-    strUsage += "  -loadblockmaxsize=<n>  " + _("Maximal block size in the files specified in -loadblock") + "\n";
     strUsage += "  -maxorphantx=<n>       " + strprintf(_("Keep at most <n> unconnectable transactions in memory (default: %u)"), DEFAULT_MAX_ORPHAN_TRANSACTIONS) + "\n";
     strUsage += "  -par=<n>               " + strprintf(_("Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)"), -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS) + "\n";
 #ifndef WIN32
@@ -357,7 +347,7 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += "  -listen                " + _("Accept connections from outside (default: 1 if no -proxy or -connect)") + "\n";
     strUsage += "  -maxconnections=<n>    " + strprintf(_("Maintain at most <n> connections to peers (default: %u)"), 125) + "\n";
     strUsage += "  -maxreceivebuffer=<n>  " + strprintf(_("Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)"), 5000) + "\n";
-    strUsage += "  -maxsendbuffer=<n>     " + strprintf(_("Maximum per-connection send buffer, <n>*1000 bytes (default: %u)"), 100000) + "\n";
+    strUsage += "  -maxsendbuffer=<n>     " + strprintf(_("Maximum per-connection send buffer, <n>*1000 bytes (default: %u)"), 1000) + "\n";
     strUsage += "  -onion=<ip:port>       " + strprintf(_("Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: %s)"), "-proxy") + "\n";
     strUsage += "  -onlynet=<net>         " + _("Only connect to nodes in network <net> (ipv4, ipv6 or onion)") + "\n";
     strUsage += "  -permitbaremultisig    " + strprintf(_("Relay non-P2SH multisig (default: %u)"), 1) + "\n";
@@ -399,6 +389,8 @@ std::string HelpMessage(HelpMessageMode mode)
 /* MCHN START */    
     strUsage += "  -walletdbversion=1|2   " + _("Specify wallet version, 1 - not scalable, 2 (default) - scalable") + "\n";
     strUsage += "  -autosubscribe=streams|assets|\"streams,assets\"|\"assets,streams\" " + _("Automatically subscribe to new streams and/or assets") + "\n";
+    strUsage += "  -maxshowndata=<n>      " + strprintf(_("The maximum number of bytes to show in the data field of API responses. (default: %u)"), MAX_OP_RETURN_SHOWN) + "\n";
+    strUsage += "                         " + _("Pieces of data larger than this will be returned as an object with txid, vout and size fields, for use with the gettxoutdata command.") + "\n";
 /* MCHN END */    
     strUsage += "  -zapwallettxes=<mode>  " + _("Delete all wallet transactions and only recover those parts of the blockchain through -rescan on startup") + "\n";
     strUsage += "                         " + _("(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)") + "\n";
@@ -489,6 +481,7 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += "  -offline                                 " + _("Start multichaind in offline mode, no connections to other nodes.") + "\n";
     strUsage += "  -initprivkey=<privkey>                   " + _("Manually set the wallet default address and private key when running multichaind for the first time.") + "\n";
     strUsage += "  -handshakelocal=<address>                " + _("Manually override the wallet address which is used for handshaking with other peers in a MultiChain blockchain.") + "\n";
+    strUsage += "  -hideknownopdrops=<n>                    " + strprintf(_("Remove recognized MultiChain OP_DROP metadata from the responses to JSON_RPC calls (default: %u)"), 0) + "\n";
     strUsage += "  -lockadminminerounds=<n>                 " + _("If set overrides lock-admin-mine-rounds blockchain setting.") + "\n";
     strUsage += "  -miningrequirespeers=<n>                 " + _("If set overrides mining-requires-peers blockchain setting, values 0/1.") + "\n";
     strUsage += "  -mineemptyrounds=<n>                     " + _("If set overrides mine-empty-rounds blockchain setting, values 0.0-1000.0 or -1.") + "\n";
@@ -497,18 +490,8 @@ std::string HelpMessage(HelpMessageMode mode)
     strUsage += "  -shortoutput                             " + _("Only show the node address (if connecting was successful) or an address in the wallet (if connect permissions must be granted by another node)") + "\n";
     strUsage += "  -bantx=<txids>                           " + _("Comma delimited list of banned transactions.") + "\n";
     strUsage += "  -lockblock=<hash>                        " + _("Blocks on branches without this block will be rejected") + "\n";
-    strUsage += "  -chunkquerytimeout=<n>                   " + _("Timeout, after which undelivered chunk is moved to the end of the chunk queue, default 25s") + "\n";
-    strUsage += "  -chunkrequesttimeout=<n>                 " + _("Timeout, after which chunk request is dropped and another source is tried, default 10s") + "\n";
-    strUsage += "  -flushsourcechunks=<n>                   " + _("Flush offchain items created by this node to disk immediately when created, default 1") + "\n";
-
-    strUsage += "\n" + _("MultiChain API response parameters") + "\n";        
-    strUsage += "  -hideknownopdrops=<n>  " + strprintf(_("Remove recognized MultiChain OP_DROP metadata from the responses to JSON-RPC calls (default: %u)"), 0) + "\n";
-    strUsage += "  -maxshowndata=<n>      " + strprintf(_("The maximum number of bytes to show in the data field of API responses. (default: %u)"), MAX_OP_RETURN_SHOWN) + "\n";
-    strUsage += "                         " + _("Pieces of data larger than this will be returned as an object with txid, vout and size fields, for use with the gettxoutdata command.") + "\n";
-    strUsage += "  -maxqueryscanitems=<n> " + strprintf(_("The maximum number of txs to be decoded during JSON-RPC querying commands. (default: %u)"), MAX_STREAM_QUERY_ITEMS) + "\n";
-    strUsage += "  -v1apicompatible=<n>   " + strprintf(_("JSON-RPC calls responses compatible with MultiChain 1.0 (default: %u)"), 0) + "\n";
-//    strUsage += "  -apidecimaldigits=<n>  " + _("maximal number of decimal digits in API output (default: auto)") + "\n";
-           
+    
+    
     strUsage += "\n" + _("Wallet optimization options:") + "\n";
     strUsage += "  -autocombineminconf    " + _("Only automatically combine outputs with at least this number of confirmations, default 1") + "\n";
     strUsage += "  -autocombinemininputs  " + _("Minimum inputs in automatically created combine transaction, default 50") + "\n";
@@ -861,42 +844,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     }
 
 #ifdef ENABLE_WALLET
-    if (mapArgs.count("-mintxfee"))
-    {
-        CAmount n = 0;
-        if (ParseMoney(mapArgs["-mintxfee"], n) && n > 0)
-            CWallet::minTxFee = CFeeRate(n);
-        else
-            return InitError(strprintf(_("Invalid amount for -mintxfee=<amount>: '%s'"), mapArgs["-mintxfee"]));
-    }
-    if (mapArgs.count("-paytxfee"))
-    {
-        CAmount nFeePerK = 0;
-        if (!ParseMoney(mapArgs["-paytxfee"], nFeePerK))
-            return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s'"), mapArgs["-paytxfee"]));
-        if (nFeePerK > nHighTransactionFeeWarning)
-            InitWarning(_("Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction."));
-        payTxFee = CFeeRate(nFeePerK, 1000);
-        if (payTxFee < ::minRelayTxFee)
-        {
-            return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)"),
-                                       mapArgs["-paytxfee"], ::minRelayTxFee.ToString()));
-        }
-    }
-    if (mapArgs.count("-maxtxfee"))
-    {
-        CAmount nMaxFee = 0;
-        if (!ParseMoney(mapArgs["-maxtxfee"], nMaxFee))
-            return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s'"), mapArgs["-maptxfee"]));
-        if (nMaxFee > nHighTransactionMaxFeeWarning)
-            InitWarning(_("Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction."));
-        maxTxFee = nMaxFee;
-        if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)
-        {
-            return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)"),
-                                       mapArgs["-maxtxfee"], ::minRelayTxFee.ToString()));
-        }
-    }
     nTxConfirmTarget = GetArg("-txconfirmtarget", 1);
     bSpendZeroConfChange = GetArg("-spendzeroconfchange", true);
     fSendFreeTransactions = GetArg("-sendfreetransactions", false);
@@ -949,7 +896,7 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
 /* MCHN START */    
     if(mc_gState->m_NetworkParams->IsProtocolMultichain())
     {
-        LogPrintf("MultiChain version build %s protocol %s (%s)\n", mc_BuildDescription(mc_gState->GetNumericVersion()), mc_gState->GetProtocolVersion(), CLIENT_DATE);
+        LogPrintf("MultiChain version %s (%s)\n", mc_gState->GetFullVersion(), CLIENT_DATE);
     }
 
 /* MCHN END */    
@@ -1045,11 +992,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     uiInterface.InitMessage(_("Initializing multichain..."));
     RegisterNodeSignals(GetNodeSignals());
 
-    if(GetBoolArg("-v1apicompatible",false))
-    {
-        mc_gState->m_Compatibility |= MC_VCM_1_0;
-    }
-
     if(GetBoolArg("-offline",false))
     {
         if(mc_gState->m_NetworkParams->m_Status != MC_PRM_STATUS_VALID)
@@ -1066,8 +1008,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     
     bool fFirstRunForBuild;
     string init_privkey=GetArg("-initprivkey","");
-
-    mc_gState->m_NetworkParams->m_RelevantProtocolVersion=mc_gState->RelevantParamProtocolVersion(); // Caching relevant protocol version
     
     pwalletMain=NULL;
     if(mc_gState->m_NetworkParams->m_Status != MC_PRM_STATUS_VALID)
@@ -1220,38 +1160,38 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
                 }
             }
 
-            if(mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL)
+            if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+                (mc_gState->GetProtocolVersion() < (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) )
             {
-                int protocol_version=(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
-            
-                if(mc_gState->IsSupported(protocol_version) == 0) 
+                seed_error=strprintf("Couldn't connect to the seed node %s on port %d.\n"
+                            "Blockchain was created by multichaind with newer protocol version (%d)\n"                
+                            "Please upgrade to the latest version of MultiChain or connect only to blockchains using protocol version %d or earlier.\n",                
+                        seed_ip.c_str(),seed_port,(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"), mc_gState->GetProtocolVersion());
+            }
+            else
+            {                                
+                if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+                    (mc_gState->m_Features->MinProtocolVersion() > (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) && 
+                    (mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL) != NULL) && 
+                    (strcmp((char*)mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL),"multichain") == 0) )
                 {
-                    if(mc_gState->IsDeprecated(protocol_version))
-                    {
-                        seed_error=strprintf("The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain %s\n",                
-                                protocol_version, mc_gState->m_Params->NetworkName(),
-                                mc_BuildDescription(-mc_gState->VersionInfo(protocol_version)));                    
-                        return InitError(seed_error);                                
-                    }
-                    else
+                    seed_error=strprintf("The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain 1.0 beta 1\n",                
+                            (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"), mc_gState->m_Params->NetworkName());                    
+                    return InitError(seed_error);            
+                }
+                else
+                {                                
+                    if(mc_gState->m_NetworkState == MC_NTS_SEED_NO_PARAMS)
                     {
-                        seed_error=strprintf("Couldn't connect to the seed node %s on port %d.\n"
-                                    "Blockchain was created by multichaind with newer protocol version (%d)\n"                
-                                    "Please upgrade to the latest version of MultiChain or connect only to blockchains using protocol version %d or earlier.\n",                
-                                seed_ip.c_str(),seed_port,protocol_version, mc_gState->GetProtocolVersion());                        
+                        char fileName[MC_DCT_DB_MAX_PATH];
+                        mc_GetFullFileName(mc_gState->m_Params->NetworkName(),"params", ".dat",MC_FOM_RELATIVE_TO_DATADIR,fileName);
+                        seed_error=strprintf("Couldn't retrieve blockchain parameters from the seed node %s on port %d.\n"
+                                    "For bitcoin protocol blockchains, the file %s must be copied manually from an existing node.",                
+                                seed_ip.c_str(),seed_port,fileName);
+
                     }
                 }
             }
-                    
-            if(mc_gState->m_NetworkState == MC_NTS_SEED_NO_PARAMS)
-            {
-                char fileName[MC_DCT_DB_MAX_PATH];
-                mc_GetFullFileName(mc_gState->m_Params->NetworkName(),"params", ".dat",MC_FOM_RELATIVE_TO_DATADIR,fileName);
-                seed_error=strprintf("Couldn't retrieve blockchain parameters from the seed node %s on port %d.\n"
-                            "For bitcoin protocol blockchains, the file %s must be copied manually from an existing node.",                
-                        seed_ip.c_str(),seed_port,fileName);
-
-            }
             
             LogPrintf("mchn: Exited from paramset discovery thread\n");        
 
@@ -1353,9 +1293,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
             return InitError(_(seed_error.c_str()));        
         }
         
-        string strBurnAddress=BurnAddress(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS)); // Caching burn address
-        LogPrint("mchn","mchn: Burn address: %s\n",strBurnAddress.c_str());                
-        
         int64_t wallet_mode=GetArg("-walletdbversion",0);
         bool wallet_mode_valid=false;
         if(wallet_mode == 0)
@@ -1389,32 +1326,34 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
         vector <mc_TxEntity> vSubscribedEntities;
         if(GetBoolArg("-reindex", false) || GetBoolArg("-rescan", false))
         {
-            pwalletTxsMain=new mc_WalletTxs;
-            if(pwalletTxsMain->Initialize(mc_gState->m_NetworkParams->Name(),MC_WMD_TXS | MC_WMD_ADDRESS_TXS) == MC_ERR_NOERROR)
+            if(mc_gState->m_Features->Streams())
             {
-                mc_Buffer *entity_list;
-                entity_list=pwalletTxsMain->GetEntityList();
-                for(int e=0;e<entity_list->GetCount();e++)
+                pwalletTxsMain=new mc_WalletTxs;
+                if(pwalletTxsMain->Initialize(mc_gState->m_NetworkParams->Name(),MC_WMD_TXS | MC_WMD_ADDRESS_TXS) == MC_ERR_NOERROR)
                 {
-                    mc_TxEntityStat *stat;
-                    stat=(mc_TxEntityStat *)entity_list->GetRow(e);
-                    switch(stat->m_Entity.m_EntityType & MC_TET_TYPE_MASK)
+                    mc_Buffer *entity_list;
+                    entity_list=pwalletTxsMain->GetEntityList();
+                    for(int e=0;e<entity_list->GetCount();e++)
                     {
-                        case MC_TET_PUBKEY_ADDRESS:
-                        case MC_TET_SCRIPT_ADDRESS:
-                        case MC_TET_STREAM:
-                        case MC_TET_STREAM_KEY:
-                        case MC_TET_STREAM_PUBLISHER:
-                        case MC_TET_ASSET:
-                            vSubscribedEntities.push_back(stat->m_Entity);
-                            break;
+                        mc_TxEntityStat *stat;
+                        stat=(mc_TxEntityStat *)entity_list->GetRow(e);
+                        switch(stat->m_Entity.m_EntityType & MC_TET_TYPE_MASK)
+                        {
+                            case MC_TET_PUBKEY_ADDRESS:
+                            case MC_TET_SCRIPT_ADDRESS:
+                            case MC_TET_STREAM:
+                            case MC_TET_STREAM_KEY:
+                            case MC_TET_STREAM_PUBLISHER:
+                            case MC_TET_ASSET:
+                                vSubscribedEntities.push_back(stat->m_Entity);
+                                break;
+                        }
                     }
+                    __US_Sleep(1000);
                 }
-                __US_Sleep(1000);
+                pwalletTxsMain->Destroy();
+                delete pwalletTxsMain;            
             }
-            pwalletTxsMain->Destroy();
-            delete pwalletTxsMain;            
-
             mc_RemoveDir(mc_gState->m_Params->NetworkName(),"wallet");            
             zap_wallet_txs=true;
         }
@@ -1465,10 +1404,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
                 {
                     mc_gState->m_WalletMode |= MC_WMD_DEBUG;
                 }
-                if(GetBoolArg("-nochunkflush",false))
-                {
-                    mc_gState->m_WalletMode |= MC_WMD_NO_CHUNK_FLUSH;
-                }
                 string autosubscribe=GetArg("-autosubscribe","none");
                 
                 if(autosubscribe=="streams")
@@ -1763,15 +1698,52 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     
     pwalletMain=NULL;
 
+    string rpc_threads_error="";
     if (fServer)
     {
-        JSON_DOUBLE_DECIMAL_DIGITS=GetArg("-apidecimaldigits",-1);        
         uiInterface.InitMessage.connect(SetRPCWarmupStatus);
-        StartRPCThreads();
+        StartRPCThreads(rpc_threads_error);
     }
 /* MCHN END*/        
     
-
+        ::minRelayTxFee = CFeeRate(MIN_RELAY_TX_FEE); 
+        if (mapArgs.count("-mintxfee"))
+        {
+            CAmount n = 0;
+            if (ParseMoney(mapArgs["-mintxfee"], n) && n > 0)
+                CWallet::minTxFee = CFeeRate(n);
+            else
+                return InitError(strprintf(_("Invalid amount for -mintxfee=<amount>: '%s'"), mapArgs["-mintxfee"]));
+        }
+        if (mapArgs.count("-paytxfee"))
+        {
+            CAmount nFeePerK = 0;
+            if (!ParseMoney(mapArgs["-paytxfee"], nFeePerK))
+                return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s'"), mapArgs["-paytxfee"]));
+            if (nFeePerK > nHighTransactionFeeWarning)
+                InitWarning(_("Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction."));
+            payTxFee = CFeeRate(nFeePerK, 1000);
+            if (payTxFee < ::minRelayTxFee)
+            {
+                return InitError(strprintf(_("Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)"),
+                                           mapArgs["-paytxfee"], ::minRelayTxFee.ToString()));
+            }
+        }
+        if (mapArgs.count("-maxtxfee"))
+        {
+            CAmount nMaxFee = 0;
+            if (!ParseMoney(mapArgs["-maxtxfee"], nMaxFee))
+                return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s'"), mapArgs["-maptxfee"]));
+            if (nMaxFee > nHighTransactionMaxFeeWarning)
+                InitWarning(_("Warning: -maxtxfee is set very high! Fees this large could be paid on a single transaction."));
+            maxTxFee = nMaxFee;
+            if (CFeeRate(maxTxFee, 1000) < ::minRelayTxFee)
+            {
+                return InitError(strprintf(_("Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)"),
+                                           mapArgs["-maxtxfee"], ::minRelayTxFee.ToString()));
+            }
+        }
+        
 #endif // ENABLE_WALLET
     // ********************************************************* Step 6: network initialization
 
@@ -1873,8 +1845,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
             return InitError(_("Failed to listen on any port. Use -listen=0 if you want this."));
     }
 /* MCHN START */    
-    pRelayManager=new mc_RelayManager;
-    
     int max_ips=64;
     uint32_t all_ips[64];
     int found_ips=1;
@@ -1882,12 +1852,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     {
         found_ips=mc_FindIPv4ServerAddress(all_ips,max_ips);
     }
-    else
-    {
-        all_ips[0]=mc_gState->m_IPv4Address;
-    }
-    pRelayManager->SetMyIPs(all_ips,found_ips);
-    
     if(!GetBoolArg("-shortoutput", false))
     {
         if(fListen && !GetBoolArg("-offline",false))
@@ -2174,6 +2138,14 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
             bytes_written=write(OutputPipe,bufOutput,strlen(bufOutput));        
         }
     }
+    if(rpc_threads_error.size())
+    {
+        if(!GetBoolArg("-shortoutput", false))
+        {    
+            sprintf(bufOutput,"%s\n",rpc_threads_error.c_str());                            
+            bytes_written=write(OutputPipe,bufOutput,strlen(bufOutput));        
+        }            
+    }
     
 //    int version=mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
     int version=mc_gState->m_NetworkParams->ProtocolVersion();
@@ -2393,8 +2365,6 @@ bool AppInit2(boost::thread_group& threadGroup,int OutputPipe)
     if (!strErrors.str().empty())
         return InitError(strErrors.str());
 
-    pRelayManager->Initialize();
-    
 //    RandAddSeedPerfmon();
 
     //// debug print
diff --git a/src/core/init.h b/src/core/init.h
index f0ee4bd..0a0cfde 100644
--- a/src/core/init.h
+++ b/src/core/init.h
@@ -11,7 +11,6 @@
 
 class CWallet;
 struct mc_WalletTxs;
-struct mc_RelayManager;
 
 namespace boost
 {
@@ -20,7 +19,6 @@ class thread_group;
 
 extern CWallet* pwalletMain;
 extern mc_WalletTxs* pwalletTxsMain;
-extern mc_RelayManager* pRelayManager;
 
 
 void StartShutdown();
diff --git a/src/core/main.cpp b/src/core/main.cpp
index 175edd5..7148779 100644
--- a/src/core/main.cpp
+++ b/src/core/main.cpp
@@ -5,6 +5,7 @@
 // MultiChain code distributed under the GPLv3 license, see COPYING file.
 
 #include "core/main.h"
+#include "version/version.h"
 
 #include "storage/addrman.h"
 #include "structs/alert.h"
@@ -30,11 +31,10 @@
 #include "multichain/multichain.h"
 #include "wallet/wallettxs.h"
 #include "script/script.h"
-#include "protocol/relay.h"
 
 
 extern mc_WalletTxs* pwalletTxsMain;
-extern mc_RelayManager* pRelayManager;
+
 
 /* MCHN END */
 
@@ -53,7 +53,6 @@ bool AcceptMultiChainTransaction(const CTransaction& tx,
                                  int offset,
                                  bool accept,
                                  string& reason,
-                                 int64_t *mandatory_fee_out,     
                                  uint32_t *replay);
 bool ExtractDestinationScriptValid(const CScript& scriptPubKey, CTxDestination& addressRet);
 bool AcceptAssetTransfers(const CTransaction& tx, const CCoinsViewCache &inputs, string& reason);
@@ -63,7 +62,6 @@ bool ReplayMemPool(CTxMemPool& pool, int from,bool accept);
 bool VerifyBlockSignature(CBlock *block,bool force);
 bool VerifyBlockMiner(CBlock *block,CBlockIndex* pindexNew);
 bool CheckBlockPermissions(const CBlock& block,CBlockIndex* prev_block,unsigned char *lpMinerAddress);
-bool ProcessMultichainRelay(CNode* pfrom, CDataStream& vRecv, CValidationState &state);
 bool ProcessMultichainVerack(CNode* pfrom, CDataStream& vRecv,bool fIsVerackack,bool *disconnect_flag);
 bool PushMultiChainVerack(CNode* pfrom, bool fIsVerackack);
 bool MultichainNode_CanConnect(CNode *pnode);
@@ -74,9 +72,7 @@ bool MultichainNode_SendInv(CNode *pnode);
 bool MultichainNode_AcceptData(CNode *pnode);
 bool MultichainNode_IgnoreIncoming(CNode *pnode);
 bool MultichainNode_IsLocal(CNode *pnode);
-bool MultichainNode_CollectChunks();
 bool IsTxBanned(uint256 txid);
-int CreateUpgradeLists(int current_height,vector<mc_UpgradedParameter> *vParams,vector<mc_UpgradeStatus> *vUpgrades);
 
 
 
@@ -352,154 +348,7 @@ map<NodeId, CNodeState> mapNodeState;
 
 /* MCHN START */
 
-int SetUpgradedParamValue(const mc_OneMultichainParam *param,int64_t value)
-{
-    if(mc_gState->m_Features->ParameterUpgrades() == 0)
-    {
-        return MC_ERR_NOERROR;        
-    }
-    
-    if(strcmp(param->m_Name,"maximumblocksize") == 0)
-    {
-        MAX_BLOCK_SIZE=(unsigned int)value;    
-        DEFAULT_BLOCK_MAX_SIZE=MAX_BLOCK_SIZE;    
-        while(MAX_BLOCK_SIZE>MAX_BLOCKFILE_SIZE)
-        {
-            MAX_BLOCKFILE_SIZE *= 2;
-        }
-        while(MAX_BLOCK_SIZE>MAX_SIZE)
-        {
-            MAX_SIZE *= 2;
-        }
-        MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;
-        MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;        
-    }
-
-    if(strcmp(param->m_Name,"targetblocktime") == 0)
-    {
-        MCP_TARGET_BLOCK_TIME=value;
-        SetMultiChainParam("targetblocktime",value);
-    }   
-    
-    if(strcmp(param->m_Name,"maxstdtxsize") == 0)
-    {
-        MAX_STANDARD_TX_SIZE=value;
-    }   
-    
-    if(strcmp(param->m_Name,"maxstdopreturnscount") == 0)
-    {
-        MCP_MAX_STD_OP_RETURN_COUNT=value;
-    }   
-    
-    if(strcmp(param->m_Name,"maxstdopreturnsize") == 0)
-    {
-        MAX_OP_RETURN_RELAY=value;    
-        MAX_OP_RETURN_RELAY=GetArg("-datacarriersize", MAX_OP_RETURN_RELAY);
-    }   
-    
-    if(strcmp(param->m_Name,"maxstdopdropscount") == 0)
-    {
-        MCP_STD_OP_DROP_COUNT=value;
-        pwalletMain->InitializeUnspentList();        
-    }   
-    
-    if(strcmp(param->m_Name,"maxstdelementsize") == 0)
-    {
-        MAX_SCRIPT_ELEMENT_SIZE=value;
-        pwalletMain->InitializeUnspentList();        
-    }   
-    
-    if(strcmp(param->m_Name,"maximumchunksize") == 0)
-    {
-        int old_value=MAX_CHUNK_SIZE;
-        MAX_CHUNK_SIZE=(unsigned int)value;    
-
-        while(MAX_CHUNK_SIZE+OFFCHAIN_MSG_PADDING>MAX_SIZE)
-        {
-            MAX_SIZE *= 2;
-        }
-
-        if(MAX_CHUNK_SIZE > old_value)
-        {
-            if(pwalletTxsMain)
-            {
-                if(pwalletTxsMain->m_ChunkBuffer)
-                {
-                    mc_Delete(pwalletTxsMain->m_ChunkBuffer);
-                    pwalletTxsMain->m_ChunkBuffer=(unsigned char*)mc_New(MAX_CHUNK_SIZE);                        
-                }
-            }
-        }
-    }
-
-    if(strcmp(param->m_Name,"maximumchunkcount") == 0)
-    {
-        MAX_CHUNK_COUNT=value;
-    }           
-    
-    return MC_ERR_NOERROR;
-}
-
 int MultichainNode_ApplyUpgrades(int current_height)
-{
-    vector<mc_UpgradedParameter> vParams;
-    int err=MC_ERR_NOERROR;
-    
-    err=CreateUpgradeLists(current_height,&vParams,NULL);
-    
-    int OriginalProtocolVersion=(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
-    int CurrentProtocolVersion=mc_gState->m_NetworkParams->ProtocolVersion();//mc_gState->m_ProtocolVersionToUpgrade;
-    
-    mc_gState->m_NetworkParams->m_ProtocolVersion=OriginalProtocolVersion;
-    mc_gState->m_NetworkParams->SetGlobals();
-    for(int p=0;p<(int)vParams.size();p++)
-    {
-        if(vParams[p].m_Skipped == MC_PSK_APPLIED)
-        {
-            if(strcmp(vParams[p].m_Param->m_Name,"protocolversion") == 0)
-            {
-                mc_gState->m_NetworkParams->m_ProtocolVersion=(int)vParams[p].m_Value;
-                mc_gState->m_NetworkParams->SetProtocolGlobals();
-            }
-            else
-            {
-                SetUpgradedParamValue(vParams[p].m_Param,vParams[p].m_Value);
-            }
-        }
-    }
-    SetMultiChainParams();            
-    mc_gState->m_ProtocolVersionToUpgrade=mc_gState->m_NetworkParams->m_ProtocolVersion;
-    
-    
-    if(mc_gState->m_ProtocolVersionToUpgrade != CurrentProtocolVersion)
-    {
-        LogPrintf("New protocol upgrade version: %d (was %d)\n",mc_gState->m_ProtocolVersionToUpgrade,CurrentProtocolVersion);
-        if( (err == MC_ERR_NOT_SUPPORTED) || ((mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0)) )
-        {
-            mc_gState->m_NetworkParams->m_ProtocolVersion=CurrentProtocolVersion;
-            LogPrintf("NODE SHOULD BE UPGRADED FROM %d TO %d\n",mc_gState->GetProtocolVersion(),mc_gState->m_ProtocolVersionToUpgrade);
-        }
-        else
-        {
-            LogPrintf("NODE IS UPGRADED FROM %d TO %d\n",CurrentProtocolVersion,mc_gState->m_ProtocolVersionToUpgrade);
-/*            
-            if(mc_gState->m_ProtocolVersionToUpgrade != mc_gState->m_NetworkParams->ProtocolVersion())
-            {
-                LogPrintf("NODE IS UPGRADED FROM %d TO %d\n",mc_gState->m_NetworkParams->ProtocolVersion(),mc_gState->m_ProtocolVersionToUpgrade);
-            }        
- */ 
-        }
-    }
-    else
-    {
-        mc_gState->m_ProtocolVersionToUpgrade=0;        
-    }
-    
-    return MC_ERR_NOERROR;
-}
-
-
-int MultichainNode_ApplyUpgrades_Old(int current_height)
 {
     mc_EntityDetails entity;
     mc_Buffer *permissions;
@@ -543,12 +392,9 @@ int MultichainNode_ApplyUpgrades_Old(int current_height)
                     if(current_height >=applied_height)
                     {
                         version=entity.UpgradeProtocolVersion();
-                        if(version >= mc_gState->MinProtocolDowngradeVersion())
+                        if(version >= MULTICHAIN_MIN_DOWNGRADE_PROTOCOL_VERSION)
                         {
-                            if((NewProtocolVersion < mc_gState->MinProtocolForbiddenDowngradeVersion()) || (version >= NewProtocolVersion))
-                            {
-                                NewProtocolVersion=version;
-                            }
+                            NewProtocolVersion=version;
                         }
                     }
                 }
@@ -562,8 +408,7 @@ int MultichainNode_ApplyUpgrades_Old(int current_height)
     if(mc_gState->m_ProtocolVersionToUpgrade != CurrentProtocolVersion)
     {
         LogPrintf("New protocol upgrade version: %d (was %d)\n",mc_gState->m_ProtocolVersionToUpgrade,CurrentProtocolVersion);
-//        if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->GetProtocolVersion())
-        if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+        if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->GetProtocolVersion())
         {
             LogPrintf("NODE SHOULD BE UPGRADED FROM %d TO %d\n",mc_gState->GetProtocolVersion(),mc_gState->m_ProtocolVersionToUpgrade);
         }
@@ -1131,7 +976,13 @@ bool IsStandardTx(const CTransaction& tx, string& reason,bool check_for_dust)
     }
 
     // only one OP_RETURN txout is permitted
-    int max_op_returns=MCP_MAX_STD_OP_RETURN_COUNT;
+/* MCHN START */    
+    int max_op_returns=1;
+    if(mc_gState->m_Features->Streams())
+    {
+        max_op_returns=MCP_MAX_STD_OP_RETURN_COUNT;
+    }
+/* MCHN END */    
     
     if ((int)nDataOut > max_op_returns) {
         reason = "multi-op-return";
@@ -1403,8 +1254,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa
     if (pfMissingInputs)
         *pfMissingInputs = false;
     
-//    if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-    if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+    if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
     {
         return false;
     }
@@ -1443,6 +1293,24 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa
     uint256 hash = tx.GetHash();
     if (pool.exists(hash))
         return false;
+
+/* MCHN START */
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        if(!AcceptPermissionsAndCheckForDust(tx,false,reason))
+        {
+            return state.DoS(0,
+                             error("AcceptToMemoryPool: : AcceptPermissionsAndCheckForDust failed %s : %s", hash.ToString(),reason),
+                             REJECT_NONSTANDARD, reason);
+        }
+        if(!AcceptAssetGenesis(tx,-1,false,reason))
+        {
+            return state.DoS(0,
+                             error("AcceptToMemoryPool: : AcceptAssetGenesis failed %s : %s", hash.ToString(),reason),
+                             REJECT_INVALID, reason);
+        }
+    }    
+/* MCHN END */
     
     // Check for conflicts with in-memory transactions
     {
@@ -1654,27 +1522,40 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa
 /* MCHN START */
         
         uint32_t replay=0;
-        int64_t mandatory_fee;
         int permissions_from,permissions_to;
         permissions_from=mc_gState->m_Permissions->m_MempoolPermissions->GetCount();
         
-        if(!AcceptMultiChainTransaction(tx,view,-1,true,reason, &mandatory_fee, &replay))
+        if(mc_gState->m_Features->Streams())
         {
-            return state.DoS(0,
-                             error("AcceptToMemoryPool: : AcceptMultiChainTransaction failed %s : %s", hash.ToString(),reason),
-                             REJECT_NONSTANDARD, reason);
+            if(!AcceptMultiChainTransaction(tx,view,-1,true,reason, &replay))
+            {
+                return state.DoS(0,
+                                 error("AcceptToMemoryPool: : AcceptMultiChainTransaction failed %s : %s", hash.ToString(),reason),
+                                 REJECT_NONSTANDARD, reason);
+            }
         }
-        
-        if(mandatory_fee)
+        else
         {
-            txMinFee += mandatory_fee;
-            if (fLimitFree && nFees < txMinFee)
-                return state.DoS(0, error("AcceptToMemoryPool : not enough fees (including mandatory) %s, %d < %d",
-                                          hash.ToString(), nFees, txMinFee),
-                                 REJECT_INSUFFICIENTFEE, "insufficient fee");
+            if(!AcceptPermissionsAndCheckForDust(tx,true,reason))
+            {
+                return state.DoS(0,
+                                 error("AcceptToMemoryPool: : AcceptPermissionChanges failed when adding to permission db %s - %s", hash.ToString(),reason),
+                                 REJECT_INVALID, reason);
+            }
+            if(!AcceptAssetGenesis(tx,-1,true,reason))
+            {
+                return state.DoS(0,
+                                 error("AcceptToMemoryPool: : AcceptAssetGenesis failed when adding to asset db %s : %s", hash.ToString(),reason),
+                                 REJECT_INVALID, reason);
+            }        
+            if(!AcceptAssetTransfers(tx, view, reason))
+            {
+                return state.DoS(0,
+                                 error("AcceptToMemoryPool: : AcceptAssetTransfers failed %s : %s", hash.ToString(),reason),
+                                 REJECT_INVALID, reason);
+            }
         }
         
-        
         if(fAddToWallet)
         {
             int err=pwalletTxsMain->AddTx(NULL,tx,-1,NULL,-1,0);
@@ -2344,15 +2225,6 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
             return false;
     }
 
-    if(!CheckBlockForUpgardableConstraints(block,state,"maximum-block-size",true))
-    {
-        return false;
-    }
-    if(!CheckBlockForUpgardableConstraints(block,state,"maximum-block-sigops",true))
-    {
-        return false;
-    }
-    
 /* MCHN START */    
     uint256 block_hash;
     unsigned char miner_address[20];
@@ -2410,44 +2282,56 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
         {
             const CTransaction &tx = block.vtx[i];
             string reason;
-            if(!AcceptMultiChainTransaction(tx,view,offset,true,reason,NULL,NULL))
+            if(mc_gState->m_Features->Streams())
             {
-                return state.DoS(100, error(reason.c_str()),
-                             REJECT_INVALID, "bad-transaction");            
-            }
+                if(!AcceptMultiChainTransaction(tx,view,offset,true,reason,NULL))
+                {
+                    return state.DoS(100, error(reason.c_str()),
+                                 REJECT_INVALID, "bad-transaction");            
+                }
 //                unsigned char *root_stream_name;
-            int root_stream_name_size;
-            mc_gState->m_NetworkParams->GetParam("rootstreamname",&root_stream_name_size);        
-            if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
-            {
-                root_stream_name_size=0;
-            }    
-            if(root_stream_name_size > 1)
-            {
-                if(pwalletTxsMain)
+                int root_stream_name_size;
+                mc_gState->m_NetworkParams->GetParam("rootstreamname",&root_stream_name_size);        
+                if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+                {
+                    root_stream_name_size=0;
+                }    
+                if(root_stream_name_size > 1)
                 {
-                    if(mc_gState->m_WalletMode & MC_WMD_TXS)
-                    {                        
-                        mc_TxEntity entity;
-                        uint256 genesis_hash=block.vtx[0].GetHash();
-                        entity.Zero();
-
-                        memcpy(entity.m_EntityID,(unsigned char*)&genesis_hash+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-                        entity.m_EntityType=MC_TET_STREAM | MC_TET_CHAINPOS;
-                        pwalletTxsMain->AddEntity(&entity,0);
-                        entity.m_EntityType=MC_TET_STREAM | MC_TET_TIMERECEIVED;
-                        pwalletTxsMain->AddEntity(&entity,0);
-                        entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_CHAINPOS;
-                        pwalletTxsMain->AddEntity(&entity,0);
-                        entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_TIMERECEIVED;
-                        pwalletTxsMain->AddEntity(&entity,0);
-                        entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_CHAINPOS;
-                        pwalletTxsMain->AddEntity(&entity,0);
-                        entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_TIMERECEIVED;
-                        pwalletTxsMain->AddEntity(&entity,0);
+                    if(pwalletTxsMain)
+                    {
+                        if(mc_gState->m_WalletMode & MC_WMD_TXS)
+                        {                        
+                            mc_TxEntity entity;
+                            uint256 genesis_hash=block.vtx[0].GetHash();
+                            entity.Zero();
+
+                            memcpy(entity.m_EntityID,(unsigned char*)&genesis_hash+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+                            entity.m_EntityType=MC_TET_STREAM | MC_TET_CHAINPOS;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                            entity.m_EntityType=MC_TET_STREAM | MC_TET_TIMERECEIVED;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                            entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_CHAINPOS;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                            entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_TIMERECEIVED;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                            entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_CHAINPOS;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                            entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_TIMERECEIVED;
+                            pwalletTxsMain->AddEntity(&entity,0);
+                        }
                     }
                 }
             }
+            else
+            {
+                if(!AcceptPermissionsAndCheckForDust(tx,true,reason))
+                {
+                    return state.DoS(100, error(reason.c_str()),
+                                 REJECT_INVALID, "bad-transaction");            
+                    return false;
+                }            
+            }
             offset+=tx.GetSerializeSize(SER_NETWORK,tx.nVersion);
         }
         if(mc_gState->m_Permissions->Commit(miner_address,&block_hash) != 0)
@@ -2569,11 +2453,35 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
             string reason;
             if(!fJustCheck)
             {
-                if(!AcceptMultiChainTransaction(tx,view,offset,true,reason,NULL,NULL))
+                if(mc_gState->m_Features->Streams())
                 {
-                    return state.DoS(0,
-                                     error("ConnectBlock: : AcceptMultiChainTransaction failed %s : %s", tx.GetHash().ToString(),reason),
-                                     REJECT_NONSTANDARD, reason);
+                    if(!AcceptMultiChainTransaction(tx,view,offset,true,reason,NULL))
+                    {
+                        return state.DoS(0,
+                                         error("ConnectBlock: : AcceptMultiChainTransaction failed %s : %s", tx.GetHash().ToString(),reason),
+                                         REJECT_NONSTANDARD, reason);
+                    }
+                }
+                else
+                {
+                    if(!AcceptPermissionsAndCheckForDust(tx,true,reason))
+                    {
+                        return state.DoS(0,
+                                         error("ConnectBlock: AcceptPermissionChanges failed when adding to permission db %s - %s", tx.GetHash().ToString(),reason),
+                                         REJECT_INVALID, reason);
+                    }
+                    if(!AcceptAssetGenesis(tx,offset,true,reason))
+                    {
+                        return state.DoS(0,
+                                         error("ConnectBlock: AcceptAssetGenesis failed when adding to asset db %s : %s", tx.GetHash().ToString(),reason),
+                                         REJECT_INVALID, reason);
+                    }        
+                    if(!AcceptAssetTransfers(tx, view, reason))
+                    {
+                        return state.DoS(0,
+                                         error("ConnectBlock: AcceptAssetTransfers failed %s : %s", tx.GetHash().ToString(),reason),
+                                         REJECT_INVALID, reason);
+                    }
                 }
             }
 /* MCHN END */                    
@@ -2600,9 +2508,22 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
             string reason;
             if(!fJustCheck)
             {
-                if(!AcceptMultiChainTransaction(tx,view,coinbase_offset,true,reason,NULL,NULL))
+                if(mc_gState->m_Features->Streams())
                 {
-                    return false;       
+                    if(!AcceptMultiChainTransaction(tx,view,coinbase_offset,true,reason,NULL))
+                    {
+                        return state.DoS(0,
+                                     error("ConnectBlock: : AcceptMultiChainTransaction failed %s : %s", tx.GetHash().ToString(),reason),
+                                     REJECT_INVALID, reason);
+//                        return false;       
+                    }
+                }
+                else
+                {
+                    if(!AcceptPermissionsAndCheckForDust(tx,true,reason))
+                    {
+                        return false;
+                    }
                 }
             }
         }            
@@ -2958,7 +2879,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *
         err=pwalletTxsMain->AddTx(NULL,tx,pindexNew->nHeight,&pos,i,pindexNew->GetBlockHash());
         if(err)
         {
-            return error("ConnectTip() : ConnectBlock %s failed, Wtxs AddTx %s, error: %d", pindexNew->GetBlockHash().ToString(),tx.GetHash().ToString(),err);
+            LogPrintf("Wallet error when connecting block %s, Tx %s, error: %d\n", pindexNew->GetBlockHash().ToString(),tx.GetHash().ToString(),err);
         }
         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);
     }
@@ -3314,8 +3235,7 @@ static bool ActivateBestChainStep(CValidationState &state, CBlockIndex *pindexMo
             }
             
 //            }
-//            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-            if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
             {
                 LogPrintf("Cannot connect more blocks, required protocol version upgrade %d -> %d\n",mc_gState->m_NetworkParams->ProtocolVersion(),mc_gState->m_ProtocolVersionToUpgrade);
                 fContinue = false;
@@ -3428,8 +3348,7 @@ bool ActivateBestChain(CValidationState &state, CBlock *pblock) {
             nCanMine=pindexMostWork->nCanMine;
 /* MCHN START */            
             
-//            if( (mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion()) && 
-            if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) &&
+            if( (mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion()) && 
                 chainActive.FindFork(pindexMostWork) == chainActive.Tip() )
             {
                 LogPrintf("Cannot connect blocks, required protocol version upgrade %d -> %d\n",mc_gState->m_NetworkParams->ProtocolVersion(),mc_gState->m_ProtocolVersionToUpgrade);
@@ -3556,6 +3475,7 @@ string SetLastBlock(uint256 hash,bool *fNotFound)
 
         CBlockIndex *pindex;
         pindex=pblockindex;
+        
         while(pindex != pindexFork)
         {
             if (pblockindex->nStatus & BLOCK_FAILED_MASK)
@@ -3586,7 +3506,7 @@ string SetLastBlock(uint256 hash,bool *fNotFound)
             
             pindex=pindex->pprev;
         }
-        
+
         while(pblockindex != chainActive.Tip())
         {
             if(!ActivateBestChainStep(state,pblockindex,NULL))
@@ -3596,7 +3516,7 @@ string SetLastBlock(uint256 hash,bool *fNotFound)
                 return error;
             }        
         }
-        
+
         setBlockIndexCandidates.insert(pblockindex);
 
         LogPrintf("Set active chain tip: %s\n",hash.GetHex().c_str());
@@ -4134,34 +4054,6 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f
 }
 
 /* MCHN START */
-
-bool CheckBlockForUpgardableConstraints(const CBlock& block, CValidationState& state, string parameter, bool in_sync)
-{
-    if(!in_sync)
-    {
-        return true;
-    }
-    
-    if(parameter == "maximum-block-size")
-    {
-        if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)
-            return state.DoS(100, error("CheckBlock() : size limits failed"),
-                             REJECT_INVALID, "bad-blk-length");        
-    }
-    if(parameter == "maximum-block-sigops")
-    {
-        unsigned int nSigOps = 0;
-        BOOST_FOREACH(const CTransaction& tx, block.vtx)
-        {
-            nSigOps += GetLegacySigOpCount(tx);
-        }
-        if (nSigOps > MAX_BLOCK_SIGOPS)
-            return state.DoS(100, error("CheckBlock() : out-of-bounds SigOpCount"),
-                             REJECT_INVALID, "bad-blk-sigops", true);        
-    }
-    return true;
-}
-
 //bool CheckBlock(CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)
 bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bool fCheckMerkleRoot)
 /* MCHN END */
@@ -4194,16 +4086,10 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
     // because we receive the wrong transactions for it.
 
     // Size limits
-    if(!CheckBlockForUpgardableConstraints(block,state,"maximum-block-size",false))
-    {
-        return false;
-    }
-/*    
     if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)
         return state.DoS(100, error("CheckBlock() : size limits failed"),
                          REJECT_INVALID, "bad-blk-length");
-*/
-    
+
     // First transaction must be coinbase, the rest must not be
     if (block.vtx.empty() || !block.vtx[0].IsCoinBase())
         return state.DoS(100, error("CheckBlock() : first tx is not coinbase"),
@@ -4233,12 +4119,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
         }
     }
     
-    if(!CheckBlockForUpgardableConstraints(block,state,"maximum-block-sigops",false))
-    {
-        return false;
-    }
     
-/*    
     unsigned int nSigOps = 0;
     BOOST_FOREACH(const CTransaction& tx, block.vtx)
     {
@@ -4247,7 +4128,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo
     if (nSigOps > MAX_BLOCK_SIGOPS)
         return state.DoS(100, error("CheckBlock() : out-of-bounds SigOpCount"),
                          REJECT_INVALID, "bad-blk-sigops", true);
-*/
+
     return true;
 }
 
@@ -4706,8 +4587,7 @@ bool ProcessNewBlock(CValidationState &state, CNode* pfrom, CBlock* pblock, CDis
             return error("%s : AcceptBlock FAILED", __func__);
         if(pindex)
         {
-//            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-            if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
             {
                 if(chainActive.FindFork(pindex) == chainActive.Tip())
                 {
@@ -5232,12 +5112,10 @@ bool LoadExternalBlockFile(FILE* fileIn, CDiskBlockPos *dbp)
     static std::multimap<uint256, CDiskBlockPos> mapBlocksUnknownParent;
     int64_t nStart = GetTimeMillis();
 
-    uint32_t effective_max_block_size=GetArg("-loadblockmaxsize",2*MAX_BLOCK_SIZE);
-    
     int nLoaded = 0;
     try {
         // This takes over fileIn and calls fclose() on it in the CBufferedFile destructor
-        CBufferedFile blkdat(fileIn, 2*effective_max_block_size, effective_max_block_size+8, SER_DISK, CLIENT_VERSION);
+        CBufferedFile blkdat(fileIn, 2*MAX_BLOCK_SIZE, MAX_BLOCK_SIZE+8, SER_DISK, CLIENT_VERSION);
         uint64_t nRewind = blkdat.GetPos();
         while (!blkdat.eof()) {
             boost::this_thread::interruption_point();
@@ -5820,24 +5698,6 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,
         return false;
     }
 
-    else if (strCommand == "offchain")
-    {
-        CValidationState state;        
-        if(pRelayManager)
-        {
-            if( (mc_gState->m_NodePausedState & MC_NPS_OFFCHAIN) == 0 )
-            {
-                if(!pRelayManager->ProcessRelay(pfrom,vRecv,state,MC_VRA_DEFAULT))
-                {
-                    int nDos = 0;
-                    if (state.IsInvalid(nDos) && nDos > 0)
-                    {
-                        Misbehaving(pfrom->GetId(), nDos);
-                    }
-                }
-            }
-        }
-    }
 
     else if (strCommand == "verack")
     {
@@ -7339,23 +7199,6 @@ bool SendMessages(CNode* pto, bool fSendTrickle)
 /* MCHN START */        
         }
         pto->fLastIgnoreIncoming=ignore_incoming;
-        
-        if(pwalletTxsMain->m_ChunkCollector)
-        {
-            int64_t time_millis_now=GetTimeMillis();
-
-            if(pwalletTxsMain->m_ChunkCollector->m_NextTryTimestamp < time_millis_now)
-            {
-                if(MultichainNode_CollectChunks())
-                {
-                    MultichainCollectChunks(pwalletTxsMain->m_ChunkCollector);
-                }                
-                pwalletTxsMain->m_ChunkCollector->m_NextTryTimestamp=time_millis_now+MultichainCollectChunksQueueStats(pwalletTxsMain->m_ChunkCollector);
-                
-//                    if(fDebug)LogPrint("chunks", "Chunks to collect: %d\n", still_to_collect);
-//                pwalletTxsMain->m_ChunkCollector->m_NextTryTimestamp=time_millis_now+GetArg("-offchainrequestfreq",MC_CCW_TIMEOUT_BETWEEN_COLLECTS_MILLIS);
-            }
-        }
 /* MCHN END */                
     }
     return true;
diff --git a/src/core/main.h b/src/core/main.h
index 2444f3f..1e4e24c 100644
--- a/src/core/main.h
+++ b/src/core/main.h
@@ -58,9 +58,9 @@ static const unsigned int DEFAULT_BLOCK_MIN_SIZE = 0;
 /** The maximum size for transactions we're willing to relay/mine */
 extern unsigned int MAX_STANDARD_TX_SIZE;                                       // MCHN global
 /** The maximum allowed number of signature check operations in a block (network rule) */
-extern unsigned int MAX_BLOCK_SIGOPS;                                           // MCHN global
+extern unsigned int MAX_BLOCK_SIGOPS;
 /** The maximum number of sigops we're willing to relay/mine in a single tx */
-extern unsigned int MAX_TX_SIGOPS;                                              // MCHN global
+extern unsigned int MAX_TX_SIGOPS;
 /** Maximum number of signature check operations in an IsStandard() P2SH script */
 static const unsigned int MAX_P2SH_SIGOPS = 15;
 /** Default for -maxorphantx, maximum number of orphan transactions kept in memory */
@@ -72,10 +72,6 @@ static const unsigned int DEFAULT_MAX_ORPHAN_TRANSACTIONS = 50000;
 static const unsigned int DEFAULT_MAX_SUCCESSORS_FROM_ONE_NODE = 10;
 /* MCHN END */
 extern int MAX_OP_RETURN_SHOWN;
-extern int MAX_STREAM_QUERY_ITEMS;
-extern int MAX_FORMATTED_DATA_DEPTH;
-extern int MIN_BLOCKS_BETWEEN_UPGRADES;
-extern unsigned int OFFCHAIN_MSG_PADDING;
 /* MCHN END */
 /** The maximum size of a blk?????.dat file (since 0.8) */
 extern unsigned int MAX_BLOCKFILE_SIZE;                                     // MCHN global
@@ -398,7 +394,6 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin
 /** Context-independent validity checks */
 bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool fCheckPOW = true);
 bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW = true, bool fCheckMerkleRoot = true);
-bool CheckBlockForUpgardableConstraints(const CBlock& block, CValidationState& state, std::string parameter, bool in_sync);
 
 /** Context-dependent validity checks */
 bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, CBlockIndex *pindexPrev, CBlockIndex *pindexChecked = NULL);
diff --git a/src/custom/custom.cpp b/src/custom/custom.cpp
deleted file mode 100644
index c759d07..0000000
--- a/src/custom/custom.cpp
+++ /dev/null
@@ -1,19 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "custom/custom.h"
-
-using namespace std;
-
-int custom_version_info(int version)
-{
-    return 0;
-}
-
-void custom_set_runtime_defaults(int exe_type)
-{
-    
-}
-
-
-
diff --git a/src/custom/custom.h b/src/custom/custom.h
deleted file mode 100644
index 9d134eb..0000000
--- a/src/custom/custom.h
+++ /dev/null
@@ -1,36 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "core/main.h"
-#include "utils/util.h"
-#include "utils/utilparse.h"
-#include "multichain/multichain.h"
-#include "structs/base58.h"
-#include "version/version.h"
-
-
-
-#ifndef CUSTOM_H
-#define CUSTOM_H
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int custom_version_info(int version);
-bool custom_good_for_coin_selection(const CScript& script);
-bool custom_accept_transacton(const CTransaction& tx, 
-                              const CCoinsViewCache &inputs,
-                              int offset,
-                              bool accept,
-                              std::string& reason,
-                              uint32_t *replay);
-
-void custom_set_runtime_defaults(int exe_type);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CUSTOM_H */
-
diff --git a/src/custom/custom_multichain.cpp b/src/custom/custom_multichain.cpp
deleted file mode 100644
index b67933c..0000000
--- a/src/custom/custom_multichain.cpp
+++ /dev/null
@@ -1,12 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "multichain/multichain.h"
-
-void* custom_get_blockchain_default(const char *param,int* size,void *param_in)
-{
-    *size=0;
-    
-    return NULL;
-}
-
diff --git a/src/custom/custom_server.cpp b/src/custom/custom_server.cpp
deleted file mode 100644
index 7fac227..0000000
--- a/src/custom/custom_server.cpp
+++ /dev/null
@@ -1,22 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "custom/custom.h"
-
-using namespace std;
-
-bool custom_good_for_coin_selection(const CScript& script)
-{
-    return true;    
-}
-
-bool custom_accept_transacton(const CTransaction& tx, 
-                              const CCoinsViewCache &inputs,
-                              int offset,
-                              bool accept,
-                              string& reason,
-                              uint32_t *replay)
-{
-    return true;
-}
-
diff --git a/src/entities/asset.cpp b/src/entities/asset.cpp
index 1f75f5b..6e326b6 100644
--- a/src/entities/asset.cpp
+++ b/src/entities/asset.cpp
@@ -536,31 +536,7 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
         }
         m_Flags |= MC_ENT_FLAG_OFFSET_IS_SET;
     }
-
-    m_Permissions=0;
-    m_Restrictions=0;
-    m_ScriptPermissions=0;
     
-    switch(m_LedgerRow.m_EntityType)
-    {
-        case MC_ENT_TYPE_ASSET:
-            m_Permissions |= MC_PTP_ADMIN | MC_PTP_ISSUE;
-            if(mc_gState->m_Features->PerAssetPermissions())
-            {
-                m_Permissions |= MC_PTP_ACTIVATE;                
-            }
-            break;
-        case MC_ENT_TYPE_STREAM:
-            m_Permissions |= MC_PTP_ADMIN | MC_PTP_ACTIVATE | MC_PTP_WRITE;
-            break;
-        default:
-            if(m_LedgerRow.m_EntityType <= MC_ENT_TYPE_STREAM_MAX)
-            {
-                m_Permissions = MC_PTP_WRITE | MC_PTP_ACTIVATE;
-            }
-            break;            
-    }
-            
     if(script_size)
     {
         value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_NAME,&value_size);
@@ -570,14 +546,17 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
             dname_buf[0]=0xff;
             value_offset=mc_FindNamedParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,(char*)dname_buf,&value_size);
         }
-        if(value_offset < m_LedgerRow.m_ScriptSize)
-        {            
-            if(value_size == 2)
-            {
-                if((char)m_LedgerRow.m_Script[value_offset] == '*')
+        if(mc_gState->m_Features->Streams())
+        {
+            if(value_offset < m_LedgerRow.m_ScriptSize)
+            {            
+                if(value_size == 2)
                 {
-                    value_offset=m_LedgerRow.m_ScriptSize;
-                    value_size=0;
+                    if((char)m_LedgerRow.m_Script[value_offset] == '*')
+                    {
+                        value_offset=m_LedgerRow.m_ScriptSize;
+                        value_size=0;
+                    }
                 }
             }
         }
@@ -593,41 +572,22 @@ void mc_EntityDetails::Set(mc_EntityLedgerRow* row)
             {
                 memcpy(m_Name,m_LedgerRow.m_Script+value_offset,value_size);                
             }
-            mc_StringLowerCase(m_Name,value_size);
+           mc_StringLowerCase(m_Name,value_size);
             m_Flags |= MC_ENT_FLAG_NAME_IS_SET;
         }
-        
-        value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_PERMISSIONS,&value_size);
-        if(value_offset <= m_LedgerRow.m_ScriptSize)
-        {
-/*            
-            if(m_Permissions & MC_PTP_WRITE)
-            {
-                m_Permissions -= MC_PTP_WRITE;
-            }
- */ 
-            m_Permissions |= MC_PTP_SPECIFIED;
-            if((value_size>0) && (value_size<=4))
-            {
-                m_ScriptPermissions=(uint32_t)mc_GetLE(m_LedgerRow.m_Script+value_offset,value_size);
-                m_Permissions |= m_ScriptPermissions;
-            }
-        }
-        
-        value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_RESTRICTIONS,&value_size);
-        if(value_offset <= m_LedgerRow.m_ScriptSize)
-        {
-            if((value_size>0) && (value_size<=4))
-            {
-                m_Restrictions |= (uint32_t)mc_GetLE(m_LedgerRow.m_Script+value_offset,value_size);
-            }
-        }
-        
     }
     
     mc_ZeroABRaw(m_FullRef);
-    memcpy(m_FullRef+MC_AST_SHORT_TXID_OFFSET,m_LedgerRow.m_Key+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-    mc_SetABRefType(m_FullRef,MC_AST_ASSET_REF_TYPE_SHORT_TXID);
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        memcpy(m_FullRef+MC_AST_SHORT_TXID_OFFSET,m_LedgerRow.m_Key+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        mc_SetABRefType(m_FullRef,MC_AST_ASSET_REF_TYPE_SHORT_TXID);
+    }
+    else
+    {
+        memcpy(m_FullRef,m_Ref,MC_AST_ASSET_REF_SIZE);
+        mc_SetABRefType(m_FullRef,MC_AST_ASSET_REF_TYPE_REF);
+    }
 }
 
 int mc_AssetDB::InsertEntity(const void* txid, int offset, int entity_type, const void *script,size_t script_size, const void* special_script, size_t special_script_size,int update_mempool)
@@ -675,14 +635,14 @@ int mc_AssetDB::InsertEntity(const void* txid, int offset, int entity_type, cons
             {
                 if(*((unsigned char*)script+value_offset+value_size-1))
                 {
-                    if(value_size > MC_ENT_MAX_NAME_SIZE)
-                    {
+		            if(value_size > MC_ENT_MAX_NAME_SIZE)
+		            {
                         if(mc_gState->m_Features->FixedIn1001120003())
                         {
                             return MC_ERR_ERROR_IN_SCRIPT;                                            
                         }
-                        value_size=MC_ENT_MAX_NAME_SIZE;
-                    }
+		                value_size=MC_ENT_MAX_NAME_SIZE;
+		            }
                     memcpy(stream_name,(unsigned char*)script+value_offset,value_size);
                     stream_name[value_size]=0x00;
                     lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(unsigned char*)stream_name,strlen(stream_name)+1);            
@@ -692,11 +652,11 @@ int mc_AssetDB::InsertEntity(const void* txid, int offset, int entity_type, cons
     }
 
     upgrade_start_block=0;
-    if(entity_type == MC_ENT_TYPE_UPGRADE)
+    if(mc_gState->m_Features->Upgrades())
     {
-        if(script)
+        if(entity_type == MC_ENT_TYPE_UPGRADE)
         {
-            if(mc_gState->m_Features->ParameterUpgrades() == 0)
+            if(script)
             {
                 value_offset=mc_FindSpecialParamInDetailsScript((unsigned char*)script,script_size,MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,&value_size);
                 if(value_offset == script_size)
@@ -711,15 +671,15 @@ int mc_AssetDB::InsertEntity(const void* txid, int offset, int entity_type, cons
                 {
                     return MC_ERR_ERROR_IN_SCRIPT;                        
                 }
-            }
-            value_offset=mc_FindSpecialParamInDetailsScript((unsigned char*)script,script_size,MC_ENT_SPRM_UPGRADE_START_BLOCK,&value_size);
-            if(value_offset != script_size)
-            {
-                if( (value_size <=0) || (value_size > 4) )
+                value_offset=mc_FindSpecialParamInDetailsScript((unsigned char*)script,script_size,MC_ENT_SPRM_UPGRADE_START_BLOCK,&value_size);
+                if(value_offset != script_size)
                 {
-                    return MC_ERR_ERROR_IN_SCRIPT;                        
+                    if( (value_size <=0) || (value_size > 4) )
+                    {
+                        return MC_ERR_ERROR_IN_SCRIPT;                        
+                    }
+                    upgrade_start_block=(uint32_t)mc_GetLE((unsigned char*)script+value_offset,value_size);
                 }
-                upgrade_start_block=(uint32_t)mc_GetLE((unsigned char*)script+value_offset,value_size);
             }
         }
     }
@@ -813,9 +773,12 @@ int mc_AssetDB::InsertEntity(const void* txid, int offset, int entity_type, cons
         }
     }    
 
-    if(entity_type == MC_ENT_TYPE_UPGRADE)
+    if(mc_gState->m_Features->Upgrades())
     {
-        return mc_gState->m_Permissions->SetApproval((unsigned char*)txid+MC_AST_SHORT_TXID_OFFSET,1,NULL,upgrade_start_block,mc_TimeNowAsUInt(),MC_PFL_ENTITY_GENESIS,update_mempool,offset);
+        if(entity_type == MC_ENT_TYPE_UPGRADE)
+        {
+            return mc_gState->m_Permissions->SetApproval((unsigned char*)txid+MC_AST_SHORT_TXID_OFFSET,1,NULL,upgrade_start_block,mc_TimeNowAsUInt(),MC_PFL_ENTITY_GENESIS,update_mempool,offset);
+        }
     }
     
     return MC_ERR_NOERROR;    
@@ -858,11 +821,14 @@ int mc_AssetDB::InsertAsset(const void* txid, int offset, uint64_t quantity, con
     }
 
     add_param=true;
-    if(script)
+    if(mc_gState->m_Features->OpDropDetailsScripts())
     {
-        if(mc_FindSpecialParamInDetailsScript((unsigned char*)script,script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size) != script_size)
+        if(script)
         {
-            add_param=false;                                
+            if(mc_FindSpecialParamInDetailsScript((unsigned char*)script,script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size) != script_size)
+            {
+                add_param=false;                                
+            }
         }
     }
 
@@ -1007,6 +973,14 @@ int mc_AssetDB::InsertAssetFollowOn(const void* txid, int offset, uint64_t quant
         return MC_ERR_NOT_FOUND;
     }    
     
+    if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+    {
+        if(aldRow.m_PrevPos < 0)                                                // Unconfirmed genesis for protocol < 10007
+        {
+            return MC_ERR_NOT_FOUND;        
+        }        
+    }
+    
     value_offset=mc_FindSpecialParamInDetailsScript(aldRow.m_Script,aldRow.m_ScriptSize,MC_ENT_SPRM_FOLLOW_ONS,&value_size);
     if(value_offset == aldRow.m_ScriptSize)
     {
@@ -1628,24 +1602,7 @@ int mc_AssetDB::FindEntityByFollowOn(mc_EntityDetails *entity,const unsigned cha
     return 0;
 }
 
-const unsigned char* mc_EntityDetails::GetParamUpgrades(int *size)
-{
-    uint32_t value_offset;
-    size_t value_size;
-    
-    if(m_LedgerRow.m_ScriptSize)
-    {
-        value_offset=mc_FindSpecialParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,MC_ENT_SPRM_UPGRADE_CHAIN_PARAMS,&value_size);
-        if(value_offset != m_LedgerRow.m_ScriptSize)
-        {
-            *size=(int)value_size;
-            return m_LedgerRow.m_Script+value_offset;
-        }
-    }
-    
-    *size=0;
-    return NULL;
-}
+
 
 const char* mc_EntityDetails::GetName()
 {
@@ -1662,14 +1619,17 @@ const char* mc_EntityDetails::GetName()
             dname_buf[0]=0xff;
             value_offset=mc_FindNamedParamInDetailsScript(m_LedgerRow.m_Script,m_LedgerRow.m_ScriptSize,(char*)dname_buf,&value_size);
         }
-        if(value_offset < m_LedgerRow.m_ScriptSize)
-        {            
-            if(value_size == 2)
-            {
-                if((char)m_LedgerRow.m_Script[value_offset] == '*')
+        if(mc_gState->m_Features->Streams())
+        {
+            if(value_offset < m_LedgerRow.m_ScriptSize)
+            {            
+                if(value_size == 2)
                 {
-                    value_offset=m_LedgerRow.m_ScriptSize;
-                    value_size=0;
+                    if((char)m_LedgerRow.m_Script[value_offset] == '*')
+                    {
+                        value_offset=m_LedgerRow.m_ScriptSize;
+                        value_size=0;
+                    }
                 }
             }
         }
@@ -1704,7 +1664,11 @@ const unsigned char* mc_EntityDetails::GetFullRef()
 
 const unsigned char* mc_EntityDetails::GetShortRef()
 {
-    return GetTxID()+MC_AST_SHORT_TXID_OFFSET;
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        return GetTxID()+MC_AST_SHORT_TXID_OFFSET;
+    }    
+    return m_Ref;
 }
 
 const unsigned char* mc_EntityDetails::GetScript()
@@ -1763,34 +1727,10 @@ int mc_EntityDetails::AllowedFollowOns()
     return 0;
 }
 
-uint32_t mc_EntityDetails::Permissions()
-{
-    return m_Permissions;
-}
-
-uint32_t mc_EntityDetails::Restrictions()
-{
-    return m_Restrictions;
-}
-
-
 int mc_EntityDetails::AnyoneCanWrite()
 {
     unsigned char *ptr;
     size_t bytes;
-
-    if(m_Permissions & MC_PTP_SPECIFIED)
-    {
-        if(mc_gState->m_Features->OffChainData())
-        {            
-            if(m_ScriptPermissions & MC_PTP_WRITE)
-            {
-                return 0;
-            }
-            return 1;            
-        }
-    }
-    
     ptr=(unsigned char *)GetSpecialParam(MC_ENT_SPRM_ANYONE_CAN_WRITE,&bytes);
     if(ptr)
     {
@@ -1821,17 +1761,12 @@ int mc_EntityDetails::UpgradeProtocolVersion()
 {
     unsigned char *ptr;
     size_t bytes;
-    int version;
     ptr=(unsigned char *)GetSpecialParam(MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,&bytes);
     if(ptr)
     {
         if((bytes>0) && (bytes<=4))
         {
-            version=(int)mc_GetLE(ptr,bytes);
-            if(version > 0)
-            {
-                return version;
-            }
+            return (int)mc_GetLE(ptr,bytes);
         }
     }
     return 0;
@@ -1959,6 +1894,10 @@ void mc_AssetDB::Dump()
 
 uint32_t mc_AssetDB::MaxEntityType()
 {
+    if(mc_gState->m_Features->Upgrades() == 0)
+    {
+        return MC_ENT_TYPE_STREAM_MAX; 
+    }
     return MC_ENT_TYPE_MAX; 
 }
 
diff --git a/src/entities/asset.h b/src/entities/asset.h
index 0c512cc..f92d52e 100644
--- a/src/entities/asset.h
+++ b/src/entities/asset.h
@@ -25,11 +25,6 @@
 #define MC_AST_ASSET_REF_TYPE_GENESIS      256 
 #define MC_AST_ASSET_REF_TYPE_SPECIAL      512
 
-#define MC_ENT_ENTITY_RESTRICTION_NONE           0x00000000
-#define MC_ENT_ENTITY_RESTRICTION_ONCHAIN        0x00000001
-#define MC_ENT_ENTITY_RESTRICTION_OFFCHAIN       0x00000002
-
-
 
 #define MC_ENT_REF_SIZE                 10
 #define MC_ENT_REF_PREFIX_SIZE           2
@@ -61,23 +56,9 @@
 #define MC_ENT_SPRM_ISSUER                    0x03
 #define MC_ENT_SPRM_ANYONE_CAN_WRITE          0x04
 #define MC_ENT_SPRM_JSON_DETAILS              0x05
-#define MC_ENT_SPRM_PERMISSIONS               0x06
-#define MC_ENT_SPRM_RESTRICTIONS              0x07
 #define MC_ENT_SPRM_ASSET_MULTIPLE            0x41
 #define MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION  0x42
 #define MC_ENT_SPRM_UPGRADE_START_BLOCK       0x43
-#define MC_ENT_SPRM_UPGRADE_CHAIN_PARAMS      0x44
-
-#define MC_ENT_SPRM_TIMESTAMP                 0x81
-#define MC_ENT_SPRM_CHUNK_HASH                0x82
-#define MC_ENT_SPRM_SOURCE_TXID               0x83
-#define MC_ENT_SPRM_SOURCE_VOUT               0x84
-#define MC_ENT_SPRM_CHUNK_SIZE                0x85
-#define MC_ENT_SPRM_CHUNK_DETAILS             0x86
-#define MC_ENT_SPRM_CHUNK_DATA                0x87
-#define MC_ENT_SPRM_ITEM_COUNT                0x88
-
-#define MC_ENT_SPRM_FILE_END                  0xFF
 
 #define MC_ENT_FLAG_OFFSET_IS_SET     0x00000001
 #define MC_ENT_FLAG_NAME_IS_SET       0x00000010
@@ -154,9 +135,6 @@ typedef struct mc_EntityDetails
     unsigned char m_FullRef[MC_AST_ASSET_QUANTITY_OFFSET];                      // Full Entity reference, derived from short txid from v 10007
     char m_Name[MC_ENT_MAX_NAME_SIZE+6];                                        // Entity name
     uint32_t m_Flags;
-    uint32_t m_Permissions;
-    uint32_t m_ScriptPermissions;
-    uint32_t m_Restrictions;
     unsigned char m_Reserved[36];   
     mc_EntityLedgerRow m_LedgerRow;
     void Zero();
@@ -167,15 +145,11 @@ typedef struct mc_EntityDetails
     const unsigned char* GetFullRef();    
     const unsigned char* GetShortRef();
     const unsigned char* GetScript();    
-    const unsigned char* GetParamUpgrades(int *size);    
-    
     int IsUnconfirmedGenesis();    
     int GetAssetMultiple();
     int IsFollowOn(); 
 //    int HasFollowOns(); 
     int AllowedFollowOns(); 
-    uint32_t Permissions(); 
-    uint32_t Restrictions(); 
     int AnyoneCanWrite(); 
     int UpgradeProtocolVersion(); 
     uint32_t UpgradeStartBlock(); 
diff --git a/src/json/json_spirit_ubjson.cpp b/src/json/json_spirit_ubjson.cpp
index 04a2f94..5079ad2 100644
--- a/src/json/json_spirit_ubjson.cpp
+++ b/src/json/json_spirit_ubjson.cpp
@@ -1,7 +1,12 @@
 // Copyright (c) 2014-2017 Coin Sciences Ltd
 // MultiChain code distributed under the GPLv3 license, see COPYING file.
 
-#include "json/json_spirit_ubjson.h"
+//#include "json/json_spirit_ubjson.h"
+#include "json/json_spirit_utils.h"
+#include "json/json_spirit_value.h"
+#include "multichain/multichain.h"
+using namespace std;
+using namespace json_spirit;
 
 #define UBJ_UNDEFINED          0
 #define UBJ_NULLTYPE           1
diff --git a/src/json/json_spirit_ubjson.h b/src/json/json_spirit_ubjson.h
deleted file mode 100644
index 0b5939f..0000000
--- a/src/json/json_spirit_ubjson.h
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#ifndef JSON_SPIRIT_UBJSON_H
-#define JSON_SPIRIT_UBJSON_H
-
-#include "json/json_spirit_utils.h"
-#include "json/json_spirit_value.h"
-#include "multichain/multichain.h"
-
-using namespace std;
-using namespace json_spirit;
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-int ubjson_write(Value json_value,mc_Script *lpScript,int max_depth);
-Value ubjson_read(const unsigned char *elem,size_t elem_size,int max_depth,int *err);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* JSON_SPIRIT_UBJSON_H */
-
diff --git a/src/json/json_spirit_writer_template.h b/src/json/json_spirit_writer_template.h
index 21bc092..4535368 100644
--- a/src/json/json_spirit_writer_template.h
+++ b/src/json/json_spirit_writer_template.h
@@ -12,9 +12,6 @@
 #include <sstream>
 #include <iomanip>
 
-extern uint32_t JSON_NO_DOUBLE_FORMATTING;                             
-extern int JSON_DOUBLE_DECIMAL_DIGITS;                             
-
 
 namespace json_spirit
 {
@@ -207,11 +204,9 @@ namespace json_spirit
                 case int_type:   output_int( value );         break;
 
                 /// Bitcoin: Added std::fixed and changed precision from 16 to 8
-/*                
                 case real_type:  os_ << std::showpoint << std::fixed << std::setprecision(8)
                                      << value.get_real();     break;
-*/
-                case real_type:  output_double( value.get_real() );break;
+
                 case null_type:  os_ << "null";               break;
                 default: assert( false );
             }
@@ -245,230 +240,7 @@ namespace json_spirit
                os_ << value.get_int64();
             }
         }
-        
-        int output_double_precision( const double& value, int max_p )
-        {
-            int p=max_p;
-                        
-            char fp[20];
-            char sp[40];
-            sprintf(fp,"%%0.%df",p);
-            sprintf(sp,fp,value);
-            char *tp=sp+strlen(sp)-1;
-            while( (tp>sp) && (p>=0) && *tp=='0')
-            {
-                p--;
-                tp--;
-            }
-//            printf("%0.16f %s %s %c %d %d\n",value,fp,sp,*tp,(tp-sp),p);
-            if( (tp == sp) || (*tp == '.') )
-            {
-                p=0;
-            }
-            return p;
-        }
-        
-        void output_double( const double& value )
-        {
-            int max_p=14;
-            if(JSON_DOUBLE_DECIMAL_DIGITS >= 0)
-            {
-                max_p=JSON_DOUBLE_DECIMAL_DIGITS;
-            }
-            
-            if(JSON_NO_DOUBLE_FORMATTING)                     
-            {
-                os_ << std::showpoint << std::fixed << std::setprecision(max_p) << value;                
-                return; 
-            }
-            double a=fabs(value);
-            double e=0.0;
-            int z=0;
-            double f=0.;
-            int j=0;
-            if(a > 0)
-            {
-                e=log10(a);
-            }            
-            if(e < -4)
-            {
-                f=a*1.e+9;
-                j=(int)f;
-                if(j)
-                {
-                    if( (f-j) < 0.0001)
-                    {
-                        z=1;
-                    }
-                }
-            }
-            int k=(int)e;
-            if(e<k)
-            {
-                k--;
-            }
-            double v=value/pow(10.,k);
-            
-            int p=output_double_precision(v,max_p);
-            if(p-k > max_p)
-            {
-                z=0;
-            }
-            
-            if( ((e < -4.) || (e > 12.)) && (z == 0))
-            {
-                if(p > 0)
-                {
-                    os_ << std::showpoint << std::fixed << std::setprecision(p) << v;
-                }
-                else
-                {
-                    os_ << (int)v;
-                }
-                os_ << "e" << ((e>=0) ? "+" : "") << k;
-            }
-            else
-            {
-                int pfull=output_double_precision(value,max_p);
-                if(pfull + k <= max_p)
-                {
-                    p=pfull;
-                }
-                else
-                {
-                    p-=k;
-                }
-                if(p > 0)
-                {
-                    os_ << std::showpoint << std::fixed << std::setprecision(p) << value;
-                }
-                else
-                {
-                    os_ << (int64_t)value;                    
-                }
-            }
-        }
 
-        void output_double_old( const double& value )
-        {
-            if(JSON_NO_DOUBLE_FORMATTING)                     
-            {
-                os_ << std::showpoint << std::fixed << std::setprecision(9) << value;                
-                return; 
-            }
-            double a=fabs(value);
-            double e=0.0;
-            int z=0;
-            double f=0.;
-            int j=0;
-            if(a > 0)
-            {
-                e=log10(a);
-            }            
-            if(e < -4)
-            {
-                f=a*1.e+9;
-                j=(int)f;
-                if(j)
-                {
-                    if( (f-j) < 0.0001)
-                    {
-                        z=1;
-                    }
-                }
-            }
-            int k=(int)e;
-            if(e<k)
-            {
-                k--;
-            }
-            double v=value/pow(10.,k);
-            
-            int p=9;
-            double t=fabs(v)*pow(10.,p);
-            int64_t n=(int64_t)(t+0.5);
-            int64_t m=(int64_t)(t/10+0.5);
-            
-            if(JSON_DOUBLE_DECIMAL_DIGITS < 0)
-            {
-                while( (p>0) && (n == m*10))
-                {
-                    p--;
-                    t/=10.;
-                    n=m;
-                    m=(int64_t)(t/10.+0.5);
-                }
-                if(p-k > 9)
-                {
-                    z=0;
-                }
-            }
-            else
-            {
-                p=JSON_DOUBLE_DECIMAL_DIGITS;
-                if(p>16)
-                {
-                    p=16;
-                }
-                if(p-k > 9)
-                {
-                    z=0;
-                }
-                if(p)
-                {
-                    double tv=value;
-                    int ap=k;
-                    if( ((e < -4.) || (e > 12.)) && (z == 0))
-                    {
-                        tv=v;
-                        ap=0;
-                    }                    
-                    char fp[20];
-                    char sp[40];
-                    sprintf(fp,"%%0.%df",p);
-                    sprintf(sp,fp,tv);
-                    char *tp=sp+strlen(sp)-1;
-                    while( (tp>sp) && (p>=0) && *tp=='0')
-                    {
-                        p--;
-                        tp--;
-                    }
-                    printf("%d %s %s %c %d %d\n",k,fp,sp,*tp,(tp-sp),p);
-                    if( (tp == sp) || (*tp == '.') )
-                    {
-                        p=0;
-                    }
-                    p+=ap;
-                }
-            }
-            
-            
-            if( ((e < -4.) || (e > 12.)) && (z == 0))
-            {
-                if(p > 0)
-                {
-                    os_ << std::showpoint << std::fixed << std::setprecision(p) << v;
-                }
-                else
-                {
-                    os_ << (int)v;
-                }
-                os_ << "e" << ((e>=0) ? "+" : "") << k;
-            }
-            else
-            {
-                p-=k;
-                if(p > 0)
-                {
-                    os_ << std::showpoint << std::fixed << std::setprecision(p) << value;
-                }
-                else
-                {
-                    os_ << (int64_t)value;                    
-                }
-            }
-        }
-        
         void output( const String_type& s )
         {
             os_ << '"' << add_esc_chars( s ) << '"';
diff --git a/src/leveldb/db/db_impl.cc b/src/leveldb/db/db_impl.cc
index 49b9595..f0c15b9 100644
--- a/src/leveldb/db/db_impl.cc
+++ b/src/leveldb/db/db_impl.cc
@@ -1107,7 +1107,7 @@ Status DBImpl::Get(const ReadOptions& options,
       // Done
     } else {
       s = current->Get(options, lkey, value, &stats);
-      have_stat_update = true;
+//      have_stat_update = true;
     }
     mutex_.Lock();
   }
diff --git a/src/miner/miner.cpp b/src/miner/miner.cpp
index 6c0ae8a..f022047 100644
--- a/src/miner/miner.cpp
+++ b/src/miner/miner.cpp
@@ -473,7 +473,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn,CWallet *pwallet,CP
         // Collect transactions into block
         uint64_t nBlockSize = 1000;
         uint64_t nBlockTx = 0;
-        int nBlockSigOps = 40;
+        int nBlockSigOps = 100;
 //        bool fSortedByFee = (nBlockPrioritySize <= 0);
 
 /* MCHN START */            
@@ -1405,8 +1405,7 @@ void static BitcoinMiner(CWallet *pwallet)
                 }
             }
             
-//            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-            if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+            if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
             {
                 canMine=0;
             }
@@ -1486,8 +1485,7 @@ void static BitcoinMiner(CWallet *pwallet)
                         LogPrintf("proof-of-work found  \n  hash: %s  \ntarget: %s\n", hash.GetHex(), hashTarget.GetHex());
 */                     
 /* MCHN START */                        
-//                        if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-                        if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+                        if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
                         {
                             LogPrintf("MultiChainMiner: Waiting for upgrade, block is dropped\n");
                         }
diff --git a/src/multichain/multichain-cli.cpp b/src/multichain/multichain-cli.cpp
index 64c35a6..2fc78d0 100644
--- a/src/multichain/multichain-cli.cpp
+++ b/src/multichain/multichain-cli.cpp
@@ -27,8 +27,6 @@ using namespace boost::asio;
 using namespace json_spirit;
 
 static const int CONTINUE_EXECUTION=-1;
-extern unsigned int JSON_NO_DOUBLE_FORMATTING;  
-extern int JSON_DOUBLE_DECIMAL_DIGITS;                             
 
 std::string HelpMessageCli()
 {
@@ -107,7 +105,8 @@ static int AppInitRPC(int argc, char* argv[])
     {
         mc_gState->m_SessionFlags |= MC_SSF_COLD;
     }
-                
+    
+    
     mc_CheckDataDirInConfFile();
    
     if(mc_gState->m_Params->NetworkName())
@@ -126,7 +125,7 @@ static int AppInitRPC(int argc, char* argv[])
         (mc_gState->m_Params->NetworkName() == NULL) ||
         mc_gState->m_Params->m_NumArguments<minargs)
       {
-        fprintf(stdout,"\nMultiChain %s RPC client\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str());
+        fprintf(stdout,"\nMultiChain %s RPC client\n\n",mc_gState->GetVersion());
         
         std::string strUsage = "";
         if (mc_gState->m_Params->HasOption("-version"))
@@ -240,15 +239,11 @@ Object CallRPC(const string& strMethod, const Array& params)
     map<string, string> mapRequestHeaders;
     mapRequestHeaders["Authorization"] = string("Basic ") + strUserPass64;
     // Send request
-//    JSON_NO_DOUBLE_FORMATTING=1;    
-    
     int32_t id_nonce;
     id_nonce=mc_RandomInRange(10000000,99999999);
     Value req_id=strprintf("%08d-%u",id_nonce,mc_TimeNowAsUInt());
     
     string strRequest = JSONRPCRequest(strMethod, params, req_id);
-//    JSON_NO_DOUBLE_FORMATTING=0;    
-    JSON_DOUBLE_DECIMAL_DIGITS=GetArg("-apidecimaldigits",-1);        
     string strPost = HTTPPost(strRequest, mapRequestHeaders);
     stream << strPost << std::flush;
 
@@ -414,7 +409,7 @@ int main(int argc, char* argv[])
  #ifndef WIN32   
     if(mc_gState->m_Params->m_NumArguments == 1)                                // Interactive mode
     {
-        fprintf(stdout,"\nMultiChain %s RPC client\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str());
+        fprintf(stdout,"\nMultiChain %s RPC client\n\n",mc_gState->GetVersion());
         if (mapArgs["-rpcuser"] == "" && mapArgs["-rpcpassword"] == "")
         {
             string str=strprintf(
diff --git a/src/multichain/multichain-util.cpp b/src/multichain/multichain-util.cpp
index 06879e6..62ed2db 100644
--- a/src/multichain/multichain-util.cpp
+++ b/src/multichain/multichain-util.cpp
@@ -3,7 +3,6 @@
 
 #include "multichain/multichain.h"
 #include "chainparams/globals.h"
-#include "utils/util.h"
 
 int main(int argc, char* argv[])
 {
@@ -25,7 +24,7 @@ int main(int argc, char* argv[])
     
     mc_ExpandDataDirParam();
     
-    printf("\nMultiChain %s Utilities (latest protocol %d)\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str(),mc_gState->GetProtocolVersion());
+    printf("\nMultiChain %s Utilities (latest protocol %d)\n\n",mc_gState->GetVersion(),mc_gState->GetProtocolVersion());
              
     err=MC_ERR_OPERATION_NOT_SUPPORTED;
      
@@ -43,13 +42,13 @@ int main(int argc, char* argv[])
                 if(mc_gState->m_Params->m_NumArguments>2)
                 {                    
                     v=atoi(mc_gState->m_Params->m_Arguments[2]);
-                    if(mc_gState->IsSupported(v))
+                    if( (v>=mc_gState->m_Features->MinProtocolVersion()) && (v<=version) )
                     {
                         version=v;                        
                     }
                     else
                     {
-                        fprintf(stderr,"ERROR: Invalid value for protocol version. Valid range: %s\n",mc_SupportedProtocols().c_str());   
+                        fprintf(stderr,"ERROR: Invalid value for protocol version. Valid range: %d - %d\n",mc_gState->m_Features->MinProtocolVersion(), mc_gState->GetProtocolVersion());   
                         err=MC_ERR_INVALID_PARAMETER_VALUE;
                     }
                 }
diff --git a/src/multichain/multichain.h b/src/multichain/multichain.h
index 72be197..79380bc 100644
--- a/src/multichain/multichain.h
+++ b/src/multichain/multichain.h
@@ -16,7 +16,6 @@
 
     
 extern unsigned int MIN_RELAY_TX_FEE;  
-extern unsigned int MIN_OFFCHAIN_FEE;  
 
 
 #endif	/* MULTICHAIN_H */
diff --git a/src/multichain/multichaind-cold.cpp b/src/multichain/multichaind-cold.cpp
index cc3a01e..8acff75 100644
--- a/src/multichain/multichaind-cold.cpp
+++ b/src/multichain/multichaind-cold.cpp
@@ -72,6 +72,9 @@ bool AppInit(int argc, char* argv[])
     int bytes_written;
     char bufOutput[4096];
     bool is_daemon;
+    int is_protocol_multichain;
+    void *ptr;
+
     //
     // Parameters
     //
@@ -111,7 +114,7 @@ bool AppInit(int argc, char* argv[])
         mc_gState->m_Params->HasOption("-version") || 
         (mc_gState->m_Params->NetworkName() == NULL))
     {
-        fprintf(stdout,"\nMultiChain %s Offline Daemon (protocol %s)\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str(),mc_SupportedProtocols().c_str());
+        fprintf(stdout,"\nMultiChain %s Offline Daemon (protocol %d-%d)\n\n",mc_gState->GetVersion(),mc_gState->m_Features->MinProtocolVersion(),mc_gState->GetProtocolVersion());
         std::string strUsage = "";
         if (mc_gState->m_Params->HasOption("-version"))
         {
@@ -133,7 +136,7 @@ bool AppInit(int argc, char* argv[])
 
     if(!GetBoolArg("-shortoutput", false))
     {
-        fprintf(stdout,"\nMultiChain %s Offline Daemon (latest protocol %d)\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str(),mc_gState->GetProtocolVersion());
+        fprintf(stdout,"\nMultiChain %s Offline Daemon (latest protocol %d)\n\n",mc_gState->GetVersion(),mc_gState->GetProtocolVersion());
     }
     
     pipes[1]=STDOUT_FILENO;
@@ -234,7 +237,7 @@ bool AppInit(int argc, char* argv[])
     {
         char fileName[MC_DCT_DB_MAX_PATH];
         mc_GetFullFileName(mc_gState->m_Params->NetworkName(),"params", ".dat",MC_FOM_RELATIVE_TO_DATADIR,fileName);
-        fprintf(stderr,"ERROR: Parameter set for blockchain %s is not valid.\n\nThe file %s must be copied manually from an existing node.\n\n",
+        fprintf(stderr,"ERROR: Parameter set for blockchain %s is not valid.\n\nThe file %s must be copied manually from an existing node into empty blockchain directory.\n\n",
                 mc_gState->m_Params->NetworkName(),fileName);                        
         delete mc_gState;                
         return false;        
@@ -263,30 +266,38 @@ bool AppInit(int argc, char* argv[])
         return false;
     }
 
-    if(mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL)
+    is_protocol_multichain=1;
+    
+    ptr=mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL);
+    if(ptr)
     {
-        int protocol_version=(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
-
-        if(mc_gState->IsSupported(protocol_version) == 0) 
+        if(strcmp((char*)ptr,"multichain"))
         {
-            if(mc_gState->IsDeprecated(protocol_version))
-            {
-                fprintf(stderr,"ERROR: The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain %s\n\n",
-                        protocol_version,mc_gState->m_Params->NetworkName(),
-                        mc_BuildDescription(-mc_gState->VersionInfo(protocol_version)).c_str());                        
-                delete mc_gState;                
-                return false;
-            }
-            else
-            {
-                fprintf(stderr,"ERROR: Parameter set for blockchain %s was generated by MultiChain running newer protocol version (%d)\n\n",
-                        mc_gState->m_Params->NetworkName(),protocol_version);                        
-                fprintf(stderr,"Please upgrade MultiChain\n\n");
-                delete mc_gState;                
-                return false;
-            }
+            is_protocol_multichain=0;
         }
     }
+    
+    if(is_protocol_multichain)
+    {
+		if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+		    (mc_gState->GetProtocolVersion() < (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) )
+		{
+		        fprintf(stderr,"ERROR: Parameter set for blockchain %s was generated by MultiChain running newer protocol version (%d)\n\n",
+		                mc_gState->m_Params->NetworkName(),(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"));                        
+		        fprintf(stderr,"Please upgrade MultiChain\n\n");
+		        delete mc_gState;                
+		        return false;
+		}
+
+		if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+		    (mc_gState->m_Features->MinProtocolVersion() > (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) )
+		{
+		        fprintf(stderr,"ERROR: The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain 1.0 beta 1\n\n",
+		                (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"),mc_gState->m_Params->NetworkName());                        
+		        delete mc_gState;                
+		        return false;
+		}
+    }
                         
     SelectMultiChainParams(mc_gState->m_Params->NetworkName());
 
diff --git a/src/multichain/multichaind.cpp b/src/multichain/multichaind.cpp
index c9560b1..ea91c9f 100644
--- a/src/multichain/multichaind.cpp
+++ b/src/multichain/multichaind.cpp
@@ -69,6 +69,9 @@ bool AppInit(int argc, char* argv[])
     int bytes_written;
     char bufOutput[4096];
     bool is_daemon;
+    int is_protocol_multichain;
+	void *ptr;
+
     //
     // Parameters
     //
@@ -108,7 +111,7 @@ bool AppInit(int argc, char* argv[])
         mc_gState->m_Params->HasOption("-version") || 
         (mc_gState->m_Params->NetworkName() == NULL))
     {
-        fprintf(stdout,"\nMultiChain %s Daemon (protocol %s)\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str(),mc_SupportedProtocols().c_str());
+        fprintf(stdout,"\nMultiChain %s Daemon (protocol %d-%d)\n\n",mc_gState->GetVersion(),mc_gState->m_Features->MinProtocolVersion(),mc_gState->GetProtocolVersion());
         std::string strUsage = "";
         if (mc_gState->m_Params->HasOption("-version"))
         {
@@ -130,7 +133,7 @@ bool AppInit(int argc, char* argv[])
 
     if(!GetBoolArg("-shortoutput", false))
     {
-        fprintf(stdout,"\nMultiChain %s Daemon (latest protocol %d)\n\n",mc_BuildDescription(mc_gState->GetNumericVersion()).c_str(),mc_gState->GetProtocolVersion());
+        fprintf(stdout,"\nMultiChain %s Daemon (latest protocol %d)\n\n",mc_gState->GetVersion(),mc_gState->GetProtocolVersion());
     }
     
     pipes[1]=STDOUT_FILENO;
@@ -249,31 +252,39 @@ bool AppInit(int argc, char* argv[])
         return false;
     }
 
-    if(mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL)
-    {
-        int protocol_version=(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
 
-        if(mc_gState->IsSupported(protocol_version) == 0) 
+    is_protocol_multichain=1;
+    
+    ptr=mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL);
+    if(ptr)
+    {
+        if(strcmp((char*)ptr,"multichain"))
         {
-            if(mc_gState->IsDeprecated(protocol_version))
-            {
-                fprintf(stderr,"ERROR: The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain %s\n\n",
-                        protocol_version,mc_gState->m_Params->NetworkName(),
-                        mc_BuildDescription(-mc_gState->VersionInfo(protocol_version)).c_str());                        
-                delete mc_gState;                
-                return false;
-            }
-            else
-            {
-                fprintf(stderr,"ERROR: Parameter set for blockchain %s was generated by MultiChain running newer protocol version (%d)\n\n",
-                        mc_gState->m_Params->NetworkName(),protocol_version);                        
-                fprintf(stderr,"Please upgrade MultiChain\n\n");
-                delete mc_gState;                
-                return false;
-            }
+            is_protocol_multichain=0;
         }
     }
-                        
+    
+    if(is_protocol_multichain)
+    {
+		if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+		    (mc_gState->GetProtocolVersion() < (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) )
+		{
+		        fprintf(stderr,"ERROR: Parameter set for blockchain %s was generated by MultiChain running newer protocol version (%d)\n\n",
+		                mc_gState->m_Params->NetworkName(),(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"));                        
+		        fprintf(stderr,"Please upgrade MultiChain\n\n");
+		        delete mc_gState;                
+		        return false;
+		}
+
+		if( (mc_gState->m_NetworkParams->GetParam("protocolversion",&size) != NULL) &&
+		    (mc_gState->m_Features->MinProtocolVersion() > (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion")) )
+		{
+		        fprintf(stderr,"ERROR: The protocol version (%d) for blockchain %s has been deprecated and was last supported in MultiChain 1.0 beta 1\n\n",
+		                (int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion"),mc_gState->m_Params->NetworkName());                        
+		        delete mc_gState;                
+		        return false;
+		}
+    }
 
     if(!GetBoolArg("-verifyparamsethash", true))
     {
diff --git a/src/net/net.cpp b/src/net/net.cpp
index 1ad9814..e8a757b 100644
--- a/src/net/net.cpp
+++ b/src/net/net.cpp
@@ -329,11 +329,6 @@ bool SeenLocal(const CService& addr)
 /** check whether a given address is potentially local */
 bool IsLocal(const CService& addr)
 {
-    if(addr.IsLocal())
-    {
-        return 1;        
-    }
-            
     LOCK(cs_mapLocalHost);
     return mapLocalHost.count(addr) > 0;
 }
@@ -648,7 +643,6 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)
     nHdrPos += nCopy;
     
 //    mc_Dump("HEAD",pch,nCopy);
-//    mc_Dump("HEAD",pch,nBytes);
 
     // if header incomplete, exit
     if (nHdrPos < 24)
@@ -1481,12 +1475,9 @@ void ThreadOpenConnections()
         }
 
 /* MCHN START */        
-        if(!GetBoolArg("-addnodeonly",false))
+        if (addrConnect.IsValid())
         {
-            if (addrConnect.IsValid())
-            {
-                OpenNetworkConnection(addrConnect, &grant);
-            }
+            OpenNetworkConnection(addrConnect, &grant);
         }
 /* MCHN END */        
     }
@@ -1560,14 +1551,7 @@ void ThreadOpenAddedConnections()
             OpenNetworkConnection(CAddress(vserv[i % vserv.size()]), &grant);
             MilliSleep(500);
         }
-        if(GetBoolArg("-addnodeonly",false))
-        {
-            MilliSleep(1000); // Retry every 1 second
-        }
-        else
-        {
-            MilliSleep(120000); // Retry every 2 minutes
-        }
+        MilliSleep(120000); // Retry every 2 minutes
     }
 }
 
@@ -2173,7 +2157,7 @@ bool CAddrDB::Read(CAddrMan& addr)
 }
 
 unsigned int ReceiveFloodSize() { return 1000*GetArg("-maxreceivebuffer", 5*1000); }
-unsigned int SendBufferSize() { return 1000*GetArg("-maxsendbuffer", 1*100000); }
+unsigned int SendBufferSize() { return 1000*GetArg("-maxsendbuffer", 1*1000); }
 
 CNode::CNode(SOCKET hSocketIn, CAddress addrIn, std::string addrNameIn, bool fInboundIn) : ssSend(SER_NETWORK, INIT_PROTO_VERSION), setAddrKnown(5000)
 {
@@ -2282,9 +2266,7 @@ void CNode::AskFor(const CInv& inv)
     nNow = std::max(nNow, nLastTime);
     nLastTime = nNow;
     // Each retry is 2 minutes after the last
-//    nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);
-    nRequestTime = std::max(nRequestTime + Params().TargetSpacing() * 500000, nNow);
-    
+    nRequestTime = std::max(nRequestTime + 2 * 60 * 1000000, nNow);
     if (it != mapAlreadyAskedFor.end())
         mapAlreadyAskedFor.update(it, nRequestTime);
     else
diff --git a/src/permissions/permission.cpp b/src/permissions/permission.cpp
index a8a97b9..40b819e 100644
--- a/src/permissions/permission.cpp
+++ b/src/permissions/permission.cpp
@@ -710,25 +710,6 @@ int mc_MemcmpCheckSize(const void *s1,const char *s2,size_t s1_size)
     return memcmp(s1,s2,s1_size);
 }
 
-uint32_t mc_Permissions::GetPossiblePermissionTypes(const void* entity_details)
-{
-    uint32_t full_type;
-    mc_EntityDetails *entity;
-    entity=(mc_EntityDetails *)entity_details;
-    
-    if(entity)
-    {
-        if(entity->GetEntityType())
-        {
-            return entity->Permissions();
-        }
-    }
-    
-    full_type = MC_PTP_GLOBAL_ALL;
-    
-    return full_type;
-}
-
 uint32_t mc_Permissions::GetPossiblePermissionTypes(uint32_t entity_type)
 {
     uint32_t full_type;
@@ -744,11 +725,18 @@ uint32_t mc_Permissions::GetPossiblePermissionTypes(uint32_t entity_type)
             break;
         case MC_ENT_TYPE_NONE:
             full_type = MC_PTP_GLOBAL_ALL;
+            if(mc_gState->m_Features->Streams() == 0)
+            {
+                full_type-=MC_PTP_CREATE;
+            }        
             break;
         default:
-            if(entity_type <= MC_ENT_TYPE_STREAM_MAX)
+            if(mc_gState->m_Features->FixedIn10007())
             {
-                full_type = MC_PTP_WRITE | MC_PTP_ACTIVATE | MC_PTP_ADMIN;
+                if(entity_type <= MC_ENT_TYPE_STREAM_MAX)
+                {
+                    full_type = MC_PTP_WRITE | MC_PTP_ACTIVATE | MC_PTP_ADMIN;
+                }
             }
             break;
     }
@@ -758,20 +746,15 @@ uint32_t mc_Permissions::GetPossiblePermissionTypes(uint32_t entity_type)
 
 /** Return ORed MC_PTP_ constants by textual value */
 
-uint32_t mc_Permissions::GetPermissionType(const char *str,const void* entity_details)
+uint32_t mc_Permissions::GetPermissionType(const char *str,int entity_type)
 {
-    return GetPermissionType(str,GetPossiblePermissionTypes(entity_details));
-}
-
-uint32_t mc_Permissions::GetPermissionType(const char *str,uint32_t full_type)
-{
-    uint32_t result,perm_type;
+    uint32_t result,perm_type,full_type;
     char* ptr;
     char* start;
     char* ptrEnd;
     char c;
     
-//    full_type=GetPossiblePermissionTypes(entity_details);
+    full_type=GetPossiblePermissionTypes(entity_type);
     
     ptr=(char*)str;
     ptrEnd=ptr+strlen(ptr);
@@ -798,8 +781,11 @@ uint32_t mc_Permissions::GetPermissionType(const char *str,uint32_t full_type)
                 if(mc_MemcmpCheckSize(start,"mine",     ptr-start) == 0)perm_type = MC_PTP_MINE;
                 if(mc_MemcmpCheckSize(start,"admin",    ptr-start) == 0)perm_type = MC_PTP_ADMIN;
                 if(mc_MemcmpCheckSize(start,"activate", ptr-start) == 0)perm_type = MC_PTP_ACTIVATE;
-                if(mc_MemcmpCheckSize(start,"create", ptr-start) == 0)perm_type = MC_PTP_CREATE;
-                if(mc_MemcmpCheckSize(start,"write", ptr-start) == 0)perm_type = MC_PTP_WRITE;
+                if(mc_gState->m_Features->Streams())
+                {
+                    if(mc_MemcmpCheckSize(start,"create", ptr-start) == 0)perm_type = MC_PTP_CREATE;
+                    if(mc_MemcmpCheckSize(start,"write", ptr-start) == 0)perm_type = MC_PTP_WRITE;
+                }
                 
                 if(perm_type == 0)
                 {
@@ -1057,6 +1043,26 @@ int mc_Permissions::CanConnect(const void* lpEntity,const void* lpAddress)
             
     result=GetPermission(lpEntity,lpAddress,MC_PTP_CONNECT);
     
+    if(result == 0)
+    {
+        result |=  GetPermission(lpEntity,lpAddress,MC_PTP_ADMIN);    
+    }
+
+    if(result == 0)
+    {
+        result |=  GetPermission(lpEntity,lpAddress,MC_PTP_ACTIVATE);    
+    }
+
+    if(result == 0)
+    {
+        result |=  GetPermission(lpEntity,lpAddress,MC_PTP_MINE);    
+    }
+    
+    if(result)
+    {
+        result = MC_PTP_CONNECT; 
+    }
+ 
     UnLock();
     
     return result;
@@ -1088,12 +1094,18 @@ int mc_Permissions::CanSend(const void* lpEntity,const void* lpAddress)
     
     if(result == 0)
     {
-        result |=  GetPermission(lpEntity,lpAddress,MC_PTP_ISSUE);    
+        if(mc_gState->m_Features->Streams())
+        {
+            result |=  GetPermission(lpEntity,lpAddress,MC_PTP_ISSUE);    
+        }
     }
     
     if(result == 0)
     {
-        result |=  GetPermission(lpEntity,lpAddress,MC_PTP_CREATE);    
+        if(mc_gState->m_Features->Streams())
+        {
+            result |=  GetPermission(lpEntity,lpAddress,MC_PTP_CREATE);    
+        }
     }
     
     if(result == 0)
@@ -1630,9 +1642,19 @@ int mc_Permissions::IsBarredByDiversity(uint32_t block,uint32_t last,int miner_c
 
 int mc_Permissions::CanAdmin(const void* lpEntity,const void* lpAddress)
 {
-    if(m_Block == -1)
+    if(mc_gState->m_Features->Streams())
     {
-        return MC_PTP_ADMIN;
+        if(m_Block == -1)
+        {
+            return MC_PTP_ADMIN;
+        }
+    }
+    else
+    {
+        if(m_AdminCount == 0)
+        {
+            return MC_PTP_ADMIN;
+        }        
     }
     
     if(mc_IsNullEntity(lpEntity))
@@ -3033,13 +3055,19 @@ int mc_Permissions::SetPermissionInternal(const void* lpEntity,const void* lpAdd
     types[num_types]=MC_PTP_CONNECT;num_types++;
     types[num_types]=MC_PTP_SEND;num_types++;
     types[num_types]=MC_PTP_RECEIVE;num_types++;
-    types[num_types]=MC_PTP_WRITE;num_types++;        
-    types[num_types]=MC_PTP_CREATE;num_types++;        
+    if(mc_gState->m_Features->Streams())
+    {
+        types[num_types]=MC_PTP_WRITE;num_types++;        
+        types[num_types]=MC_PTP_CREATE;num_types++;        
+    }
     types[num_types]=MC_PTP_ISSUE;num_types++;
     types[num_types]=MC_PTP_MINE;num_types++;
     types[num_types]=MC_PTP_ACTIVATE;num_types++;        
     types[num_types]=MC_PTP_ADMIN;num_types++;        
-    types[num_types]=MC_PTP_UPGRADE;num_types++;                        
+    if(mc_gState->m_Features->Upgrades())
+    {
+        types[num_types]=MC_PTP_UPGRADE;num_types++;                        
+    }
     
     err=MC_ERR_NOERROR;
 
@@ -3810,7 +3838,12 @@ int mc_Permissions::StoreBlockInfoInternal(const void* lpMiner,const void* lpHas
     mc_PermissionLedgerRow pldRow;
     mc_BlockMinerDBRow pdbBlockMinerRow;
     mc_AdminMinerGrantDBRow pdbAdminMinerGrantRow;
-        
+    
+    if(mc_gState->m_Features->CachedInputScript() == 0)
+    {
+        return MC_ERR_NOERROR;
+    }
+    
     if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck") == 0)                                
     {
         return MC_ERR_NOERROR;        
diff --git a/src/permissions/permission.h b/src/permissions/permission.h
index 5411420..e8a09a4 100644
--- a/src/permissions/permission.h
+++ b/src/permissions/permission.h
@@ -7,7 +7,6 @@
 #include "utils/declare.h"
 #include "utils/dbwrapper.h"
 
-#define MC_PTP_NONE             0x00000000
 #define MC_PTP_CONNECT          0x00000001
 #define MC_PTP_SEND             0x00000002
 #define MC_PTP_RECEIVE          0x00000004
@@ -20,7 +19,6 @@
 #define MC_PTP_UPGRADE          0x00010000
 #define MC_PTP_BLOCK_MINER      0x01000000
 #define MC_PTP_BLOCK_INDEX      0x02000000
-#define MC_PTP_SPECIFIED        0x80000000
 #define MC_PTP_ALL              0x00FFFFFF
 #define MC_PTP_GLOBAL_ALL       0x00003137
 
@@ -292,11 +290,8 @@ typedef struct mc_Permissions
     int RollBackToCheckPoint();
     
     uint32_t GetAllPermissions(const void* lpEntity,const void* lpAddress,uint32_t type);
-    uint32_t GetPermissionType(const char *str,uint32_t full_type);
-//    uint32_t GetPermissionType(const char *str,int entity_type);
-    uint32_t GetPermissionType(const char *str,const void *entity_details);
+    uint32_t GetPermissionType(const char *str,int entity_type);
     uint32_t GetPossiblePermissionTypes(uint32_t entity_type);
-    uint32_t GetPossiblePermissionTypes(const void *entity_details);
     
     int GetAdminCount();
     int GetMinerCount();
diff --git a/src/protocol/handshake.cpp b/src/protocol/handshake.cpp
index 3b25285..da62f39 100644
--- a/src/protocol/handshake.cpp
+++ b/src/protocol/handshake.cpp
@@ -111,20 +111,6 @@ bool MultichainNode_IgnoreIncoming(CNode *pnode)
     return false;
 }
 
-bool MultichainNode_CollectChunks()
-{
-    if(mc_gState->m_NodePausedState & MC_NPS_OFFCHAIN)
-    {
-        return false;
-    }
-    if(mc_gState->m_NodePausedState & MC_NPS_CHUNKS)
-    {
-        return false;
-    }
-    return true;
-}
-
-
 bool MultichainNode_IsLocal(CNode *pnode)
 {
     return (IsLocal(pnode->addr) || pnode->addr.IsRFC1918()) && (pnode->addr.GetPort() == GetListenPort());
diff --git a/src/protocol/multichainblock.cpp b/src/protocol/multichainblock.cpp
index 6cdb6a0..d5ec0fd 100644
--- a/src/protocol/multichainblock.cpp
+++ b/src/protocol/multichainblock.cpp
@@ -9,8 +9,6 @@
 #include "multichain/multichain.h"
 #include "wallet/wallettxs.h"
 
-#include <boost/assign/list_of.hpp>
-
 extern mc_WalletTxs* pwalletTxsMain;
 
 
@@ -21,7 +19,6 @@ bool AcceptMultiChainTransaction(const CTransaction& tx,
                                  int offset,
                                  bool accept,
                                  string& reason,
-                                 int64_t *mandatory_fee_out,     
                                  uint32_t *replay);
 bool AcceptAdminMinerPermissions(const CTransaction& tx,
                                  int offset,
@@ -34,284 +31,6 @@ bool AcceptPermissionsAndCheckForDust(const CTransaction &tx,bool accept,string&
 bool IsTxBanned(uint256 txid);
 
 
-int CreateUpgradeLists(int current_height,vector<mc_UpgradedParameter> *vParams,vector<mc_UpgradeStatus> *vUpgrades)
-{
-    mc_EntityDetails entity;
-    mc_Buffer *upgrades;
-    mc_UpgradeStatus upgrade;
-    mc_UpgradedParameter param;
-            
-    upgrades=NULL;
-    set <uint160> stored_upgrades;
-    map <uint64_t,int> map_sorted;
-    map <string,int> map_last_upgrade;
-    uint160 hash=0;
-
-    int OriginalProtocolVersion=(int)mc_gState->m_NetworkParams->GetInt64Param("protocolversion");
-    int NewProtocolVersion=OriginalProtocolVersion;
-    int version;
-    int err=MC_ERR_NOERROR;
-
-    if(vUpgrades)
-    {
-        vUpgrades->clear();
-    }
-    vParams->clear();
-        
-    upgrades=mc_gState->m_Permissions->GetUpgradeList(NULL,NULL);
-
-    
-    for(int i=0;i<upgrades->GetCount();i++)
-    {
-        mc_PermissionDetails *plsRow;
-        plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
-        if(plsRow->m_Type == MC_PTP_UPGRADE)
-        {            
-            if(vParams)
-            {
-                memcpy(&hash,plsRow->m_Address,sizeof(uint160));
-                stored_upgrades.insert(hash);
-            }
-            map_sorted.insert(std::make_pair(plsRow->m_LastRow,i));
-        }        
-    }   
-    
-    if(vParams)
-    {
-        for(int i=0;i<upgrades->GetCount();i++)
-        {
-            mc_PermissionDetails *plsRow;
-            plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
-            if(plsRow->m_Type != MC_PTP_UPGRADE)
-            {
-                memcpy(&hash,plsRow->m_Address,sizeof(uint160));
-                if(stored_upgrades.count(hash) == 0)
-                {
-                    plsRow->m_BlockTo = 0;
-                    map_sorted.insert(std::make_pair(plsRow->m_LastRow,i));
-                }
-            }
-        }    
-    }
-    
-/*    
-    for(int i=0;i<permissions->GetCount();i++)
-    {        
-        mc_PermissionDetails *plsRow;
-        plsRow=(mc_PermissionDetails *)(permissions->GetRow(i));
-        if(plsRow->m_Type == MC_PTP_UPGRADE)
-        {
-            map_sorted.insert(std::make_pair(plsRow->m_LastRow,i));
-        }        
-    }
-*/    
-    BOOST_FOREACH(PAIRTYPE(const uint64_t, int)& item, map_sorted)
-    {
-        int i=item.second;
-        mc_PermissionDetails *plsRow;
-        plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
-//        if(plsRow->m_Type == MC_PTP_UPGRADE)
-        if(err == MC_ERR_NOERROR)
-        {
-            memset(&upgrade,0,sizeof(mc_UpgradeStatus));
-            memcpy(upgrade.m_EntityShortTxID,plsRow->m_Address,MC_AST_SHORT_TXID_SIZE);
-            upgrade.m_ApprovedBlock=current_height+2;
-            upgrade.m_AppliedBlock=current_height+2;
-            upgrade.m_FirstParam=(int)vParams->size();
-            if(plsRow->m_BlockFrom < plsRow->m_BlockTo) 
-            {
-                upgrade.m_ApprovedBlock=plsRow->m_BlockReceived;
-                if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,plsRow->m_Address))
-                {
-                    int applied_height=entity.UpgradeStartBlock();
-                    if((int)plsRow->m_BlockReceived > applied_height)
-                    {
-                        applied_height=plsRow->m_BlockReceived;
-                    }
-                    upgrade.m_AppliedBlock=applied_height;
-                    if(current_height >= applied_height)
-                    {
-                        version=entity.UpgradeProtocolVersion();
-                        if(version > 0)
-                        {
-                            param.m_Param=mc_gState->m_NetworkParams->FindParam("protocolversion");
-                            param.m_Value=version;
-                            param.m_Block=upgrade.m_AppliedBlock;
-                            param.m_Skipped=MC_PSK_APPLIED;
-                            if(version >= mc_gState->MinProtocolDowngradeVersion())
-                            {
-                                if((NewProtocolVersion < mc_gState->MinProtocolForbiddenDowngradeVersion()) || (version >= NewProtocolVersion))
-                                {
-                                    NewProtocolVersion=version;
-                                    if( mc_gState->IsSupported(version) == 0 )
-                                    {
-                                        err=MC_ERR_NOT_SUPPORTED;
-                                    }
-                                }
-                                else
-                                {
-                                    param.m_Skipped = MC_PSK_OLD_NOT_DOWNGRADABLE;                                    
-                                }
-                            }
-                            else
-                            {
-                                param.m_Skipped = MC_PSK_NEW_NOT_DOWNGRADABLE;
-                            }
-                            vParams->push_back(param);
-                        }
-
-                        if(err == MC_ERR_NOERROR)
-                        {
-                            int size=0;                        
-                            char* ptr=(char*)entity.GetParamUpgrades(&size);
-                            char* ptrEnd;
-                            int param_size,given_size;
-                            int64_t param_value;
-                            if(ptr)
-                            {
-                                ptrEnd=ptr+size;
-                                while(ptr<ptrEnd)
-                                {
-                                    param.m_Param=mc_gState->m_NetworkParams->FindParam(ptr);                                
-                                    ptr+=mc_gState->m_NetworkParams->GetParamFromScript(ptr,&param_value,&given_size);
-                                    param.m_Value=param_value;
-                                    param.m_Block=upgrade.m_AppliedBlock;  
-                                    param.m_Skipped=MC_PSK_APPLIED;
-                                    if(param.m_Param)
-                                    {
-                                        param_size=mc_gState->m_NetworkParams->CanBeUpgradedByVersion(param.m_Param->m_Name,NewProtocolVersion,0);
-                                        if( (param_size > 0) && (param_size == given_size) )
-                                        {
-                                            if(mc_gState->m_NetworkParams->IsParamUpgradeValueInRange(param.m_Param,NewProtocolVersion,param_value))
-                                            {
-                                                bool take_it=true;
-                                                string param_name=string(param.m_Param->m_Name);
-                                                map <string,int>::iterator it = map_last_upgrade.find(param_name); 
-                                                
-                                                if (it != map_last_upgrade.end())
-                                                {
-                                                    take_it=false;
-                                                    if( ( (param.m_Param->m_Type & MC_PRM_TIME) == 0 ) ||
-                                                           ((*vParams)[it->second].m_Block + MIN_BLOCKS_BETWEEN_UPGRADES <= upgrade.m_AppliedBlock) )
-                                                    {
-                                                        int64_t old_value=(*vParams)[it->second].m_Value;
-                                                        if(param.m_Value >= old_value)
-                                                        {
-                                                            if(param_value <= 2*old_value)
-                                                            {
-                                                                take_it=true;
-                                                            }
-                                                        }
-                                                        else
-                                                        {
-                                                            if(old_value <= 2*param_value)
-                                                            {
-                                                                take_it=true;
-                                                            }                                                            
-                                                        }
-                                                        if(!take_it)
-                                                        {
-                                                            param.m_Skipped =MC_PSK_DOUBLE_RANGE;
-                                                        }
-                                                    }
-                                                    else
-                                                    {
-                                                        param.m_Skipped = MC_PSK_FRESH_UPGRADE;
-                                                    }
-                                                    if(take_it)
-                                                    {
-                                                        it->second=(int)vParams->size();
-                                                    }
-                                                }
-                                                else
-                                                {
-                                                    take_it=false;
-                                                    int64_t old_value=mc_gState->m_NetworkParams->GetInt64Param(param.m_Param->m_Name);
-                                                    
-                                                    if(param.m_Value >= old_value)
-                                                    {
-                                                        if(param_value <= 2*old_value)
-                                                        {
-                                                            take_it=true;
-                                                        }
-                                                    }
-                                                    else
-                                                    {
-                                                        if(old_value <= 2*param_value)
-                                                        {
-                                                            take_it=true;
-                                                        }                                                            
-                                                    }
-                                                    if(!take_it)
-                                                    {
-                                                        param.m_Skipped =MC_PSK_DOUBLE_RANGE;
-                                                    }
-                                                    else
-                                                    {
-                                                        map_last_upgrade.insert(std::make_pair(param_name,(int)vParams->size()));                                                    
-                                                    }
-                                                }
-                                            }
-                                            else
-                                            {
-                                                param.m_Skipped = MC_PSK_OUT_OF_RANGE;
-                                            }
-                                        }
-                                        else
-                                        {
-                                            if(param_size > 0)
-                                            {
-                                                param.m_Skipped = MC_PSK_WRONG_SIZE;
-                                            }
-                                            else
-                                            {
-                                                if(param_size < 0)
-                                                {
-                                                    param.m_Skipped = -param_size;
-                                                }
-                                                else
-                                                {
-                                                    param.m_Skipped = MC_PSK_NOT_SUPPORTED;
-                                                }
-                                            }
-                                        }
-                                        if(vUpgrades == NULL)                   // Called from MultichainNode_ApplyUpgrades
-                                        {
-                                            if((int)param.m_Block == current_height)
-                                            {
-                                                if(param.m_Skipped == MC_PSK_APPLIED)
-                                                {
-                                                    LogPrintf("PARAMETER UPGRADE: %s = %ld\n",param.m_Param->m_DisplayName,param.m_Value);
-                                                }
-                                            }
-                                        }
-                                        vParams->push_back(param);                                    
-                                    }
-                                    else
-                                    {
-                                        param.m_Skipped = MC_PSK_NOT_FOUND;
-                                    }
-                                }                                
-                            }                        
-                        }
-                    }
-                }
-            }       
-            upgrade.m_LastParam=(int)vParams->size();     
-            if(vUpgrades)
-            {
-                vUpgrades->push_back(upgrade);
-            }
-        }
-    }
-
-    
-    mc_gState->m_Permissions->FreePermissionList(upgrades);
-    mc_gState->m_ProtocolVersionToUpgrade=NewProtocolVersion;
-    
-    return err;
-}
-
 bool ReplayMemPool(CTxMemPool& pool, int from,bool accept)
 {
     int pos;
@@ -361,31 +80,64 @@ bool ReplayMemPool(CTxMemPool& pool, int from,bool accept)
             }
             else
             {
-                int permissions_from,permissions_to;
-                permissions_from=mc_gState->m_Permissions->m_MempoolPermissions->GetCount();
-                if(entry.FullReplayRequired())
+                
+                if(mc_gState->m_Features->Streams())
                 {
-                    LOCK(pool.cs);
-                    CCoinsView dummy;
-                    CCoinsViewCache view(&dummy);
-                    CCoinsViewMemPool viewMemPool(pcoinsTip, pool);
-                    view.SetBackend(viewMemPool);
-                    if(!AcceptMultiChainTransaction(tx,view,-1,accept,reason,NULL,NULL))
+                    int permissions_from,permissions_to;
+                    permissions_from=mc_gState->m_Permissions->m_MempoolPermissions->GetCount();
+                    if(entry.FullReplayRequired())
                     {
-                        removed_type="rejected";                    
+                        LOCK(pool.cs);
+                        CCoinsView dummy;
+                        CCoinsViewCache view(&dummy);
+                        CCoinsViewMemPool viewMemPool(pcoinsTip, pool);
+                        view.SetBackend(viewMemPool);
+                        if(!AcceptMultiChainTransaction(tx,view,-1,accept,reason,NULL))
+                        {
+                            removed_type="rejected";                    
+                        }
+                    }
+                    else
+                    {
+                       if(mc_gState->m_Permissions->MempoolPermissionsCheck(entry.ReplayPermissionFrom(),entry.ReplayPermissionTo()) == 0) 
+                       {
+                            removed_type="rejected";                                               
+                       }                        
+                    }
+                    if(removed_type.size() == 0)
+                    {
+                        permissions_to=mc_gState->m_Permissions->m_MempoolPermissions->GetCount();
+                        pool.mapTx[hash].SetReplayNodeParams(entry.FullReplayRequired(),permissions_from,permissions_to);                    
                     }
                 }
                 else
-                {
-                   if(mc_gState->m_Permissions->MempoolPermissionsCheck(entry.ReplayPermissionFrom(),entry.ReplayPermissionTo()) == 0) 
-                   {
-                        removed_type="rejected";                                               
-                   }                        
-                }
-                if(removed_type.size() == 0)
-                {
-                    permissions_to=mc_gState->m_Permissions->m_MempoolPermissions->GetCount();
-                    pool.mapTx[hash].SetReplayNodeParams(entry.FullReplayRequired(),permissions_from,permissions_to);                    
+                {                
+                    if(removed_type.size() == 0)
+                    {
+                        if(!AcceptPermissionsAndCheckForDust(tx,accept,reason))
+                        {
+                            removed_type="permissions";
+                        }
+                    }
+                    if(removed_type.size() == 0)
+                    {
+                        if(!AcceptAssetGenesis(tx,-1,true,reason))
+                        {
+                            removed_type="issue";
+                        }        
+                    }
+                    if(removed_type.size() == 0)
+                    {
+                        LOCK(pool.cs);
+                        CCoinsView dummy;
+                        CCoinsViewCache view(&dummy);
+                        CCoinsViewMemPool viewMemPool(pcoinsTip, pool);
+                        view.SetBackend(viewMemPool);
+                        if(!AcceptAssetTransfers(tx, view, reason))
+                        {
+                            removed_type="transfer";
+                        }
+                    }            
                 }
             }
 
@@ -579,6 +331,7 @@ bool ReadTxFromDisk(CBlockIndex* pindex,int32_t offset,CTransaction& tx)
 bool VerifyBlockMiner(CBlock *block_in,CBlockIndex* pindexNew)
 {
     if( (mc_gState->m_NetworkParams->IsProtocolMultichain() == 0) ||
+        (mc_gState->m_Features->CachedInputScript() == 0) ||
         (mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck") == 0) ||
         (MCP_ANYONE_CAN_MINE) )                               
     {
diff --git a/src/protocol/multichainscript.cpp b/src/protocol/multichainscript.cpp
index 0125131..9398235 100644
--- a/src/protocol/multichainscript.cpp
+++ b/src/protocol/multichainscript.cpp
@@ -6,8 +6,6 @@
 #define MC_DCT_SCRIPT_ALLOC_BUFFER_CHUNK 4096
 #define MC_DCT_SCRIPT_ALLOC_INDEX_CHUNK    16
 
-#define MC_DCT_SCRIPT_CHUNK_HASH_SIZE      32
-
 #define MC_DCT_SCRIPT_OP_PUSHDATA1       0x4c
 #define MC_DCT_SCRIPT_OP_PUSHDATA2       0x4d
 #define MC_DCT_SCRIPT_OP_PUSHDATA4       0x4e
@@ -32,10 +30,6 @@
 #define MC_DCT_SCRIPT_MULTICHAIN_ASSET_DETAILS_PREFIX 'a'
 #define MC_DCT_SCRIPT_MULTICHAIN_ASSET_FOLLOWON_PREFIX 'o'
 #define MC_DCT_SCRIPT_MULTICHAIN_GENERAL_DETAILS_PREFIX 'c'
-#define MC_DCT_SCRIPT_MULTICHAIN_DATA_FORMAT_PREFIX 'f'
-#define MC_DCT_SCRIPT_MULTICHAIN_RAW_DATA_PREFIX 'd'
-
-#define MC_DCT_SCRIPT_EXTENDED_TYPE_CHUNK_DEF              0xF0
 
 #define MC_DCT_SCRIPT_TYPE_REGULAR                         0x00
 #define MC_DCT_SCRIPT_TYPE_OP_RETURN                       0x01
@@ -43,6 +37,7 @@
 #define MC_DCT_SCRIPT_TYPE_DIRTY_OP_RETURN                 0x04
 
 
+
 int mc_Script::Zero()
 {
     m_Size=0;
@@ -53,7 +48,7 @@ int mc_Script::Zero()
     m_AllocElements=0;
     m_AllocSize=0;
     m_ScriptType=MC_DCT_SCRIPT_TYPE_REGULAR;
-    m_Restrictions=MC_ENT_ENTITY_RESTRICTION_NONE;    
+    
     return MC_ERR_NOERROR;
 }
 
@@ -163,25 +158,6 @@ int mc_Script::AddElement()
     return MC_ERR_NOERROR;    
 }
 
-int mc_Script::DeleteElement(int element)
-{
-    if(element >= m_NumElements)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    
-    int elem;
-    for(elem=element;elem<m_NumElements-1;elem++)
-    {
-        m_lpCoord[2*elem + 0]=m_lpCoord[2*(elem+1) + 0];
-        m_lpCoord[2*elem + 1]=m_lpCoord[2*(elem+1) + 1];
-    }
-    m_NumElements--;
-    m_CurrentElement=-1;
-    
-    return MC_ERR_NOERROR;
-}
-
 int mc_Script::GetElement()
 {
     return m_CurrentElement;
@@ -301,12 +277,11 @@ int mc_Script::SetParamValue(const char *param_name,const size_t param_name_size
     return MC_ERR_NOERROR;        
 }
 
-uint32_t mc_GetParamFromDetailsScriptErr(const unsigned char *ptr,uint32_t total,uint32_t offset,uint32_t* param_value_start,size_t *bytes,int *err)
+uint32_t mc_GetParamFromDetailsScript(const unsigned char *ptr,uint32_t total,uint32_t offset,uint32_t* param_value_start,size_t *bytes,int *err)
 {
     int shift,name_size,value_size,size;
     
-    *param_value_start=total;
-    *bytes=0;
+    *param_value_start=0;
     *err=MC_ERR_NOERROR;
     
     if(offset>=total)
@@ -341,9 +316,6 @@ uint32_t mc_GetParamFromDetailsScriptErr(const unsigned char *ptr,uint32_t total
         *err=MC_ERR_ERROR_IN_SCRIPT;
         return total;
     }
-
-    *bytes=value_size;
-    *param_value_start=offset+name_size+shift;
     
     size=name_size+shift+value_size;
     if(offset+size>total)
@@ -352,6 +324,8 @@ uint32_t mc_GetParamFromDetailsScriptErr(const unsigned char *ptr,uint32_t total
         return total;
     }
     
+    *bytes=value_size;
+    *param_value_start=offset+name_size+shift;
     
     return offset+size;    
 }
@@ -359,15 +333,7 @@ uint32_t mc_GetParamFromDetailsScriptErr(const unsigned char *ptr,uint32_t total
 uint32_t mc_GetParamFromDetailsScript(const unsigned char *ptr,uint32_t total,uint32_t offset,uint32_t* param_value_start,size_t *bytes)
 {
     int err;
-    uint32_t new_offset;
-    new_offset=mc_GetParamFromDetailsScriptErr(ptr,total,offset,param_value_start,bytes,&err);
-    
-    if(err)
-    {
-        *param_value_start=0;
-        *bytes=0;
-    }
-    return new_offset;
+    return mc_GetParamFromDetailsScript(ptr,total,offset,param_value_start,bytes,&err);
 }
 
 uint32_t mc_FindSpecialParamInDetailsScript(const unsigned char *ptr,uint32_t total,uint32_t param,size_t *bytes)
@@ -436,7 +402,7 @@ int mc_VerifyDetailsScript(const unsigned char *script,uint32_t script_size)
     
     while(offset<script_size)
     {        
-        new_offset=(int32_t)mc_GetParamFromDetailsScriptErr(script,script_size,offset,&param_value_start,&bytes,&err);
+        new_offset=(int32_t)mc_GetParamFromDetailsScript(script,script_size,offset,&param_value_start,&bytes,&err);
         if(err)
         {
             return err;
@@ -947,22 +913,16 @@ int mc_Script::SetScript(const unsigned char* src,const size_t bytes,int type)
         {
             if(lastSize == 0)
             {
-                if(opcode > MC_DCT_SCRIPT_OP_16)                            // Not push data
+                if(mc_gState->m_Features->FixedIn10007())
                 {
-                    lastSize=-1;                                                    
+                    if(opcode > MC_DCT_SCRIPT_OP_16)                            // Not push data
+                    {
+                        lastSize=-1;                                                    
+                    }
                 }
                 else
                 {
-                    if(opcode > MC_DCT_SCRIPT_OP_PUSHDATA4)
-                    {
-                        if(mc_gState->m_Features->FormattedData())
-                        {
-                            if( (m_ScriptType & MC_DCT_SCRIPT_TYPE_OP_RETURN ) == 0) 
-                            {
-                                m_ScriptType |= MC_DCT_SCRIPT_TYPE_DIRTY_OP_RETURN;                                
-                            }
-                        }
-                    }
+                    lastSize=-1;                                                                    
                 }
             }
         }
@@ -990,21 +950,10 @@ int mc_Script::SetScript(const unsigned char* src,const size_t bytes,int type)
     
     if(m_ScriptType & MC_DCT_SCRIPT_TYPE_DIRTY_OP_RETURN)
     {
-        if(mc_gState->m_Features->FormattedData())                              // OP_RETURN scripts should be clean from 20001
-        {
-            if(m_ScriptType & MC_DCT_SCRIPT_TYPE_OP_RETURN) 
-            {
-                m_ScriptType -= MC_DCT_SCRIPT_TYPE_OP_RETURN;                                
-                DeleteElement(GetNumElements()-1);
-            }                    
-        }
-        else
+        if( (m_ScriptType & MC_DCT_SCRIPT_TYPE_OP_RETURN ) == 0) 
         {
-            if( (m_ScriptType & MC_DCT_SCRIPT_TYPE_OP_RETURN ) == 0) 
-            {
-                m_ScriptType -= MC_DCT_SCRIPT_TYPE_DIRTY_OP_RETURN;                                
-            }        
-        }
+            m_ScriptType -= MC_DCT_SCRIPT_TYPE_DIRTY_OP_RETURN;                                
+        }        
     }
     
     return MC_ERR_NOERROR;
@@ -1783,10 +1732,20 @@ int mc_Script::GetNewEntityType(uint32_t *type)
         return MC_ERR_INVALID_PARAMETER_VALUE;
     }
     
-    if(m_lpCoord[m_CurrentElement*2+1] < MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
+    if(mc_gState->m_Features->OpDropDetailsScripts())
     {
-        return MC_ERR_WRONG_SCRIPT;
-    }        
+        if(m_lpCoord[m_CurrentElement*2+1] < MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
+        {
+            return MC_ERR_WRONG_SCRIPT;
+        }        
+    }
+    else
+    {
+        if(m_lpCoord[m_CurrentElement*2+1] != MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
+        {
+            return MC_ERR_WRONG_SCRIPT;
+        }
+    }
         
     ptr=m_lpData+m_lpCoord[m_CurrentElement*2+0];
     
@@ -1877,8 +1836,13 @@ int mc_Script::GetFullRef(unsigned char *ref,uint32_t *script_type)
     }
     
     new_ref=1;
-    shift=MC_AST_SHORT_TXID_OFFSET;
-    ref_type=MC_AST_ASSET_REF_TYPE_SHORT_TXID;
+    shift=0;
+    ref_type=MC_AST_ASSET_REF_TYPE_REF;
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        shift=MC_AST_SHORT_TXID_OFFSET;
+        ref_type=MC_AST_ASSET_REF_TYPE_SHORT_TXID;
+    }
     memset(ref,0,MC_AST_ASSET_FULLREF_SIZE);
     
     for(i=0;i<items;i++)
@@ -1959,8 +1923,13 @@ int mc_Script::GetAssetQuantities(mc_Buffer *amounts,uint32_t script_type)
             
     ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
 
-    shift=MC_AST_SHORT_TXID_OFFSET;
-    ref_type=MC_AST_ASSET_REF_TYPE_SHORT_TXID;
+    shift=0;
+    ref_type=MC_AST_ASSET_REF_TYPE_REF;
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        shift=MC_AST_SHORT_TXID_OFFSET;
+        ref_type=MC_AST_ASSET_REF_TYPE_SHORT_TXID;
+    }
     
     items=(m_lpCoord[m_CurrentElement*2+1] - (MC_DCT_SCRIPT_IDENTIFIER_LEN+1)) / (mc_gState->m_NetworkParams->m_AssetRefSize + MC_AST_ASSET_QUANTITY_SIZE);
 
@@ -2050,7 +2019,11 @@ int mc_Script::SetAssetQuantities(mc_Buffer *amounts,uint32_t script_type)
         return err;
     }
 
-    shift=MC_AST_SHORT_TXID_OFFSET;
+    shift=0;
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        shift=MC_AST_SHORT_TXID_OFFSET;
+    }
     
     
     for(i=0;i<amounts->GetCount();i++)
@@ -2195,508 +2168,3 @@ int mc_Script::SetCachedScript(int offset, int *next_offset, int vin, unsigned c
     
     return MC_ERR_NOERROR;    
 }
-
-int mc_Script::GetRawData(unsigned char **data,int *size)
-{
-    unsigned char *ptr;
-    unsigned char *ptrEnd;
-    
-    if(data)
-    {
-        *data=NULL;
-    }
-        
-    if(m_CurrentElement<0)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    
-    if(m_lpCoord[m_CurrentElement*2+1] < MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    ptr=m_lpData+m_lpCoord[m_CurrentElement*2+0];
-    ptrEnd=ptr+m_lpCoord[m_CurrentElement*2+1];
-    
-    if(memcmp(ptr,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN) != 0)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    
-    if(ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN] != MC_DCT_SCRIPT_MULTICHAIN_RAW_DATA_PREFIX)
-    {
-        return MC_ERR_WRONG_SCRIPT;            
-    }
-    
-    ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-    
-    if(data)
-    {
-        *data=ptr;
-        *size=ptrEnd-ptr;
-    }
-    
-    return MC_ERR_NOERROR;        
-}
-
-int mc_Script::SetRawData(const unsigned char *data,const int size)
-{
-    int err;
-    unsigned char buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+1];
-    
-    err=AddElement();
-    if(err)
-    {
-        return err;
-    }
-    
-    memcpy(buf,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN);
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_RAW_DATA_PREFIX;        
-    
-    err=SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1);
-    if(err)
-    {
-        return err;
-    }
-
-    if(size)
-    {
-        err=SetData(data,size);
-        if(err)
-        {
-            return err;
-        }
-    }
-
-    return MC_ERR_NOERROR;        
-}
-
-int mc_Script::GetDataFormat(uint32_t *format)
-{
-    unsigned char *ptr;
-    unsigned char f;
-    
-    if(format)
-    {
-        *format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    }
-        
-    if(m_CurrentElement<0)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    
-    if(m_lpCoord[m_CurrentElement*2+1] < MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    ptr=m_lpData+m_lpCoord[m_CurrentElement*2+0];
-    
-    if(memcmp(ptr,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN) != 0)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    
-    if(ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN] != MC_DCT_SCRIPT_MULTICHAIN_DATA_FORMAT_PREFIX)
-    {
-        return MC_ERR_WRONG_SCRIPT;            
-    }
-    
-    ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-
-    f=(unsigned char)(*ptr);
-
-    if(f & MC_SCR_DATA_FORMAT_EXTENDED_MASK)
-    {
-        f=MC_SCR_DATA_FORMAT_UNKNOWN;
-    }
-    
-    if(format)
-    {
-        *format=(uint32_t)f;
-    }
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_Script::SetDataFormat(const uint32_t format)
-{
-    int err;
-    unsigned char buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1];
-    unsigned char f;
-    
-    f=(unsigned char)format;
-    if(f & MC_SCR_DATA_FORMAT_EXTENDED_MASK)
-    {
-        f=MC_SCR_DATA_FORMAT_UNKNOWN;        
-    }
-    
-    err=AddElement();
-    if(err)
-    {
-        return err;
-    }
-    
-    memcpy(buf,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN);
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_DATA_FORMAT_PREFIX;        
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+1]=f;
-    
-    err=SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1);
-    if(err)
-    {
-        return err;
-    }
-    
-    return MC_ERR_NOERROR;    
-}
-
-int mc_Script::GetChunkDef(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size,int check_sizes)
-{
-    unsigned char *ptr;
-    unsigned char *ptrEnd;
-    unsigned char f,s;
-    int c,count,shift,size;
-/*    
-    if(format)
-    {
-        *format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    }
-*/        
-    if(m_CurrentElement<0)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    
-    if(m_lpCoord[m_CurrentElement*2+1] < MC_DCT_SCRIPT_IDENTIFIER_LEN+1+1)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    ptr=m_lpData+m_lpCoord[m_CurrentElement*2+0];
-    ptrEnd=ptr+m_lpCoord[m_CurrentElement*2+1];
-    
-    if(memcmp(ptr,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN) != 0)
-    {
-        return MC_ERR_WRONG_SCRIPT;
-    }
-    
-    
-    if(ptr[MC_DCT_SCRIPT_IDENTIFIER_LEN] != MC_DCT_SCRIPT_MULTICHAIN_DATA_FORMAT_PREFIX)
-    {
-        return MC_ERR_WRONG_SCRIPT;            
-    }
-    
-    ptr+=MC_DCT_SCRIPT_IDENTIFIER_LEN+1;
-
-    f=(unsigned char)(*ptr);
-
-    if(f != MC_DCT_SCRIPT_EXTENDED_TYPE_CHUNK_DEF)
-    {
-        return MC_ERR_WRONG_SCRIPT;            
-    }
-    
-    ptr++;
-    
-    if(ptr+3 > ptrEnd)
-    {
-        return MC_ERR_ERROR_IN_SCRIPT;                                                            
-    }
-    
-    if(format)
-    {
-        *format=(uint32_t)(*ptr);
-    }   
-    
-    ptr++;
-
-    s=(uint32_t)(*ptr);
- 
-    if(s != 0)
-    {
-        return MC_ERR_ERROR_IN_SCRIPT;                                          // Salt length should be 0
-    }
-    
-    ptr++;
-    
-    count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-    
-    if(count<0)
-    {
-        return MC_ERR_ERROR_IN_SCRIPT;
-    }
-
-    ptr+=shift;
-
-    if(check_sizes)
-    {
-        if(count > MAX_CHUNK_COUNT)
-        {
-            return MC_ERR_ERROR_IN_SCRIPT;        
-        }
-    }
-    
-    if(chunk_count)
-    {
-        *chunk_count=count;
-    }
-    
-    if(hashes)
-    {
-        *hashes=ptr;
-    }
-    
-    if(total_size)
-    {
-        *total_size=0;
-    }
-    
-    for(c=0;c<count;c++)
-    {
-        size=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-
-        if(size<0)
-        {
-            return MC_ERR_ERROR_IN_SCRIPT;
-        }
-        
-        if(check_sizes)
-        {
-            if(size > MAX_CHUNK_SIZE)
-            {
-                return MC_ERR_ERROR_IN_SCRIPT;        
-            }
-        }
-        
-        ptr+=shift;
-        
-        if(ptr+MC_DCT_SCRIPT_CHUNK_HASH_SIZE>ptrEnd)
-        {
-            return MC_ERR_ERROR_IN_SCRIPT;                    
-        }
-        
-        ptr+=MC_DCT_SCRIPT_CHUNK_HASH_SIZE;
-        
-        if(total_size)
-        {
-            *total_size+=size;
-        }
-    }    
-    
-    return MC_ERR_NOERROR;    
-}
-
-int mc_Script::GetChunkDef(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size)
-{
-    return GetChunkDef(format,hashes,chunk_count,total_size,0);
-}
-
-int mc_Script::SetChunkDefHeader(const uint32_t format,int chunk_count)
-{
-    int err,shift;
-    unsigned char buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+14];
-    
-    err=AddElement();
-    if(err)
-    {
-        return err;
-    }
-    
-    memcpy(buf,MC_DCT_SCRIPT_MULTICHAIN_IDENTIFIER,MC_DCT_SCRIPT_IDENTIFIER_LEN);
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN]=MC_DCT_SCRIPT_MULTICHAIN_DATA_FORMAT_PREFIX;        
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+1]=MC_DCT_SCRIPT_EXTENDED_TYPE_CHUNK_DEF;
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+2]=(unsigned char)format;
-    buf[MC_DCT_SCRIPT_IDENTIFIER_LEN+3]=0;                                      // Salt length    
-    shift=mc_PutVarInt(buf+MC_DCT_SCRIPT_IDENTIFIER_LEN+4,11,chunk_count);
-    
-    err=SetData(buf,MC_DCT_SCRIPT_IDENTIFIER_LEN+4+shift);
-    if(err)
-    {
-        return err;
-    }
-
-    return MC_ERR_NOERROR;        
-}
-
-int mc_Script::SetChunkDefHash(unsigned char *hash,int size)
-{
-    int err,shift;
-    unsigned char buf[16];
-
-    shift=mc_PutVarInt(buf,16,size);
-    err=SetData(buf,shift);
-    if(err)
-    {
-        return err;
-    }
-
-    err=SetData(hash,MC_DCT_SCRIPT_CHUNK_HASH_SIZE);
-    if(err)
-    {
-        return err;
-    }
-    
-    return MC_ERR_NOERROR;            
-}
-
-
-int mc_Script::ExtractAndDeleteDataFormat(uint32_t *format)
-{
-    return ExtractAndDeleteDataFormat(format,NULL,NULL,NULL);
-}
-
-int mc_Script::ExtractAndDeleteDataFormat(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size,int check_sizes)
-{
-    int elem,err;
-
-    m_Restrictions=MC_ENT_ENTITY_RESTRICTION_NONE;
-    
-    if(format)
-    {
-        *format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    }
-
-    if(hashes)
-    {
-        *hashes=NULL;
-    }
-
-    if(mc_gState->m_Features->FormattedData() == 0)
-    {
-        return MC_ERR_NOERROR;
-    }
-    
-    if(m_NumElements >= 1)
-    {        
-        if(m_lpCoord[(m_NumElements-1)*2+1] > 0)
-        {
-            m_Restrictions |= MC_ENT_ENTITY_RESTRICTION_ONCHAIN;
-        }        
-    }
-    
-    if(m_NumElements < 2)
-    {        
-        return MC_ERR_NOERROR;
-    }
-        
-    
-    
-    elem=m_NumElements-2;
-        
-    SetElement(elem);
-    if( (err=GetDataFormat(format)) != MC_ERR_WRONG_SCRIPT  )
-    {
-        if( (mc_gState->m_Features->OffChainData() == 0) || (GetChunkDef(NULL,NULL,NULL,NULL) == MC_ERR_WRONG_SCRIPT) )
-        {
-            DeleteElement(elem);            
-        }
-        if(err)
-        {
-            return err;
-        }
-    }        
-    
-    if(mc_gState->m_Features->OffChainData() == 0)
-    {
-        return MC_ERR_NOERROR;
-    }
-    
-    if(m_NumElements < 2)
-    {        
-        return MC_ERR_NOERROR;
-    }
-        
-    elem=m_NumElements-2;
-    
-    SetElement(elem);
-    while( (elem >= 0 ) && ((err=GetChunkDef(format,hashes,chunk_count,total_size,check_sizes)) == MC_ERR_NOERROR) )
-    {
-        m_Restrictions |= MC_ENT_ENTITY_RESTRICTION_OFFCHAIN;
-        DeleteElement(elem);
-        elem--;
-        if(elem < 0)
-        {
-            err=MC_ERR_WRONG_SCRIPT;
-        }
-        else
-        {
-            SetElement(elem);            
-        }
-    }
-        
-    if(err != MC_ERR_WRONG_SCRIPT)
-    {
-        if(hashes)
-        {
-            *hashes=NULL;
-        }
-        if(chunk_count)
-        {
-            *chunk_count=0;
-        }
-        return err;            
-    }
-    
-    return MC_ERR_NOERROR;        
-}
-
-int mc_Script::ExtractAndDeleteDataFormat(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size)
-{
-    return ExtractAndDeleteDataFormat(format,hashes,chunk_count,total_size,0);
-}
-
-int mc_Script::DeleteDuplicatesInRange(int from,int to)
-{
-    int *len0,*len1,*len2,*len3,*len4;
-
-    len0=m_lpCoord+from*2+1;
-    len3=m_lpCoord+to*2+1;    
-    len4=m_lpCoord+m_NumElements*2+1;    
-    
-    len1=len3-2;    
-    while(len1>len0)
-    {
-        len2=len1-2;
-        while(len2 >= len0)
-        {
-            if(*len2 >= 0)
-            {
-                if(*len2 == *len1)
-                {
-                    if( (*len2==0) || (memcmp(m_lpData+*(len2-1),m_lpData+*(len1-1),*len2) == 0) )
-                    {
-                        *len1=-1;
-                        len2=len0;
-                    }
-                }
-            }
-            len2-=2;
-        }
-        len1-=2;
-    }
-    
-    len1=len0+2;
-    len2=len0+2;
-    
-    while(len2<len4)
-    {
-        if(*len2 >= 0)
-        {
-            if(len1 != len2)
-            {
-                *len1=*len2;
-                *(len1-1)=*(len2-1);
-            }
-            len1+=2;
-        }
-        len2+=2;
-    }
-    
-    m_NumElements-=(len2-len1)/2;
-    m_CurrentElement=-1;
-    
-   return MC_ERR_NOERROR;
- }
\ No newline at end of file
diff --git a/src/protocol/multichainscript.h b/src/protocol/multichainscript.h
index 9bd4808..b765f7c 100644
--- a/src/protocol/multichainscript.h
+++ b/src/protocol/multichainscript.h
@@ -13,11 +13,6 @@
 #define MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER              0x00000001
 #define MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON              0x00000002
 
-#define MC_SCR_DATA_FORMAT_UNKNOWN                 0x00 
-#define MC_SCR_DATA_FORMAT_UTF8                    0x01 
-#define MC_SCR_DATA_FORMAT_UBJSON                  0x02 
-#define MC_SCR_DATA_FORMAT_EXTENDED_MASK           0x80 
-
 
 typedef struct mc_Script
 {    
@@ -29,7 +24,6 @@ typedef struct mc_Script
     int m_AllocElements;
     int m_AllocSize;
     int m_ScriptType;
-    uint32_t m_Restrictions;
     
     mc_Script()
     {
@@ -52,7 +46,6 @@ typedef struct mc_Script
     
     int GetNumElements();
     int AddElement();
-    int DeleteElement(int element);
     int SetSpecialParamValue(unsigned char param,const unsigned char* param_value,const size_t param_value_size);
     int SetParamValue(const char *param_name,const size_t param_name_size,const unsigned char* param_value,const size_t param_value_size);
     size_t GetParamValue(const unsigned char *ptr,size_t total,size_t offset,size_t* param_value_start,size_t *bytes);
@@ -99,23 +92,6 @@ typedef struct mc_Script
     
     int GetCachedScript(int offset, int *next_offset, int* vin, unsigned char** script, int *script_size);
     int SetCachedScript(int offset, int *next_offset, int vin, unsigned char* script, int script_size);
-
-    int GetRawData(unsigned char **data,int *size);
-    int SetRawData(const unsigned char *data,const int size);
-    
-    int GetDataFormat(uint32_t *format);
-    int SetDataFormat(const uint32_t format);
-    
-    int GetChunkDef(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size);
-    int GetChunkDef(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size,int check_sizes);
-    int SetChunkDefHeader(const uint32_t format,int chunk_count);
-    int SetChunkDefHash(unsigned char *hash,int size);
-    
-    int ExtractAndDeleteDataFormat(uint32_t *format);
-    int ExtractAndDeleteDataFormat(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size);
-    int ExtractAndDeleteDataFormat(uint32_t *format,unsigned char** hashes,int *chunk_count,int64_t *total_size,int check_sizes);
-    int DeleteDuplicatesInRange(int from,int to);
-    
     
 } mc_Script;
 
diff --git a/src/protocol/multichaintx.cpp b/src/protocol/multichaintx.cpp
index 705169e..be07360 100644
--- a/src/protocol/multichaintx.cpp
+++ b/src/protocol/multichaintx.cpp
@@ -6,113 +6,12 @@
 
 #include "core/main.h"
 #include "utils/util.h"
-#include "utils/utilparse.h"
 #include "multichain/multichain.h"
 #include "structs/base58.h"
-#include "custom/custom.h"
 
 using namespace std;
 
 string EncodeHexTx(const CTransaction& tx);
-bool ExtractDestinations10008(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet, bool no_clear, bool *not_cleared);
-
-#define MC_MTX_OUTPUT_DETAIL_FLAG_NONE                   0x00000000                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_OP_RETURN_ENTITY_ITEM  0x00000001                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_CREATE      0x00000002                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_ADMIN       0x00000004                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_NOT_PURE_PERMISSION    0x00000008                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_NOT_OP_RETURN          0x00000010                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_FOLLOWON_DETAILS       0x00000020                              
-#define MC_MTX_OUTPUT_DETAIL_FLAG_NO_DESTINATION         0x00000040                              
-
-typedef struct CMultiChainTxDetails
-{    
-    bool fCheckCachedScript;                                                    // If tx contains admin/miner grants, it should have cached input script
-    bool fScriptHashAllFound;                                                   // Input script with SIGHASH_ALL found, OP_RETURN metadata data can be transferred in this tx
-    bool fRejectIfOpDropOpReturn;                                               // Tx should be rejected of OP_DROP+OP_RETURN script is found
-    bool fSeedNodeInvolved;                                                     // Connect permission of seed node changed
-    bool fFullReplayCheckRequired;                                              // Tx should be rechecked when mempool is replayed
-    bool fAdminMinerGrant;                                                      // Admin/miner grant in this transaction
-    
-    vector <txnouttype> vInputScriptTypes;                                      // Input script types
-    vector <uint160> vInputDestinations;                                        // Addresses used in input scripts
-    vector <int> vInputHashTypes;                                               // Input hash types
-    vector <bool> vInputCanGrantAdminMine;                                      // Flags - input can be used as signer for admin/mine grants
-    vector <bool> vInputHadAdminPermissionBeforeThisTx;                         // Admin permissions before this tx - for approval
-    
-    set <string> vAllowedAdmins;                                                // Admin permissions before this tx - for grants
-    set <string> vAllowedActivators;                                            // Activate permissions before this tx - for grants
-    
-    vector <uint32_t> vOutputScriptFlags;                                       // Output script flags, filled when script is processed for the first time
-    vector <int> vOutputPermissionRequired;                                     // Number of required receive permissions 
-    vector < vector<CTxDestination> > vOutputDestinations;                      // Output destinations
-    vector < CTxDestination > vOutputSingleDestination;                         // Single destination for setting permission
-    
-
-    unsigned char details_script[MC_ENT_MAX_SCRIPT_SIZE];                       // Entity details script
-    int details_script_size;                                                    // Entity details script size
-    int details_script_type;                                                    // Entity details script type - new/update
-    uint32_t new_entity_type;                                                   // New entity type
-    int new_entity_output;                                                      // Output where new entity is defined
-    int64_t total_offchain_size;                                                // Total size of offchain items
-    int64_t total_value_in;                                                     // Total amount in inputs
-    int64_t total_value_out;                                                    // Total amount in outputs
-    
-    CMultiChainTxDetails()
-    {
-        Zero();
-    }
-    
-    ~CMultiChainTxDetails()
-    {
-        
-    }
-    
-    void Zero();
-    bool IsRelevantInput(int vin,int vout);
-    
-} CMultiChainTxDetails;
-
-void CMultiChainTxDetails::Zero()
-{
-    vInputScriptTypes.clear();
-    vInputDestinations.clear();
-    vInputHashTypes.clear();
-    vInputCanGrantAdminMine.clear();
-    vInputHadAdminPermissionBeforeThisTx.clear();
-    
-    vAllowedAdmins.clear();
-    vAllowedActivators.clear();
-    
-    vOutputScriptFlags.clear();
-    vOutputPermissionRequired.clear();
-    vOutputDestinations.clear();
-    vOutputSingleDestination.clear();
-    
-    fCheckCachedScript=false;
-    fScriptHashAllFound=false;
-    fRejectIfOpDropOpReturn=false;
-    fSeedNodeInvolved=false;
-    fFullReplayCheckRequired=false;
-    fAdminMinerGrant=false;
-
-    details_script_size=0;
-    details_script_type=-1;
-    new_entity_type=MC_ENT_TYPE_NONE;
-    new_entity_output=-1;
-    total_offchain_size=0;
-    total_value_in=0;
-    total_value_out=0;
-}
-
-bool CMultiChainTxDetails::IsRelevantInput(int vin, int vout)
-{
-    if( (vInputHashTypes[vin] == SIGHASH_ALL) || ( (vInputHashTypes[vin] == SIGHASH_SINGLE) && ((vin == vout) ) ) )
-    {
-        return true;
-    }
-    return false;
-}
 
 uint160 mc_GenesisAdmin(const CTransaction& tx)
 {
@@ -148,7 +47,7 @@ uint160 mc_GenesisAdmin(const CTransaction& tx)
     return 0;
 }
 
-bool mc_ExtractInputAssetQuantities(mc_Buffer *assets, const CScript& script1, uint256 hash, string& reason)
+bool mc_ExtractInputAssetQuantities(const CScript& script1, uint256 hash, string& reason)
 {
     int err;
     int64_t quantity;
@@ -160,7 +59,7 @@ bool mc_ExtractInputAssetQuantities(mc_Buffer *assets, const CScript& script1, u
     for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
     {
         mc_gState->m_TmpScript->SetElement(e);
-        err=mc_gState->m_TmpScript->GetAssetQuantities(assets,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER | MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);
+        err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsIn,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER | MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);
         if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
         {
             reason="Asset transfer script rejected - error in script";
@@ -174,18 +73,26 @@ bool mc_ExtractInputAssetQuantities(mc_Buffer *assets, const CScript& script1, u
             memset(buf_amounts,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
             if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&hash))
             {
+                if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+                {
+                    if(entity.IsUnconfirmedGenesis())             // Not confirmed genesis has -1 in offset field
+                    {
+                        reason="Asset transfer script rejected - using unconfirmed issue";
+                        return false;                                
+                    }
+                }
                 memcpy(buf_amounts,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
-                int row=assets->Seek(buf_amounts);
+                int row=mc_gState->m_TmpAssetsIn->Seek(buf_amounts);
                 if(row>=0)
                 {
-                    int64_t last=mc_GetABQuantity(assets->GetRow(row));
+                    int64_t last=mc_GetABQuantity(mc_gState->m_TmpAssetsIn->GetRow(row));
                     quantity+=last;
-                    mc_SetABQuantity(assets->GetRow(row),quantity);                        
+                    mc_SetABQuantity(mc_gState->m_TmpAssetsIn->GetRow(row),quantity);                        
                 }
                 else
                 {
                     mc_SetABQuantity(buf_amounts,quantity);
-                    assets->Add(buf_amounts);
+                    mc_gState->m_TmpAssetsIn->Add(buf_amounts);
                 }
             }                
             else
@@ -207,6 +114,23 @@ bool mc_ExtractInputAssetQuantities(mc_Buffer *assets, const CScript& script1, u
     return true;
 }
 
+bool mc_ExtractOutputAssetQuantities(string& reason)
+{
+    int err;
+    for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
+    {
+        mc_gState->m_TmpScript->SetElement(e);
+        err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsOut,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER);
+        if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
+        {
+            reason="Asset transfer script rejected - error in output transfer script";
+            return false;                                
+        }
+    }
+
+    return true;
+}
+
 bool mc_CompareAssetQuantities(string& reason)
 {
     unsigned char *ptrIn;
@@ -244,11 +168,14 @@ bool mc_CompareAssetQuantities(string& reason)
         int row=mc_gState->m_TmpAssetsIn->Seek(ptrOut);
         quantity=mc_GetABQuantity(ptrOut);
 
-        if(mc_gState->m_Assets->FindEntityByFullRef(&entity,ptrOut) == 0)
+        if(mc_gState->m_Features->ShortTxIDInTx())
         {
-            reason="Asset transfer script rejected - asset not found";
-            return false;                                                    
-        }                           
+            if(mc_gState->m_Assets->FindEntityByFullRef(&entity,ptrOut) == 0)
+            {
+                reason="Asset transfer script rejected - asset not found";
+                return false;                                                    
+            }                           
+        }
         
         if(quantity>0)
         {
@@ -272,1164 +199,2238 @@ bool mc_CompareAssetQuantities(string& reason)
     return true;
 }
 
-void MultiChainTransaction_SetTmpOutputScript(const CScript& script1)
-{
-    CScript::const_iterator pc1 = script1.begin();
-    mc_gState->m_TmpScript->Clear();
-    mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-}
-
-bool MultiChainTransaction_CheckCachedScriptFlag(const CTransaction& tx)
-{
-    bool flag=false;
-    if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+bool AcceptAssetGenesisFromPredefinedIssuers(const CTransaction &tx,
+                                            int offset,bool accept,
+                                            vector <uint160> vInputDestinations,
+                                            vector <int> vInputHashTypes,
+                                            vector <txnouttype> vInputScriptTypes,
+                                            bool fReturnFalseIfFound,
+                                            string& reason,
+                                            bool *fFullReplayCheckRequired)
+{    
+    int update_mempool=0;
+    mc_EntityDetails entity;
+    mc_EntityDetails this_entity;
+    unsigned char details_script[MC_ENT_MAX_SCRIPT_SIZE];
+    char asset_name[MC_ENT_MAX_NAME_SIZE+1];
+    int multiple;
+    int details_script_size;
+    int err;
+    int64_t quantity,total;
+    uint256 txid;
+    bool new_issue,follow_on;
+    int details_script_type;
+    unsigned char *ptrOut;
+    vector <uint160> issuers;
+    vector <uint32_t> issuer_flags;
+    uint32_t flags;
+    uint32_t value_offset;
+    size_t value_size;
+    unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
+    
+        
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
     {
-        flag=true;
-    }        
+        return true;
+    }    
     if(tx.IsCoinBase())
     {
-        flag=false;
+        return true;
     }
-    return flag;
-}
-
-bool MultiChainTransaction_CheckCoinbaseInputs(const CTransaction& tx,     
-                                               CMultiChainTxDetails *details)
-{
-    if(!tx.IsCoinBase())                                                  
-    {   
-        return false;
-    }    
     
-    if(mc_gState->m_Permissions->m_Block == -1)                     
-    {                    
-        details->vInputScriptTypes.push_back(TX_PUBKEYHASH);
-        details->vInputDestinations.push_back(mc_GenesisAdmin(tx));             // Genesis admin is considered to be admin/opener of everything in genesis coinbase        
-    }
-    else
+    if(accept)
     {
-        details->vInputScriptTypes.push_back(TX_NONSTANDARD);
-        details->vInputDestinations.push_back(0);                               // Invalid signer, but we have to fill arrays for the input
+        update_mempool=1;
     }
-
-    details->fScriptHashAllFound=true;                              
-    details->vInputHashTypes.push_back(SIGHASH_ALL);                         
-    details->vInputCanGrantAdminMine.push_back(!details->fCheckCachedScript);            
-
-    return true;
-}
-
-
-bool MultiChainTransaction_CheckInputs(const CTransaction& tx,                  // Tx to check
-                                       const CCoinsViewCache &inputs,           // Tx inputs from UTXO database
-                                       CMultiChainTxDetails *details,           // Tx details object
-                                       string& reason)                          // Error message
+    
+    total=0;
+    
+    asset_name[0]=0;
+    multiple=1;
+    new_issue=false;
+    follow_on=false;
+    details_script_type=-1;
+    mc_gState->m_TmpAssetsOut->Clear();
+    
+    details_script_size=0;
+    for (unsigned int j = 0; j < tx.vout.size(); j++)
+    {
+        mc_gState->m_TmpScript->Clear();
         
-{
-    for (unsigned int i = 0; i < tx.vin.size(); i++)                            
-    {                                                                                                                                                                
-        const CScript& script2 = tx.vin[i].scriptSig;        
-        CScript::const_iterator pc2 = script2.begin();
-        if (!script2.IsPushOnly())
-        {
-            reason="sigScript should be push-only";
-            return false;
-        }
-
-        const COutPoint &prevout = tx.vin[i].prevout;
-        const CCoins *coins = inputs.AccessCoins(prevout.hash);
-        assert(coins);
-
-        const CScript& script1 = coins->vout[prevout.n].scriptPubKey;        
+        const CScript& script1 = tx.vout[j].scriptPubKey;        
         CScript::const_iterator pc1 = script1.begin();
-
-        details->total_value_in+=coins->vout[prevout.n].nValue;
+        uint32_t new_entity_type;
+        int entity_update;
         
-        txnouttype typeRet;
-        int nRequiredRet;
-        vector<CTxDestination> addressRets;
-        int op_addr_offset,op_addr_size,is_redeem_script,sighash_type,check_last;
-
-        sighash_type=SIGHASH_NONE;
-        if(ExtractDestinations(script1,typeRet,addressRets,nRequiredRet))       // Standard script
+        CTxDestination addressRet;
+        
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+        
+        if(mc_gState->m_TmpScript->IsOpReturnScript())
         {
-            if (typeRet != TX_NULL_DATA)                                        // Regular script
+            if(mc_gState->m_Features->OpDropDetailsScripts())
             {
-                CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
-                CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
-                if( (lpKeyID == NULL) && (lpScriptID == NULL) )
+                if(mc_gState->m_TmpScript->GetNumElements() == 2 )              // One OP_DROP + OP_RETRUN - new entity
                 {
-                    reason="Internal error: cannot extract address from input scriptPubKey";
-                    return false;
-                }
-                else
-                {
-                    if(typeRet != TX_MULTISIG)
+                    mc_gState->m_TmpScript->SetElement(0);
+                    err=mc_gState->m_TmpScript->GetNewEntityType(&new_entity_type,&entity_update,details_script,&details_script_size);
+                    if(err == 0)                                                // New entity element
                     {
-                        if(lpKeyID)
-                        {
-                            details->vInputDestinations.push_back(*(uint160*)lpKeyID);                               
-                        }
-                        if(lpScriptID)
+                        if(new_entity_type == MC_ENT_TYPE_ASSET)
                         {
-                            details->vInputDestinations.push_back(*(uint160*)lpScriptID);                               
+                            if(details_script_type >= 0)
+                            {
+                                reason="Metadata script rejected - too many new entities";
+                                return false;                                    
+                            }
+                            if(entity_update == 0)
+                            {
+                                details_script_type=entity_update;
+                                *asset_name=0x00;
+                                multiple=1;
+                                value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_NAME,&value_size);
+                                							
+                                if(value_offset<(uint32_t)details_script_size)
+                                {
+                                    if(value_size > MC_ENT_MAX_NAME_SIZE)
+                                    {
+                                        if(mc_gState->m_Features->FixedIn1001120003())
+                                        {
+                                            reason="Metadata script rejected - entity name too long";
+                                            return false;                    
+                                        }
+
+                                        value_size=MC_ENT_MAX_NAME_SIZE;
+                                    }
+
+                                    memcpy(asset_name,details_script+value_offset,value_size);
+                                    asset_name[value_size]=0x00;
+                                }
+                                value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size);
+                                if(value_offset<(uint32_t)details_script_size)
+                                {
+                                    multiple=mc_GetLE(details_script+value_offset,value_size);
+                                }                            
+                            }
                         }
                     }
                     else
                     {
-                        details->vInputDestinations.push_back(0);               // Multisig scripts cannot be used for signing tx objects - issues, stream items, etc.
+                        if(err != MC_ERR_WRONG_SCRIPT)
+                        {
+                            reason="Asset details script rejected - error in script";
+                            return false;                                    
+                        }
                     }
+                        
                 }
-
-                check_last=0;
-                if( (typeRet == TX_PUBKEY) || (typeRet == TX_MULTISIG) )
-                {
-                    check_last=1;
-                    details->fRejectIfOpDropOpReturn=true;                      // pay-to-pubkey and bare multisig  scripts cannot be considered "publisher" for the stream, 
-                                                                                // because we cannot extract publisher address from the input script itself. 
-                                                                                // Though we can still accept this transaction, it is rejected for consistency with principle
-                                                                                // "each input which signs the stream item must have permitted writer"
-                }
-
-                                                                                // Find sighash_type
-                mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,check_last);        
-                if(sighash_type == SIGHASH_ALL)
-                {
-                    details->fScriptHashAllFound=true;
-                }
-                if(sighash_type == SIGHASH_SINGLE)
+                if(mc_gState->m_TmpScript->GetNumElements())                    // 2 OP_DROPs + OP_RETURN - entity update
                 {
-                    if(i >= tx.vout.size())
+                    mc_gState->m_TmpScript->SetElement(1);
+                    err=mc_gState->m_TmpScript->GetNewEntityType(&new_entity_type,&entity_update,details_script,&details_script_size);
+                    if(err == 0)    // New entity element
                     {
-                        reason="SIGHASH_SINGLE input without matching output";
-                        return false;                                
-                    }
-                }                    
-            }
-            else                                                                // Null-data script
-            {
-                details->fRejectIfOpDropOpReturn=true;                          // Null data scripts cannot be used in txs with OP_DROP+OP_RETURN
-                                                                                // We should not be there at all 
-                details->vInputDestinations.push_back(0);       
-            }            
-            details->vInputScriptTypes.push_back(typeRet);
-        }
-        else                                                                    // Non-standard script        
-        {
-            details->fRejectIfOpDropOpReturn=true;                              // Non-standard inputs cannot be used in txs with OP_DROP+OP_RETURN
-                                                                                // We cannot be sure where are the signatures in input script
-            details->vInputScriptTypes.push_back(TX_NONSTANDARD);
-            details->vInputDestinations.push_back(0);                                
-        }            
-
-        details->vInputHashTypes.push_back(sighash_type);        
-
-        if(mc_gState->m_Features->PerAssetPermissions())                        // Checking per-asset send permissions
-        {
-            mc_gState->m_TmpAssetsTmp->Clear();
-            if(!mc_ExtractInputAssetQuantities(mc_gState->m_TmpAssetsTmp,script1,prevout.hash,reason))    
-            {
-                return false;
+                        if(entity_update == 0)
+                        {
+                            reason="Metadata script rejected - wrong element, should be entity update";
+                            return false;                                    
+                        }
+                        if(details_script_type >= 0)
+                        {
+                            reason="Metadata script rejected - too many new new entities/entity updates";
+                            return false;                                    
+                        }
+                        if(new_entity_type == MC_ENT_TYPE_ASSET)
+                        {
+                            details_script_type=entity_update;
+                            mc_gState->m_TmpScript->SetElement(0);
+                                                                                // Should be spke
+                            if(mc_gState->m_TmpScript->GetEntity(short_txid))   // Entity element
+                            {
+                                reason="Metadata script rejected - wrong element, should be entityref";
+                                return false;                                    
+                            }
+                            if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
+                            {
+                                reason="Metadata script rejected - entity not found";
+                                return false;                                    
+                            }                                           
+                        }
+                        else
+                        {
+                            reason="Metadata script rejected - wrong entity type, should be asset";
+                            return false;                                                                
+                        }
+                    }                              
+                }                
             }
-            if(!mc_VerifyAssetPermissions(mc_gState->m_TmpAssetsTmp,addressRets,1,MC_PTP_SEND,reason))
+            else
             {
-                return false;                                
+                if(details_script_size == 0)
+                {
+                    int e=mc_gState->m_TmpScript->GetNumElements()-1;
+                    if(e == 0)
+                    {
+                        mc_gState->m_TmpScript->SetElement(e);
+                        err=mc_gState->m_TmpScript->GetAssetDetails(asset_name,&multiple,details_script,&details_script_size);
+                        if(err)
+                        {
+                            if(err != MC_ERR_WRONG_SCRIPT)
+                            {
+                                reason="Asset details script rejected - error in script";
+                                return false;                                    
+                            }
+                            details_script_size=0;
+                        }
+                    }
+                }
             }
         }
-
-                                                                                // Filling input asset quantity list
-        if(!mc_ExtractInputAssetQuantities(mc_gState->m_TmpAssetsIn,script1,prevout.hash,reason))   
-        {
-            return false;
-        }                
-       
-                                                                                // Initialization, input cannot be used as signer for admin/miner grant
-        details->vInputCanGrantAdminMine.push_back(!details->fCheckCachedScript);            
-    }    
-
-    return true;
-}
-
-bool MultiChainTransaction_CheckNewEntity(int vout,
-                                          bool& fScriptParsed,
-                                          CMultiChainTxDetails *details,   
-                                          string& reason)      
-{
-    int err;
-    int entity_update;
-    
-    mc_gState->m_TmpScript->SetElement(0);
-    err=mc_gState->m_TmpScript->GetNewEntityType(&(details->new_entity_type),&entity_update,details->details_script,&(details->details_script_size));
-    if(err == 0)    
-    {
-        fScriptParsed=true;
-        if(details->new_entity_output >= 0)
-        {
-            reason="Metadata script rejected - too many new entities";
-            return false;
-       }
-        if(entity_update)
-        {
-            reason="Metadata script rejected - entity update script should be preceded by entityref";
-            return false;
-        }
-        if(details->new_entity_type <= mc_gState->m_Assets->MaxEntityType())
-        {
-            details->new_entity_output=vout;                                    
-            details->details_script_type=entity_update;
-        }
         else
         {
-            reason="Metadata script rejected - unsupported new entity type";
-            return false;            
-        }
-    }   
-    else
-    {
-        if(err != MC_ERR_WRONG_SCRIPT)
-        {
-            reason="Entity details script rejected - error in script";
-            return false;            
-        }
-    }
-    
-    return true;
-}
-
-bool MultiChainTransaction_CheckCachedScript(const CTransaction& tx, 
-                                             const CCoinsViewCache &inputs,   
-                                             bool& fScriptParsed,
-                                             CMultiChainTxDetails *details,   
-                                             string& reason)      
-{
-    int err;
-    int cs_offset,cs_new_offset,cs_size,cs_vin;
-    unsigned char *cs_script;
-    
-    mc_gState->m_TmpScript->SetElement(0);
-    cs_offset=0;
-    while( (err=mc_gState->m_TmpScript->GetCachedScript(cs_offset,&cs_new_offset,&cs_vin,&cs_script,&cs_size)) != MC_ERR_WRONG_SCRIPT )
-    {
-        fScriptParsed=true;
-        if(err != MC_ERR_NOERROR)
-        {
-            reason="Metadata script rejected - error in cached script";
-            return false;
-        }
-        if(cs_offset)
-        {
-            if( cs_vin >= (int)tx.vin.size() )
-            {
-                reason="Metadata script rejected - invalid input in cached script";
-                return false;
-            }
-
-            const COutPoint &prevout = tx.vin[cs_vin].prevout;
-            const CCoins *coins = inputs.AccessCoins(prevout.hash);
-
-            const CScript& script3 = coins->vout[prevout.n].scriptPubKey;        
-            CScript::const_iterator pc3 = script3.begin();
-
-            if(cs_size != (int)script3.size())
-            {
-                reason="Metadata script rejected - cached script mismatch";
-                return false;
-            }
-            if(memcmp(cs_script,(unsigned char*)&pc3[0],cs_size))
-            {
-                reason="Metadata script rejected - cached script mismatch";
-                return false;
-            }
-            if(details->fCheckCachedScript)
+            for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
             {
-                if(details->vInputHashTypes[cs_vin] == SIGHASH_ALL)
+                mc_gState->m_TmpScript->SetElement(e);
+                err=mc_gState->m_TmpScript->GetAssetGenesis(&quantity);
+                if(err == 0)
                 {
-                    details->vInputCanGrantAdminMine[cs_vin]=true;
-                }
-            }
-        }
-        cs_offset=cs_new_offset;
-    }    
-    
-    return true;
-}
+                    new_issue=true;
+                    if(quantity+total<0)
+                    {
+                        reason="Asset issue script rejected - overflow";
+                        return false;                                        
+                    }
+                                        
+                    total+=quantity;
+                    
+                    if(!ExtractDestination(script1, addressRet))
+                    {
+                        reason="Asset issue script rejected - wrong destination type";
+                        return false;                
+                    }
+                    
+                    CKeyID *lpKeyID=boost::get<CKeyID> (&addressRet);
+                    CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
+                    if((lpKeyID == NULL) && (lpScriptID == NULL))
+                    {
+                        reason="Asset issue script rejected - wrong destination type";
+                        return false;                
+                    }
+                    CBitcoinAddress address;
+                    if(lpKeyID != NULL)
+                    {
+                        address=CBitcoinAddress(*lpKeyID);
+                    }
+                    else
+                    {
+                        address=CBitcoinAddress(*lpScriptID);
+                    }
+                    if(update_mempool)
+                    {
+                        if(fDebug)LogPrint("mchn","Found asset issue script in tx %s for %s - (%ld)\n",
+                                tx.GetHash().GetHex().c_str(),
+                                address.ToString().c_str(),quantity);                    
+                    }
+                }            
+                else
+                {
+                    if(err != MC_ERR_WRONG_SCRIPT)
+                    {
+                        reason="Asset issue script rejected - error in script";
+                        return false;                                    
+                    }
+                    err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsOut,MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);
+                    if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
+                    {
+                        reason="Asset follow-on script rejected - error in follow-on script";
+                        return false;                                
+                    }
+                    if(err == MC_ERR_NOERROR)
+                    {
+                        if(update_mempool)
+                        {
+                            if(fDebug)LogPrint("mchn","Found asset follow-on script in tx %s\n",
+                                    tx.GetHash().GetHex().c_str());                    
+                        }
+                    }
+                }                
+            }        
+        }
+    }    
 
-void MultiChainTransaction_FillAdminPermissionsBeforeTx(const CTransaction& tx,
-                                                        CMultiChainTxDetails *details)      
-{
-    if(details->vInputHadAdminPermissionBeforeThisTx.size() == 0)
+    if(details_script_type >= 0)
     {
-        for (unsigned int i = 0; i < tx.vin.size(); i++)
+        if(details_script_type)
         {
-            details->vInputHadAdminPermissionBeforeThisTx.push_back(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&(details->vInputDestinations[i])) != 0);
-        }                                
+            follow_on=true;            
+        }
+        else
+        {
+            new_issue=true;
+        }
     }
-}
-
-bool MultiChainTransaction_VerifyAndDeleteDataFormatElements(string& reason,int64_t *total_size)
-{
-    if(mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(NULL,NULL,NULL,total_size,1))
+    
+    if(mc_gState->m_TmpAssetsOut->GetCount())
     {
-        reason="Error in data format script";
-        return false;                    
-    }
-
-    return true;        
-}
-
-bool MultiChainTransaction_CheckOpReturnScript(const CTransaction& tx, 
-                                               const CCoinsViewCache &inputs,   
-                                               int vout,
-                                               CMultiChainTxDetails *details,   
-                                               string& reason)      
-{
-    bool fScriptParsed=false;
-    uint32_t timestamp,approval;
-    vector<CTxDestination> addressRets;
-    CTxDestination single_address;
-    int64_t total_offchain_size;
+        follow_on=true;
+    }   
     
-    total_offchain_size=0;
-    if(!MultiChainTransaction_VerifyAndDeleteDataFormatElements(reason,&total_offchain_size))
+    if(follow_on)
     {
-        return false;
+        total=0;
+        if(mc_gState->m_TmpAssetsOut->GetCount() > 1)
+        {
+            reason="Asset follow-on script rejected - follow-on for several assets";
+            return false;                                                
+        }
+        if(new_issue)
+        {
+            reason="Asset follow-on script rejected - follow-on and issue in one transaction";
+            return false;                                                            
+        }
+        ptrOut=NULL;
+        if(mc_gState->m_TmpAssetsOut->GetCount() == 0)
+        {
+            if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
+            {
+                reason="Details script rejected - entity not found";
+                return false;                                    
+            }                                           
+        }
+        else
+        {
+            ptrOut=mc_gState->m_TmpAssetsOut->GetRow(0);       
+            if(mc_gState->m_Assets->FindEntityByFullRef(&entity,ptrOut) == 0)
+            {
+                reason="Asset follow-on script rejected - asset not found";
+                return false;                                                                        
+            }            
+        }
+        if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+        {
+            if(entity.IsUnconfirmedGenesis())
+            {
+                reason="Asset follow-on script rejected - unconfirmed asset";
+                return false;                                                                                        
+            }
+        }
+        if(entity.AllowedFollowOns() == 0)
+        {
+            reason="Asset follow-on script rejected - follow-ons not allowed for this asset";
+            return false;                                                                                    
+        }
+        if(details_script_type >= 0)
+        {
+            if(memcmp(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,short_txid,MC_AST_SHORT_TXID_SIZE))
+            {
+                reason="Asset follow-on script rejected - mismatch in follow-on quantity asset and details script";
+                return false;                                                                                                    
+            }
+        }
+        if(ptrOut)
+        {
+            total=mc_GetABQuantity(ptrOut);
+            if(total+mc_gState->m_Assets->GetTotalQuantity(&entity) < 0)
+            {
+                reason="Asset follow-on script rejected - exceeds maximal value for asset";
+                return false;                                                                                                                
+            }
+        }
     }
-    details->total_offchain_size+=total_offchain_size;
     
-    if(!details->fScriptHashAllFound)             
+    if(!new_issue && !follow_on)
     {
-                                                                                // SIGHASH_NONE or not signed at all
-        if( ((int)details->vInputHashTypes.size() <= vout) || (details->vInputHashTypes[vout] != SIGHASH_SINGLE) )
-        {
-            reason="Output with metadata should be properly signed";
-            return false;
-        }                        
+        return true;
     }
-
-    if( mc_gState->m_TmpScript->GetNumElements() > 1 )                          // OP_DROP+OP_RETURN script
+    
+    if(fReturnFalseIfFound)
     {
-        if(details->fRejectIfOpDropOpReturn)                                    // We cannot extract address sighash_type properly from the input script 
-                                                                                // as we don't know where are the signatures
-        {
-            reason="Non-standard, P2PK or bare multisig inputs cannot be used in this tx";
-            return false;
-        }
-
-        if(mc_gState->m_TmpScript->IsDirtyOpReturnScript())
         {
-            reason="Non-standard, Only OP_DROP elements are allowed in metadata outputs with OP_DROP";
-            return false;
+            reason="Asset issue script rejected - not allowed in this transaction, conflicts with other entities";
+            return false;                                                                                            
         }
     }
     
-    if( mc_gState->m_TmpScript->GetNumElements() == 2 )                         // Cached input script or new entity
+    *fFullReplayCheckRequired=true;
+    
+    issuers.clear();
+    if(vInputDestinations.size())
     {
-        if(!fScriptParsed)
+        for (unsigned int i = 0; i < tx.vin.size(); i++)
         {
-                                                                                // Cached scripts
-            if(!MultiChainTransaction_CheckCachedScript(tx, inputs, fScriptParsed, details, reason))
+            if(vInputHashTypes[i] == SIGHASH_ALL)
             {
-                return false;
+                if(vInputDestinations[i] != 0)
+                {
+                    bool can_issue=false;
+                    if(new_issue)
+                    {
+                        if(mc_gState->m_Permissions->CanIssue(NULL,(unsigned char*)&vInputDestinations[i]))
+                        {                            
+                            can_issue=true;
+                        }                            
+                    }
+                    else
+                    {
+                        if(mc_gState->m_Permissions->CanIssue(entity.GetTxID(),(unsigned char*)&vInputDestinations[i]))
+                        {
+                            can_issue=true;
+                        }                                                        
+                    }                
+                    if(can_issue)
+                    {
+                        issuers.push_back(vInputDestinations[i]);
+                        flags=MC_PFL_NONE;
+                        if(vInputScriptTypes[i] == TX_SCRIPTHASH)
+                        {
+                            flags |= MC_PFL_IS_SCRIPTHASH;
+                        }
+                        issuer_flags.push_back(flags);                        
+                    }
+                }
             }
-        }
+        }        
+    }
+    else
+    {        
+        for (unsigned int i = 0; i < tx.vin.size(); i++)
+        {
+            const CScript& script2 = tx.vin[i].scriptSig;        
+            CScript::const_iterator pc2 = script2.begin();
+
+            mc_gState->m_TmpScript->Clear();
+            mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTSIG);
+
+            if(mc_gState->m_TmpScript->GetNumElements() == 2)
+            {
+                size_t elem_size;
+                const unsigned char *elem;
+
+                elem = mc_gState->m_TmpScript->GetData(0,&elem_size);
+
+                if(elem_size > 1)                                               // If this is multisig with one signature it should be OP_0
+                {
+                    unsigned char hash_type=elem[elem_size-1] & 0x1f;
+
+                    if(hash_type == SIGHASH_ALL)
+                    {
+                        elem = mc_gState->m_TmpScript->GetData(1,&elem_size);
+                        const unsigned char *pubkey_hash=(unsigned char *)Hash160(elem,elem+elem_size).begin();
+
+                        if(new_issue)
+                        {
+                            if(mc_gState->m_Permissions->CanIssue(NULL,pubkey_hash))
+                            {                            
+                                issuers.push_back(Hash160(elem,elem+elem_size));
+                            }                            
+                        }
+                        else
+                        {
+                            if(mc_gState->m_Permissions->CanIssue(entity.GetTxID(),pubkey_hash))
+                            {
+                                issuers.push_back(Hash160(elem,elem+elem_size));
+                            }                                                        
+                        }
+                    }
+                }
+            }
+        }            
+    }
+    
+    if(issuers.size() == 0)
+    {
+        reason="Inputs don't belong to valid issuer";
+        return false;
+    }                
+
+    err=MC_ERR_NOERROR;
+    
+    mc_gState->m_TmpScript->Clear();
+    mc_gState->m_TmpScript->AddElement();
+    unsigned char issuer_buf[24];
+    memset(issuer_buf,0,sizeof(issuer_buf));
+    flags=MC_PFL_NONE;        
+    uint32_t timestamp=0;
+    set <uint160> stored_issuers;
+
+    if(new_issue)
+    {
+//        mc_gState->m_Permissions->SetCheckPoint();
+        err=MC_ERR_NOERROR;
 
-        if(!fScriptParsed)
+        txid=tx.GetHash();
+        err=mc_gState->m_Permissions->SetPermission(&txid,issuer_buf,MC_PTP_CONNECT,
+                (unsigned char*)issuers[0].begin(),0,(uint32_t)(-1),timestamp,flags | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
+    }
+
+    for (unsigned int i = 0; i < issuers.size(); i++)
+    {
+        if(err == MC_ERR_NOERROR)
         {
-                                                                                // New entities
-            if(!MultiChainTransaction_CheckNewEntity(vout, fScriptParsed, details, reason))
+            if(stored_issuers.count(issuers[i]) == 0)
             {
-                return false;
+                memcpy(issuer_buf,issuers[i].begin(),sizeof(uint160));
+                mc_PutLE(issuer_buf+sizeof(uint160),&issuer_flags[i],4);
+                if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
+                {
+                    mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,sizeof(issuer_buf));            
+                }
+                if(new_issue)
+                {
+                    err=mc_gState->m_Permissions->SetPermission(&txid,issuer_buf,MC_PTP_ADMIN | MC_PTP_ISSUE,
+                            (unsigned char*)issuers[0].begin(),0,(uint32_t)(-1),timestamp,flags | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
+                }
+                stored_issuers.insert(issuers[i]);
             }
         }
-        
-        if(!fScriptParsed)
+    }        
+
+    memset(issuer_buf,0,sizeof(issuer_buf));
+    mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,1);
+/*                    
+    if(new_issue)
+    {
+        if((err != MC_ERR_NOERROR) || !accept)
         {
-            reason="Metadata script rejected - Unrecognized script, should be new entity or input script cache";
-            return false;
-        }        
+            mc_gState->m_Permissions->RollBackToCheckPoint();            
+        }
+    }
+*/
+    if(err)
+    {
+        reason="Cannot update permission database for issued asset";
+        return false;            
     }
     
-    if( (mc_gState->m_TmpScript->GetNumElements() > 3) && 
-        (mc_gState->m_Features->MultipleStreamKeys() == 0) )                    // More than 2 OP_DROPs
+    const unsigned char *special_script;
+    size_t special_script_size=0;
+    special_script=mc_gState->m_TmpScript->GetData(0,&special_script_size);
+    txid=tx.GetHash();
+    if(new_issue)
+    {        
+        err=mc_gState->m_Assets->InsertAsset(&txid,offset,total,asset_name,multiple,details_script,details_script_size,special_script,special_script_size,update_mempool);                      
+    }
+    else
     {
-        reason="Metadata script rejected - too many elements";
-        return false;
+        err=mc_gState->m_Assets->InsertAssetFollowOn(&txid,offset,total,details_script,details_script_size,special_script,special_script_size,entity.GetTxID(),update_mempool);
     }
+            
+    if(err)           
+    {
+        reason="Asset issue script rejected - could not insert new asset to database";
+        if(err == MC_ERR_FOUND)
+        {
+            reason="Asset issue script rejected - entity with this name/asset-ref/txid already exists";                        
+            if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&txid) == 0)
+            {
+                if(strlen(asset_name) == 0)
+                {
+                    mc_gState->m_Assets->FindEntityByName(&entity,asset_name);
+                }
+            }
+            
+            if(fDebug)LogPrint("mchn","Asset already exists. TxID: %s, AssetRef: %d-%d-%d, Name: %s\n",
+                    tx.GetHash().GetHex().c_str(),
+                    mc_gState->m_Assets->m_Block+1,offset,(int)(*((unsigned char*)&txid+31))+256*(int)(*((unsigned char*)&txid+30)),
+                    entity.GetName());                                        
+        }
+        return false;                                            
+    }
+        
+    
+    if(update_mempool)
+    {
+        if(offset>=0)
+        {
+            if(mc_gState->m_Assets->FindEntityByTxID(&this_entity,(unsigned char*)&txid))
+            {
+                if(new_issue)
+                {
+                    if(fDebug)LogPrint("mchn","New asset. TxID: %s, AssetRef: %d-%d-%d, Name: %s\n",
+                            tx.GetHash().GetHex().c_str(),
+                            mc_gState->m_Assets->m_Block+1,offset,(int)(*((unsigned char*)&txid+0))+256*(int)(*((unsigned char*)&txid+1)),
+                            this_entity.GetName());                                        
+                }
+                else
+                {
+                    uint256 otxid;
+                    memcpy(&otxid,entity.GetTxID(),32);
+                    if(fDebug)LogPrint("mchn","Follow-on issue. TxID: %s,  Original issue txid: %s\n",
+                            tx.GetHash().GetHex().c_str(),otxid.GetHex().c_str());
+                }
+            }
+            else
+            {
+                reason="Asset issue script rejected - could not insert new asset to database";
+                return false;                                            
+            }
+        }
+    }
+    
+    return true;
+}
+
+
+bool AcceptMultiChainTransaction(const CTransaction& tx, 
+                                 const CCoinsViewCache &inputs,
+                                 int offset,
+                                 bool accept,
+                                 string& reason,
+                                 uint32_t *replay)
+{
+    bool fScriptHashAllFound;
+    bool fSeedNodeInvolved;
+    bool fReject;
+    bool fShouldHaveDestination;
+    bool fRejectIfOpDropOpReturn;
+    bool fCheckCachedScript;
+    bool fFullReplayCheckRequired;
+    bool fAdminMinerGrant;
+    int nNewEntityOutput;
+    unsigned char details_script[MC_ENT_MAX_SCRIPT_SIZE];
+    int details_script_size;
+    uint32_t new_entity_type;
+    int err;
+    
+    vector <txnouttype> vInputScriptTypes;
+    vector <uint160> vInputDestinations;
+    vector <int> vInputHashTypes;
+    vector <bool> vInputCanGrantAdminMine;
+    vector <bool> vInputHadAdminPermissionBeforeThisTx;
+    set <string> vAllowedAdmins;
+    set <string> vAllowedActivators;
+    
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return true;
+    }    
+
+    details_script_size=0;
+    new_entity_type=MC_ENT_TYPE_NONE;
+    
+    fCheckCachedScript=false;
+    if(mc_gState->m_Features->CachedInputScript())
+    {
+        if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+        {
+            fCheckCachedScript=true;
+        }        
+    }
+    
+    fFullReplayCheckRequired=false;
+    fAdminMinerGrant=false;
+    fScriptHashAllFound=false;     
+    fRejectIfOpDropOpReturn=false;
+    mc_gState->m_TmpAssetsIn->Clear();
+    for (unsigned int i = 0; i < tx.vin.size(); i++)                            // Processing input scripts
+    {                                                                                                                                                                
+        if(tx.IsCoinBase())                                                     
+        {                                                                                                                                           
+            if(i == 0)                                                          
+            {
+                if(mc_gState->m_Permissions->m_Block == -1)                     
+                {
+                    vInputScriptTypes.push_back(TX_PUBKEYHASH);
+                    vInputDestinations.push_back(mc_GenesisAdmin(tx));          // Genesis admin is considered to be admin/opener of everything in genesis block        
+                    fCheckCachedScript=false;
+                }
+                else
+                {
+                    vInputScriptTypes.push_back(TX_NONSTANDARD);
+                    vInputDestinations.push_back(0);                                                    
+                }
+                fScriptHashAllFound=true;                                       // Allows to transfer OP_RETURN metadata in this tx. 
+                vInputHashTypes.push_back(SIGHASH_ALL);                         
+            }
+            else                                                                
+            {
+                vInputScriptTypes.push_back(TX_NONSTANDARD);
+                vInputDestinations.push_back(0);                                
+                vInputHashTypes.push_back(SIGHASH_NONE);                                        
+            }                
+        }
+        else
+        {
+            const CScript& script2 = tx.vin[i].scriptSig;        
+            CScript::const_iterator pc2 = script2.begin();
+            if(mc_gState->m_Features->FixedIn10007())
+            {
+                if (!script2.IsPushOnly())
+                {
+                    reason="sigScript should be push-only";
+                    return false;
+                }
+            }
+            
+            const COutPoint &prevout = tx.vin[i].prevout;
+            const CCoins *coins = inputs.AccessCoins(prevout.hash);
+            assert(coins);
+
+            const CScript& script1 = coins->vout[prevout.n].scriptPubKey;        
+            CScript::const_iterator pc1 = script1.begin();
+
+            txnouttype typeRet;
+            int nRequiredRet;
+            vector<CTxDestination> addressRets;
+            int op_addr_offset,op_addr_size,is_redeem_script,sighash_type,check_last;
+
+            sighash_type=SIGHASH_NONE;
+            if(ExtractDestinations(script1,typeRet,addressRets,nRequiredRet))   // Is Standard transaction
+            {
+                if (typeRet != TX_NULL_DATA)                                    // Single-address destinations
+                {
+                    CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
+                    CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
+                    if( (lpKeyID == NULL) && (lpScriptID == NULL) )
+                    {
+                        reason="Internal error: cannot extract address from input scriptPubKey";
+                        return false;
+                    }
+                    else
+                    {
+                        if(typeRet != TX_MULTISIG)
+                        {
+                            if(lpKeyID)
+                            {
+                                vInputDestinations.push_back(*(uint160*)lpKeyID);                               
+                            }
+                            if(lpScriptID)
+                            {
+                                vInputDestinations.push_back(*(uint160*)lpScriptID);                               
+                            }
+                        }
+                        else
+                        {
+                            vInputDestinations.push_back(0);                                   
+                        }
+                    }
+                    
+                    check_last=0;
+                    if( (typeRet == TX_PUBKEY) || (typeRet == TX_MULTISIG) )
+                    {
+                        check_last=1;
+                    }
+                    
+                                                                                // Find sighash_type
+                    mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,check_last);        
+                    if(sighash_type == SIGHASH_ALL)
+                    {
+                        fScriptHashAllFound=true;
+                    }
+                    if(mc_gState->m_Features->FixedIn10008())
+                    {
+                        if(sighash_type == SIGHASH_SINGLE)
+                        {
+                            if(i >= tx.vout.size())
+                            {
+                                reason="SIGHASH_SINGLE input without matching output";
+                                return false;                                
+                            }
+                        }                    
+                    }
+                    if(check_last)
+                    {
+                        fRejectIfOpDropOpReturn=true;                           // pay-to-pubkey and bare multisig  script cannot be considered "publisher" for the stream, because we cannot
+                                                                                // extract it from the input script. Though we can still accept this transaction it is rejected
+                                                                                // for consistency with principle "each input which signs the stream item must contain a permitted writer"
+                    }
+                }
+                else
+                {
+                    fRejectIfOpDropOpReturn=true;                               // Null data scripts cannot be used in txs with OP_DROP+OP_RETURN
+                                                                                // We should not be there at all as null data scripts cannot be signed generally speaking
+                    vInputDestinations.push_back(0);       
+                }            
+                vInputScriptTypes.push_back(typeRet);
+            }
+            else
+            {
+                fRejectIfOpDropOpReturn=true;                                   // Non-standard inputs cannot be used in txs with OP_DROP+OP_RETURN
+                                                                                // Otherwise we cannot be sure where are the signatures in input script
+                vInputScriptTypes.push_back(TX_NONSTANDARD);
+                vInputDestinations.push_back(0);                                
+            }            
+
+            vInputHashTypes.push_back(sighash_type);        
+            
+            if(!mc_ExtractInputAssetQuantities(script1,prevout.hash,reason))    // Filling input asset quantity list
+            {
+                return false;
+            }
+        }    
+        
+        vInputCanGrantAdminMine.push_back(!fCheckCachedScript);            
+    }    
+        
+    fReject=false;
+    nNewEntityOutput=-1;
+    fSeedNodeInvolved=false;
+    fShouldHaveDestination=false;
+    fShouldHaveDestination |= (MCP_ALLOW_ARBITRARY_OUTPUTS == 0);
+    fShouldHaveDestination |= (MCP_ANYONE_CAN_RECEIVE == 0);
+    fShouldHaveDestination |= (MCP_ALLOW_MULTISIG_OUTPUTS == 0);
+    fShouldHaveDestination |= (MCP_ALLOW_P2SH_OUTPUTS == 0);
+    
+    mc_gState->m_Permissions->SetCheckPoint();
+    mc_gState->m_TmpAssetsOut->Clear();
+    
+                                                                                // Processing output scripts
+                                                                                // pass 0 - all permissions, except mine, admin and activate + script type checks
+                                                                                // pass 1 - mine permissions (to retrieve cached scripts in pass=0)
+                                                                                // pass 2 - admin and activate permissions (to retrive list of admins in pass=0)
+                                                                                // pass 3 - everything except permissions - balance, assets, streams
+    for(int pass=0;pass<4;pass++)
+    {
+        for (unsigned int j = 0; j < tx.vout.size(); j++)
+        {
+            bool fNoDestinationInOutput;
+            bool fIsPurePermission;
+            bool fAdminRequired;
+            bool fCheckAdminList;
+            bool fAllValidPublishers;
+            bool fScriptParsed;
+            unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
+            mc_EntityDetails entity;
+            int receive_required;
+            uint32_t type,from,to,timestamp,flags,approval;
+            unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE];
+            int item_key_size,entity_update;
+            int cs_offset,cs_new_offset,cs_size,cs_vin;
+            unsigned char *cs_script;
+            
+            const CScript& script1 = tx.vout[j].scriptPubKey;        
+            CScript::const_iterator pc1 = script1.begin();
+
+
+            mc_gState->m_TmpScript->Clear();
+            mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+                       
+            if(mc_gState->m_TmpScript->IsOpReturnScript())                      // OP_RETURN
+            {
+                if( (pass == 0) && !fScriptHashAllFound)             
+                {
+                    if(mc_gState->m_Features->FixedIn10007())
+                    {
+                        if( (vInputHashTypes.size() <= j) || (vInputHashTypes[j] != SIGHASH_SINGLE) )
+                        {
+                            reason="Output with metadata should be properly signed";
+                            fReject=true;
+                            goto exitlbl;                                                                    
+                        }                        
+                    }
+                    else
+                    {
+                        reason="Tx with metadata should have at least one SIGHASH_ALL output";
+                        fReject=true;
+                        goto exitlbl;                                                                
+                    }
+                }
+                
+                if( (pass == 0) && (mc_gState->m_TmpScript->GetNumElements() > 1) ) // We have at least one OP_DROP element
+                {
+                    if(fRejectIfOpDropOpReturn)                                 // We cannot extract sighash_type properly from the input script 
+                                                                                // as we don't know where are the signatures
+                    {
+                        reason="Non-standard, P2PK or bare multisig inputs cannot be used in this tx";
+                        fReject=true;
+                        goto exitlbl;                                                                
+                    }
+                    
+                    if(mc_gState->m_TmpScript->IsDirtyOpReturnScript())
+                    {
+                        reason="Non-standard, Only OP_DROP elements are allowed in metadata outputs with OP_DROP";
+                        fReject=true;
+                        goto exitlbl;                                                                                        
+                    }
+                }
+                
+                if( (pass == 0) && (mc_gState->m_TmpScript->GetNumElements() == 2) ) // One OP_DROP + OP_RETURN - new entity or cached script
+                {
+                    mc_gState->m_TmpScript->SetElement(0);
+                    fScriptParsed=false;
+                                                  
+                    if(mc_gState->m_Features->CachedInputScript())
+                    {
+                        cs_offset=0;
+                        while( (err=mc_gState->m_TmpScript->GetCachedScript(cs_offset,&cs_new_offset,&cs_vin,&cs_script,&cs_size)) != MC_ERR_WRONG_SCRIPT )
+                        {
+                            fScriptParsed=true;
+                            if(err != MC_ERR_NOERROR)
+                            {
+                                reason="Metadata script rejected - error in cached script";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                            
+                            }
+                            if(cs_offset)
+                            {
+                                if( cs_vin >= (int)tx.vin.size() )
+                                {
+                                    reason="Metadata script rejected - invalid input in cached script";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                                
+                                }
+                                const COutPoint &prevout = tx.vin[cs_vin].prevout;
+                                const CCoins *coins = inputs.AccessCoins(prevout.hash);
+                                
+                                const CScript& script3 = coins->vout[prevout.n].scriptPubKey;        
+                                CScript::const_iterator pc3 = script3.begin();
+
+                                if(cs_size != (int)script3.size())
+                                {
+                                    reason="Metadata script rejected - cached script mismatch";
+                                    fReject=true;
+                                    goto exitlbl;                                                                               
+                                }
+                                if(memcmp(cs_script,(unsigned char*)&pc3[0],cs_size))
+                                {
+                                    reason="Metadata script rejected - cached script mismatch";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                   
+                                }
+                                if(fCheckCachedScript)
+                                {
+                                    if(vInputHashTypes[cs_vin] == SIGHASH_ALL)
+                                    {
+                                        vInputCanGrantAdminMine[cs_vin]=true;
+                                    }
+                                }
+                            }
+                            cs_offset=cs_new_offset;
+                        }
+                    }
+
+                    if(mc_gState->m_Features->OpDropDetailsScripts())
+                    {
+                        err=mc_gState->m_TmpScript->GetNewEntityType(&new_entity_type,&entity_update,details_script,&details_script_size);
+                        if(err == 0)    // New entity element
+                        {
+                            fScriptParsed=true;
+                            if(nNewEntityOutput >= 0)
+                            {
+                                reason="Metadata script rejected - too many new entities";
+                                fReject=true;
+                                goto exitlbl;                                                                                            
+                            }
+                            if(entity_update)
+                            {
+                                reason="Metadata script rejected - entity update script should be preceded by entityref";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                            
+                            }
+                            if(new_entity_type <= mc_gState->m_Assets->MaxEntityType())
+                            {
+                                if(new_entity_type != MC_ENT_TYPE_ASSET)
+                                {
+                                    nNewEntityOutput=j;
+                                }
+                            }
+                            else
+                            {
+                                reason="Metadata script rejected - unsupported new entity type";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                                                                                            
+                            }
+                        }   
+                        else
+                        {
+                            if(err != MC_ERR_WRONG_SCRIPT)
+                            {
+                                reason="Entity details script rejected - error in script";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                                                        
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if(mc_gState->m_TmpScript->GetNewEntityType(&new_entity_type) == 0)    // New entity element
+                        {
+                            fScriptParsed=true;
+                            if(nNewEntityOutput >= 0)
+                            {
+                                reason="Metadata script rejected - too many new entities";
+                                fReject=true;
+                                goto exitlbl;                                                                                            
+                            }
+                            if(new_entity_type != MC_ENT_TYPE_STREAM)
+                            {
+                                reason="Metadata script rejected - unsupported new entity type";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                        
+                            }
+                            nNewEntityOutput=j;
+                                                                                    // Should be SPKc
+                            mc_gState->m_TmpScript->SetElement(1);
+                            err=mc_gState->m_TmpScript->GetGeneralDetails(details_script,&details_script_size);
+                            if(err)
+                            {
+                                if(err != MC_ERR_WRONG_SCRIPT)
+                                {
+                                    reason="Entity details script rejected - error in script";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                        
+                                }
+                                details_script_size=0;
+                            }
+                        }
+                    }
+                    if(!fScriptParsed)
+                    {
+                        reason="Metadata script rejected - Unrecognized script, should be new entity";
+                        if(mc_gState->m_Features->CachedInputScript())
+                        {
+                            reason+=" or input script cache";
+                        }
+                        fReject=true;
+                        goto exitlbl;                                                                                                                                        
+                    }
+                }
+                
+                if( (pass == 0) && (mc_gState->m_TmpScript->GetNumElements() > 3) ) // More than 2 OP_DROPs
+                {
+                    reason="Metadata script rejected - too many elements";
+                    fReject=true;
+                    goto exitlbl;                                                                                                                                        
+                }
+
+                if( (pass == 0) && (mc_gState->m_TmpScript->GetNumElements() == 3) ) // 2 OP_DROPs + OP_RETURN - possible upgrade approval
+                {
+                    if(mc_gState->m_Features->Upgrades())
+                    {
+                        mc_gState->m_TmpScript->SetElement(1);
+
+                        if(mc_gState->m_TmpScript->GetApproval(&approval,&timestamp) == 0)
+                        {
+                            if(vInputHadAdminPermissionBeforeThisTx.size() == 0)
+                            {
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    vInputHadAdminPermissionBeforeThisTx.push_back(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&vInputDestinations[i]) != 0);
+                                }                                
+                            }
+                        }                        
+                    }
+                }
+                
+                if( (pass == 3) && (mc_gState->m_TmpScript->GetNumElements() == 3) ) // 2 OP_DROPs + OP_RETURN - item key or entity update or upgrade approval
+                {
+                    mc_gState->m_TmpScript->SetElement(0);
+                                                                                // Should be spke
+                    if(mc_gState->m_TmpScript->GetEntity(short_txid))           // Entity element
+                    {
+                        reason="Metadata script rejected - wrong element, should be entityref";
+                        fReject=true;
+                        goto exitlbl;                                                                                                                                        
+                    }
+                    if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
+                    {
+                        reason="Metadata script rejected - entity not found";
+                        fReject=true;
+                        goto exitlbl;                                                                            
+                    }               
+                    
+                    if(mc_gState->m_Features->OpDropDetailsScripts())
+                    {
+                        if(entity.GetEntityType() == MC_ENT_TYPE_ASSET)
+                        {
+                            mc_gState->m_TmpScript->SetElement(1);
+                            err=mc_gState->m_TmpScript->GetNewEntityType(&new_entity_type,&entity_update,details_script,&details_script_size);
+                            if(err == 0)    // New entity element
+                            {
+                                if(entity_update == 0)
+                                {
+                                    reason="Metadata script rejected - wrong element, should be entity update";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                                                                    
+                                }
+                                if(new_entity_type != MC_ENT_TYPE_ASSET)
+                                {
+                                    reason="Metadata script rejected - entity type mismatch in update script";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                                                                                                        
+                                }                                
+                            }          
+                            else
+                            {
+                                reason="Metadata script rejected - wrong element, should be entity update";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                                                                    
+                            }
+                        }
+                        else                                                    // (pseudo)stream or upgrade
+                        {
+                            if((mc_gState->m_Features->Upgrades() == 0) || (entity.GetEntityType() != MC_ENT_TYPE_UPGRADE)) // (pseudo)stream
+                            {
+                                mc_gState->m_TmpScript->SetElement(1);
+                                                                                    // Should be spkk
+                                if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
+                                {
+                                    reason="Metadata script rejected - wrong element, should be item key";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                        
+                                }                                            
+                            }
+                            else                        
+                            {
+                                mc_gState->m_TmpScript->SetElement(1);          // Upgrade approval
+                                
+                                if(mc_gState->m_TmpScript->GetApproval(&approval,&timestamp))
+                                {
+                                    reason="Metadata script rejected - wrong element, should be upgrade approval";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                                            
+                                }
+                                uint256 upgrade_hash=*(uint256*)(entity.GetTxID());
+                                if(approval)
+                                {
+                                    LogPrintf("Found approval script in tx %s for %s\n",
+                                            tx.GetHash().GetHex().c_str(),
+                                            upgrade_hash.ToString().c_str());
+                                }
+                                else
+                                {
+                                    LogPrintf("Found disapproval script in tx %s for %s\n",
+                                            tx.GetHash().GetHex().c_str(),
+                                            upgrade_hash.ToString().c_str());                                    
+                                }
+
+                                bool fAdminFound=false;
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    if(vInputHadAdminPermissionBeforeThisTx[i])
+                                    {
+                                        if( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && (i == j) ) )
+                                        {
+                                            if(mc_gState->m_Permissions->SetApproval(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,approval,
+                                                                                     (unsigned char*)&vInputDestinations[i],entity.UpgradeStartBlock(),timestamp,MC_PFL_NONE,1,offset) == 0)
+                                            {
+                                                fAdminFound=true;
+                                            }                                                                                    
+                                        }                                        
+                                    }
+                                }   
+                                if(!fAdminFound)
+                                {
+                                    reason="Inputs don't belong to valid admin for approval script";
+                                    fReject=true;
+                                    goto exitlbl;                                                            
+                                }                                
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if(entity.GetEntityType() != MC_ENT_TYPE_STREAM)
+                        {
+                            reason="Metadata script rejected - not stream entity";                            
+                            fReject=true;
+                            goto exitlbl;                                                                                                                                        
+                        }                        
+                        mc_gState->m_TmpScript->SetElement(1);
+                                                                                // Should be spkk
+                        if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
+                        {
+                            reason="Metadata script rejected - wrong element, should be item key";
+                            fReject=true;
+                            goto exitlbl;                                                                                                                                        
+                        }                                            
+                    }
+                    
+                    if( (entity.GetEntityType() != MC_ENT_TYPE_ASSET) && (entity.GetEntityType() != MC_ENT_TYPE_UPGRADE) )
+                    {
+                        fAllValidPublishers=true;
+                        if(entity.AnyoneCanWrite() == 0)
+                        {
+                            if(mc_gState->m_Features->FixedIn10007())
+                            {
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    if( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && (i == j) ) )
+                                    {
+                                        if(fAllValidPublishers)
+                                        {
+                                            if(mc_gState->m_Permissions->CanWrite(entity.GetTxID(),(unsigned char*)&vInputDestinations[i]) == 0)
+                                            {
+                                                fAllValidPublishers=false;
+                                            }
+                                        }
+                                    }
+                                }                                
+                            }
+                            else
+                            {
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    if(fAllValidPublishers)
+                                    {
+                                        fAllValidPublishers=false;
+                                        if( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && (i == j) ) )
+                                        {
+                                                                                // Only in these two cases we can extract address from the input script
+                                                                                // When subscribing to the stream we don't have output scripts
+                                            if( (vInputScriptTypes[i] == TX_PUBKEYHASH) || (vInputScriptTypes[i] == TX_SCRIPTHASH) )
+                                            {
+                                                if(mc_gState->m_Permissions->CanWrite(entity.GetTxID(),(unsigned char*)&vInputDestinations[i]))
+                                                {
+                                                    fAllValidPublishers=true;
+                                                }
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+                        if(!fAllValidPublishers)
+                        {
+                            reason="Metadata script rejected - Inputs don't belong to valid publisher";
+                            fReject=true;
+                            goto exitlbl;                                                                                                                                                                
+                        }                    
+                    }
+                }
+            }
+            else                                                                // Not OP_RETURN
+            {
+                txnouttype typeRet;
+                int nRequiredRet;
+                vector<CTxDestination> addressRets;
+
+                fNoDestinationInOutput=false;
+                
+                if(!ExtractDestinations(script1,typeRet,addressRets,nRequiredRet))
+                {
+                    fNoDestinationInOutput=true;
+                }            
+
+                if( (pass == 0) && fShouldHaveDestination )                     // Some setting in the protocol require address can be extracted
+                {
+                    if(fNoDestinationInOutput && 
+                      ( (MCP_ANYONE_CAN_RECEIVE == 0) || (MCP_ALLOW_ARBITRARY_OUTPUTS == 0) ) )
+                    {
+                        reason="Script rejected - destination required ";
+                        fReject=true;
+                        goto exitlbl;                    
+                    }
+                    
+                    if((MCP_ALLOW_ARBITRARY_OUTPUTS == 0) || (mc_gState->m_Features->FixedDestinationExtraction() == 0) )
+                    {
+                        if((typeRet == TX_MULTISIG) && (MCP_ALLOW_MULTISIG_OUTPUTS == 0))
+                        {
+                            reason="Script rejected - multisig is not allowed";
+                            fReject=true;
+                            goto exitlbl;                    
+                        }
+
+                        if((typeRet == TX_SCRIPTHASH) && (MCP_ALLOW_P2SH_OUTPUTS == 0))
+                        {
+                            reason="Script rejected - P2SH is not allowed";
+                            fReject=true;
+                            goto exitlbl;                    
+                        }
+                    }
+                }                
+                
+                receive_required=0;                                             // Number of required receive permissions
+                if( (pass == 3) && fShouldHaveDestination )
+                {
+                    receive_required=addressRets.size();
+                    if(typeRet == TX_MULTISIG)
+                    {
+                        receive_required-=(pc1[0]-0x50);
+                        receive_required+=1;
+                        if(receive_required>(int)addressRets.size())
+                        {
+                            receive_required=addressRets.size();
+                        }
+                    }
+                }
+                
+                fIsPurePermission=false;
+                if(mc_gState->m_TmpScript->GetNumElements())
+                {
+                    fIsPurePermission=true;
+                }
+                
+                entity.Zero();                                                  // Permission processing    
+                for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
+                {
+                    mc_gState->m_TmpScript->SetElement(e);
+                    if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)      // Entity element
+                    {
+                        if(entity.GetEntityType())
+                        {
+                            reason="Script rejected - duplicate entity script";
+                            fReject=true;
+                            goto exitlbl;                                                
+                        }
+                        if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
+                        {
+                            reason="Script rejected - entity not found";
+                            fReject=true;
+                            goto exitlbl;                                                                            
+                        }                        
+                    }
+                    else                                                        // Not entity element
+                    {   
+                        if(mc_gState->m_TmpScript->GetPermission(&type,&from,&to,&timestamp) == 0)// Permission script
+                        {
+                            if(fNoDestinationInOutput)
+                            {
+                                reason="Script rejected - wrong destination type in output with permission script";
+                                fReject=true;
+                                goto exitlbl;                                
+                            }
+                            fCheckAdminList=false;
+                            if(mc_gState->m_Features->CachedInputScript())
+                            {
+                                fCheckAdminList=true;
+                            }
+                            else
+                            {
+                                if(type & ( MC_PTP_ACTIVATE | MC_PTP_ADMIN ))
+                                {
+                                    fCheckAdminList=true;
+                                }
+                            }
+                            fAdminRequired=false;
+                            switch(pass)
+                            {
+                                case 0:                                         // Not admin or activate
+                                    fAdminRequired=fCheckAdminList;                                        
+                                    if(mc_gState->m_Features->CachedInputScript())
+                                    {
+                                        type &= ( MC_PTP_CONNECT | MC_PTP_SEND | MC_PTP_RECEIVE | MC_PTP_WRITE);
+                                    }
+                                    else
+                                    {
+                                        type &= ~( MC_PTP_ACTIVATE | MC_PTP_ADMIN);                                        
+                                    }
+                                    break;
+                                case 1:                                         // Admin or activate
+                                    if(mc_gState->m_Features->CachedInputScript())
+                                    {
+                                        type &= ( MC_PTP_CREATE | MC_PTP_ISSUE | MC_PTP_ACTIVATE );
+                                    }
+                                    else
+                                    {
+                                        type = 0;                                        
+                                    }
+                                    break;
+                                case 2:                                         // Admin or activate
+                                    if(mc_gState->m_Features->CachedInputScript())
+                                    {
+                                        type &= ( MC_PTP_MINE | MC_PTP_ADMIN );                                        
+                                        if(type)
+                                        {
+                                            fAdminMinerGrant=true;                                            
+                                        }
+                                    }
+                                    else                                        
+                                    {
+                                        type &= ( MC_PTP_ACTIVATE | MC_PTP_ADMIN );
+                                    }
+                                    break;
+                                case 3:                                         // This pass is not about permissions
+                                    type=0;
+                                    break;
+                            }
+                            if(fAdminRequired)                                  // this is done for pass=2, calculating list of valid admins before this tx has effect
+                            {
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    if( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && (i == j) ) )
+                                    {
+                                        if(mc_gState->m_Permissions->CanAdmin(entity.GetTxID(),(unsigned char*)&vInputDestinations[i]))
+                                        {
+                                            vAllowedAdmins.insert(strprintf("%d-%d-%d",i,j,e));
+                                        }                                        
+                                        if(mc_gState->m_Permissions->CanActivate(entity.GetTxID(),(unsigned char*)&vInputDestinations[i]))
+                                        {
+                                            vAllowedActivators.insert(strprintf("%d-%d-%d",i,j,e));
+                                        }
+                                    }
+                                }
+                            }
+                            
+                            if(type)
+                            {
+                                CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
+                                CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
+                                                                                // Permissions cannot be granted to nonstandard outputs or bare multisigs
+                                if(((lpKeyID == NULL) && (lpScriptID == NULL)) || (addressRets.size() > 1))
+                                {
+                                    reason="Permission script rejected - wrong destination type";
+                                    fReject=true;
+                                    goto exitlbl;
+                                }
+                                CBitcoinAddress address;
+                                unsigned char* ptr=NULL;
+                                flags=MC_PFL_NONE;
+                                if(lpKeyID != NULL)
+                                {
+                                    address=CBitcoinAddress(*lpKeyID);
+                                    ptr=(unsigned char*)(lpKeyID);
+                                    if(type & MC_PTP_CONNECT)                   
+                                    {
+                                        if(mc_gState->m_pSeedNode)
+                                        {
+                                            CNode* seed_node;
+                                            seed_node=(CNode*)(mc_gState->m_pSeedNode);
+
+                                                                                // If connect permission of seed node was involved, we may want to disconnect from it
+                                            if(memcmp(ptr,seed_node->kAddrRemote.begin(),20) == 0)
+                                            {
+                                                fSeedNodeInvolved=true;
+                                            }
+                                        }
+                                    }
+                                }
+                                else
+                                {
+                                    flags=MC_PFL_IS_SCRIPTHASH;
+                                    address=CBitcoinAddress(*lpScriptID);
+                                    ptr=(unsigned char*)(lpScriptID);
+                                }
+                                
+                                if(fDebug)LogPrint("mchn","Found permission script in tx %s for %s - (%08x: %d - %d)\n",
+                                        tx.GetHash().GetHex().c_str(),
+                                        address.ToString().c_str(),
+                                        type, from, to);
+
+                                bool fAdminFound=false;
+                                bool fAdminFoundWithoutCachedScript=false;
+                                bool fActivateIsEnough=mc_gState->m_Permissions->IsActivateEnough(type);
+                                for (unsigned int i = 0; i < tx.vin.size(); i++)
+                                {
+                                    if( ( fCheckAdminList && !fActivateIsEnough && (vAllowedAdmins.count(strprintf("%d-%d-%d",i,j,e)) > 0)) ||
+                                        ( fCheckAdminList && fActivateIsEnough && (vAllowedActivators.count(strprintf("%d-%d-%d",i,j,e)) > 0)) ||
+                                        (!fCheckAdminList && ( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && (i == j) ) )))    
+                                    {                 
+                                        if(vInputDestinations[i] != 0)
+                                        {
+                                            if( ( (type & (MC_PTP_ADMIN | MC_PTP_MINE)) == 0) || vInputCanGrantAdminMine[i] || (entity.GetEntityType() > 0) )
+                                            {
+                                                fFullReplayCheckRequired=true;
+                                                if(mc_gState->m_Permissions->SetPermission(entity.GetTxID(),ptr,type,(unsigned char*)&vInputDestinations[i],from,to,timestamp,flags,1,offset) == 0)
+                                                {
+                                                    fAdminFound=true;
+                                                }
+                                            }
+                                            else
+                                            {
+                                                fAdminFoundWithoutCachedScript=true;                                                
+                                            }
+                                        }
+                                    }
+                                }
+                                if(!fAdminFound)
+                                {
+                                    reason="Inputs don't belong to valid admin";
+                                    if(fAdminFoundWithoutCachedScript)
+                                    {
+                                        reason="Inputs require scriptPubKey cache to support miner precheck";
+                                    }
+                                    fReject=true;
+                                    goto exitlbl;                                                            
+                                }
+                            }      
+                            entity.Zero();                                      // Entity element in the non-op-return output should be followed by permission element
+                                                                                // So only permission can nullify it
+                        }
+                        else                                                    // Not permission script
+                        {
+                            if(entity.GetEntityType())                              
+                            {
+                                reason="Script rejected - entity script should be followed by permission";
+                                fReject=true;
+                                goto exitlbl;                                                
+                            }
+                            fIsPurePermission=false;
+                        }
+                    }
+                }                                                               // End of permission script processing
+                
+                if(entity.GetEntityType())
+                {
+                    reason="Script rejected - incomplete entity script";
+                    fReject=true;
+                    goto exitlbl;                                                
+                }
+                
+                if(tx.vout[j].nValue > 0)
+                {
+                    fIsPurePermission=false;
+                }
+
+                if(pass == 3)
+                {
+                    if(!mc_ExtractOutputAssetQuantities(reason))                // Filling output asset quantity list
+                    {
+                        fReject=true;
+                        goto exitlbl;                                                                        
+                    }
+                }
+
+                if( (pass == 3) && !fIsPurePermission )                         // Check for dust and receive permission
+                {
+                    if((offset < 0) && Params().RequireStandard())              // If not in block - part of IsStandard check
+                    {
+                        if (tx.vout[j].IsDust(::minRelayTxFee))             
+                        {
+                            if(!tx.IsCoinBase())
+                            {
+                                reason="Transaction amount too small";
+                                fReject=true;
+                                goto exitlbl;                                                            
+                            }                            
+                        }
+                    }
+                    for(int a=0;a<(int)addressRets.size();a++)
+                    {                            
+                        CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[a]);
+                        CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[a]);
+                        if((lpKeyID == NULL) && (lpScriptID == NULL))
+                        {
+                            reason="Script rejected - wrong destination type";
+                            fReject=true;
+                            goto exitlbl;                                                            
+                        }
+                        unsigned char* ptr=NULL;
+                        if(lpKeyID != NULL)
+                        {
+                            ptr=(unsigned char*)(lpKeyID);
+                        }
+                        else
+                        {
+                            ptr=(unsigned char*)(lpScriptID);
+                        }
 
-    if(mc_gState->m_TmpScript->GetNumElements() == 3 )                          // 2 OP_DROPs + OP_RETURN - possible upgrade approval
-                                                                                // Admin permissions before tx should be used 
-                                                                                // Performed only if it is indeed needed
-    {
-        mc_gState->m_TmpScript->SetElement(1);
+                        bool fCanReceive=mc_gState->m_Permissions->CanReceive(NULL,ptr);
 
-        if(mc_gState->m_TmpScript->GetApproval(&approval,&timestamp) == 0)
-        {
-            MultiChainTransaction_FillAdminPermissionsBeforeTx(tx,details);
-        }                        
-    }
+                        if(tx.IsCoinBase())                                     // Miner can send funds to himself in coinbase even without receive permission
+                        {
+                            fCanReceive |= mc_gState->m_Permissions->CanMine(NULL,ptr);
+                        }
+                        if(fCanReceive)                        
+                        {
+                            receive_required--;
+                        }                                    
+                    }
+                    if(receive_required>0)
+                    {
+                        if( (tx.vout[j].nValue > 0) || 
+                            (mc_gState->m_TmpScript->GetNumElements() > 0) ||
+                            (mc_gState->m_Features->AnyoneCanReceiveEmpty() == 0) )
+                        {
+                            reason="One of the outputs doesn't have receive permission";
+                            fReject=true;
+                            goto exitlbl;                                                                                
+                        }
+                    }
+                }
+            }                                                                   // End of non-OP_RETURN output
+        }                                                                       // End of output processing            
+    }                                                                           // End of pass loop
     
-    if(mc_gState->m_TmpScript->GetNumElements() >= 3 )                          // This output should be processed later - after all permissions
+    if(!mc_CompareAssetQuantities(reason))                                      // Comparing input/output asset quantities
     {
-        details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_OP_RETURN_ENTITY_ITEM;
+        fReject=true;
+        goto exitlbl;                                                                        
     }
-    
-    details->vOutputPermissionRequired.push_back(0);                            // Stubs for these arrays elements, not used later
-    details->vOutputDestinations.push_back(addressRets);
-    details->vOutputSingleDestination.push_back(single_address);
-    
-    return true;
-}
-
-bool MultiChainTransaction_CheckAssetUpdateDetails(mc_EntityDetails *entity,
-                                                   int vout,
-                                                   CMultiChainTxDetails *details,   
-                                                   string& reason)      
-{
-    int err;
-    int entity_update;
-    
-    if(mc_gState->m_TmpScript->GetNumElements() > 3)                            
+        
+                                                                                // Checking asset geneses and follow-ons
+                                                                                // If new entity is found - asset genesis is forbidden, otherwise they will have the same reference
+                                                                                // If we fail here only permission db was updated. it will be rolled back
+    if(!AcceptAssetGenesisFromPredefinedIssuers(tx,offset,accept,vInputDestinations,vInputHashTypes,vInputScriptTypes,(nNewEntityOutput >= 0),reason,&fFullReplayCheckRequired))
     {
-        reason="Metadata script rejected - too many elements in asset update script";
-        return false;
+        fReject=true;
+        goto exitlbl;                                                                                
     }
-    
-    mc_gState->m_TmpScript->SetElement(1);
-    
-    err=mc_gState->m_TmpScript->GetNewEntityType(&(details->new_entity_type),&entity_update,details->details_script,&(details->details_script_size));
-    
-    if(err == 0)    
+            
+    if(nNewEntityOutput >= 0)                                                   // (pseudo)streams and upgrade                                               
     {
-        if(details->details_script_type >= 0)
-        {
-            reason="Metadata script rejected - too many new entities/entity updates";
-            return false;
-        }
+        vector <uint160> openers;
+        vector <uint32_t> opener_flags;
+        unsigned char opener_buf[24];
+        
+        string entity_type_str;
+        uint32_t flags=MC_PFL_NONE;        
+        uint32_t timestamp=0;
+        set <uint160> stored_openers;
+        int update_mempool;
+        uint256 txid;
+        mc_EntityDetails entity;
+        
+        fFullReplayCheckRequired=true;
         
-        if(entity_update == 0)
+        update_mempool=0;
+        if(accept)
         {
-            reason="Metadata script rejected - wrong element, should be entity update";
-            return false;
+            update_mempool=1;            
         }
-        if(details->new_entity_type != MC_ENT_TYPE_ASSET)
-        {
-            reason="Metadata script rejected - entity type mismatch in update script";
-            return false;
-        }      
-        details->details_script_type=entity_update;
-    }          
-    else
-    {
-        reason="Metadata script rejected - wrong element, should be entity update";
-        return false;
-    }
-                                                                                // The script itself will be processed later
-    details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_FOLLOWON_DETAILS;
-    return true;
-}
-
-bool MultiChainTransaction_CheckUpgradeApproval(const CTransaction& tx,
-                                                mc_EntityDetails *entity,
-                                                int offset,  
-                                                int vout,
-                                                CMultiChainTxDetails *details,   
-                                                string& reason)      
-{
-    uint32_t timestamp,approval;
-    uint256 upgrade_hash;
-    bool fAdminFound;
-    
-    if(mc_gState->m_TmpScript->GetNumElements() > 3)                            
-    {
-        reason="Metadata script rejected - too many elements in upgrade approval script";
-        return false;
-    }
-    
-    mc_gState->m_TmpScript->SetElement(1);          
-
-    if(mc_gState->m_TmpScript->GetApproval(&approval,&timestamp))
-    {
-        reason="Metadata script rejected - wrong element, should be upgrade approval";
-        return false;
-    }
-    
-    upgrade_hash=*(uint256*)(entity->GetTxID());
-    if(approval)
-    {
-        LogPrintf("Found approval script in tx %s for %s\n",
-                tx.GetHash().GetHex().c_str(),
-                upgrade_hash.ToString().c_str());
-    }
-    else
-    {
-        LogPrintf("Found disapproval script in tx %s for %s\n",
-                tx.GetHash().GetHex().c_str(),
-                upgrade_hash.ToString().c_str());                                    
-    }
-
-    fAdminFound=false;
-    for (unsigned int i = 0; i < tx.vin.size(); i++)
-    {
-        if(details->vInputHadAdminPermissionBeforeThisTx[i])
+        
+        openers.clear();                                                        // List of openers
+        opener_flags.clear();
+        for (unsigned int i = 0; i < tx.vin.size(); i++)
         {
-            if(details->IsRelevantInput(i,vout))
+            if( (vInputHashTypes[i] == SIGHASH_ALL) || ( (vInputHashTypes[i] == SIGHASH_SINGLE) && ((int)i == nNewEntityOutput) ) )
             {
-                if(mc_gState->m_Permissions->SetApproval(entity->GetTxID()+MC_AST_SHORT_TXID_OFFSET,approval,
-                                                         (unsigned char*)&(details->vInputDestinations[i]),entity->UpgradeStartBlock(),timestamp,MC_PFL_NONE,1,offset) == 0)
-                {
-                    fAdminFound=true;
-                }                                                                                    
-            }                                        
+                if(mc_gState->m_Permissions->CanCreate(NULL,(unsigned char*)&vInputDestinations[i]))
+                {                            
+                    if( (new_entity_type != MC_ENT_TYPE_UPGRADE) || (mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&vInputDestinations[i]) != 0) )
+                    {
+                        openers.push_back(vInputDestinations[i]);
+                        flags=MC_PFL_NONE;
+                        if(vInputScriptTypes[i] == TX_SCRIPTHASH)
+                        {
+                            flags |= MC_PFL_IS_SCRIPTHASH;
+                        }
+                        opener_flags.push_back(flags);
+                    }
+                }                            
+            }
+        }                
+        
+        if(openers.size() == 0)
+        {
+            reason="Metadata script rejected - Inputs don't belong to valid creator";
+            fReject=true;
+            goto exitlbl;                                                                                                                                                                
         }
-    }   
-    
-    if(!fAdminFound)
-    {
-        reason="Inputs don't belong to valid admin for approval script";
-        return false;
-    }                                
-
-    return true;
-}
+        
+        err=MC_ERR_NOERROR;
 
-bool MultiChainTransaction_CheckStreamItem(mc_EntityDetails *entity,
-                                           int vout,
-                                           CMultiChainTxDetails *details,   
-                                           string& reason)      
-{
-    bool fAllValidPublishers;
-    unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE];
-    int item_key_size;
-    
-    if(mc_gState->m_Features->OffChainData())
-    {
-        if(mc_gState->m_TmpScript->m_Restrictions & entity->m_Restrictions)
+        mc_gState->m_TmpScript->Clear();
+        mc_gState->m_TmpScript->AddElement();
+        txid=tx.GetHash();                                                      // Setting first record in the per-entity permissions list
+        
+        if(new_entity_type != MC_ENT_TYPE_UPGRADE)
         {
-            reason="Metadata script rejected - stream restrictions violation";
-            return false;        
+            memset(opener_buf,0,sizeof(opener_buf));
+            err=mc_gState->m_Permissions->SetPermission(&txid,opener_buf,MC_PTP_CONNECT,
+                    (unsigned char*)openers[0].begin(),0,(uint32_t)(-1),timestamp, MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
         }
-    }
-                                                                                // Multiple keys, if not allowed, check for count is made in different place
-    for (int e = 1; e < mc_gState->m_TmpScript->GetNumElements()-1; e++)
-    {
-        mc_gState->m_TmpScript->SetElement(e);
-                                                                                
-        if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))         
-        {
-            reason="Metadata script rejected - wrong element, should be item key";
-            return false;
-        }                                            
-    }
-    
-    fAllValidPublishers=true;
-    if(entity->AnyoneCanWrite() == 0)
-    {
-        for (unsigned int i = 0; i < details->vInputDestinations.size(); i++)
+        for (unsigned int i = 0; i < openers.size(); i++)
         {
-            if(details->IsRelevantInput(i,vout))
+            if(err == MC_ERR_NOERROR)
             {
-                if(fAllValidPublishers)
+                if(stored_openers.count(openers[i]) == 0)
                 {
-                    if(mc_gState->m_Permissions->CanWrite(entity->GetTxID(),(unsigned char*)&(details->vInputDestinations[i])) == 0)
+                    memcpy(opener_buf,openers[i].begin(),sizeof(uint160));
+                    mc_PutLE(opener_buf+sizeof(uint160),&opener_flags[i],4);
+                    if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
+                    {
+                        mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,sizeof(opener_buf));            
+                    }
+                    if(new_entity_type != MC_ENT_TYPE_UPGRADE)
                     {
-                        fAllValidPublishers=false;
+                                                                                // Granting default permissions to openers
+                        err=mc_gState->m_Permissions->SetPermission(&txid,opener_buf,MC_PTP_ADMIN | MC_PTP_ACTIVATE | MC_PTP_WRITE,
+                                (unsigned char*)openers[i].begin(),0,(uint32_t)(-1),timestamp,opener_flags[i] | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
                     }
+                    stored_openers.insert(openers[i]);
                 }
             }
-        }                                
-    }
-    
-    if(!fAllValidPublishers)
-    {
-        reason="Metadata script rejected - Inputs don't belong to valid publisher";
-        return false;
-    }                    
-    
-    return true;
-}
-
-bool MultiChainTransaction_CheckEntityItem(const CTransaction& tx,
-                                           int offset,  
-                                           int vout,
-                                           CMultiChainTxDetails *details,   
-                                           string& reason)      
-{
-    unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-    mc_EntityDetails entity;
-    
-    if(!MultiChainTransaction_VerifyAndDeleteDataFormatElements(reason,NULL))
-    {
-        return false;
-    }
-    
-    mc_gState->m_TmpScript->SetElement(0);
-                                                                                // Should be spke
-    if(mc_gState->m_TmpScript->GetEntity(short_txid))                           // Entity element
-    {
-        reason="Metadata script rejected - wrong element, should be entityref";
-        return false;
-    }
-    
-    if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
-    {
-        reason="Metadata script rejected - entity not found";
-        return false;
-    }               
-    
-    if(entity.GetEntityType() == MC_ENT_TYPE_ASSET)                             // Asset update
-    {
-        if(!MultiChainTransaction_CheckAssetUpdateDetails(&entity,vout,details,reason))
+        }        
+        if(err)
         {
-            return false;            
+            reason=" Cannot update permission database for new entity";
+            fReject=true;
+            goto exitlbl;                                                                                                                                                                
         }
-    }
-    else
-    {
-        if(entity.GetEntityType() == MC_ENT_TYPE_UPGRADE)                       // Upgrade approval
+        
+        memset(opener_buf,0,sizeof(opener_buf));                                // Storing opener list in entity metadata
+        mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,1);                    
+        
+        const unsigned char *special_script;
+        size_t special_script_size=0;
+        special_script=mc_gState->m_TmpScript->GetData(0,&special_script_size);
+        err=mc_gState->m_Assets->InsertEntity(&txid,offset,new_entity_type,details_script,details_script_size,special_script,special_script_size,update_mempool);
+        if(err)           
         {
-            if(!MultiChainTransaction_CheckUpgradeApproval(tx,&entity,offset,vout,details,reason))
+            reason="New entity script rejected - could not insert new entity to database";
+            if(err == MC_ERR_ERROR_IN_SCRIPT)
+            {
+                reason="New entity script rejected - error in script";                        
+            }
+            if(err == MC_ERR_FOUND)
             {
-                return false;            
+                reason="New entity script rejected - entity with this name already exists";                        
             }
+            fReject=true;
+            goto exitlbl;                                                                                                                                                                
         }
-        else                                                                    // (Pseudo)stream item
+
+        if(update_mempool)
         {
-            if(!MultiChainTransaction_CheckStreamItem(&entity,vout,details,reason))
+            if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&txid))
             {
-                return false;            
-            }            
+                entity_type_str="stream";
+                if(new_entity_type == MC_ENT_TYPE_UPGRADE)
+                {
+                    entity_type_str="upgrade";
+                }
+                if(offset>=0)
+                {
+                    LogPrintf("New %s. TxID: %s, StreamRef: %d-%d-%d, Name: %s\n",
+                            entity_type_str.c_str(),tx.GetHash().GetHex().c_str(),
+                            mc_gState->m_Assets->m_Block+1,offset,(int)(*((unsigned char*)&txid+0))+256*(int)(*((unsigned char*)&txid+1)),
+                            entity.GetName());                                        
+                }
+                else
+                {
+                    LogPrintf("New %s. TxID: %s, unconfirmed, Name: %s\n",
+                            entity_type_str.c_str(),tx.GetHash().GetHex().c_str(),entity.GetName());                                                            
+                }
+            }
+            else
+            {
+                reason="New entity script rejected - could not insert new entity to database";
+                fReject=true;
+                goto exitlbl;                                                                                                                                                                
+            }
         }
     }
     
-    return true;
-}
-
-bool MultiChainTransaction_CheckDestinations(const CScript& script1,
-                                             int vout,
-                                             CMultiChainTxDetails *details,   
-                                             string& reason)      
-{
-    bool fNoDestinationInOutput;
-    bool not_cleared;
     
-    txnouttype typeRet;
-    int nRequiredRet,receive_required;    
-    vector<CTxDestination> addressRets;
-    CTxDestination single_destination;
+exitlbl:
+                                    
+    if(accept)
+    {
+        if(fSeedNodeInvolved)                                                   // Checking if we should disconnect from seed node
+        {
+            CNode* seed_node;
+            seed_node=(CNode*)(mc_gState->m_pSeedNode);
 
-    not_cleared=false;
-    fNoDestinationInOutput=false;
+            if(!mc_gState->m_Permissions->CanConnect(NULL,seed_node->kAddrRemote.begin()))
+            {
+                LogPrintf("mchn: Seed node lost connect permission \n");
+                mc_gState->m_pSeedNode=NULL;
+            }
+        }
+    }
 
-    if(mc_gState->m_Features->FixedDestinationExtraction())
+    if(!accept || fReject)                                                      // Rolling back permission database if we were just checking or error occurred    
     {
-        fNoDestinationInOutput=!ExtractDestinations(script1,typeRet,addressRets,nRequiredRet);
+        mc_gState->m_Permissions->RollBackToCheckPoint();
     }
-    else                                                                        // Bug in 10008, permission was set to address in non-standard output
+
+    if(replay)
     {
-        fNoDestinationInOutput=!ExtractDestinations10008(script1,typeRet,addressRets,nRequiredRet,true,&not_cleared);
+        *replay=0;
+        if(fFullReplayCheckRequired)
+        {
+            *replay |= MC_PPL_REPLAY;
+        }
+        if(fAdminMinerGrant)
+        {
+            *replay |= MC_PPL_ADMINMINERGRANT;
+        }
     }
-    if(fNoDestinationInOutput)
+
+    if(fReject)
     {
-        details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_NO_DESTINATION;
-    }      
+        if(fDebug)LogPrint("mchn","mchn: Tx rejected: %s\n",EncodeHexTx(tx));
+    }
+
+    return !fReject;
+}
+
+bool AcceptAdminMinerPermissions(const CTransaction& tx,
+                                 int offset,
+                                 bool verify_signatures,
+                                 string& reason,
+                                 uint32_t *result)
+{
+    vector <txnouttype> vInputScriptTypes;
+    vector <uint160> vInputDestinations;
+    vector <int> vInputHashTypes;
+    vector <bool> vInputCanGrantAdminMine;
+    vector <bool> vInputHadAdminPermissionBeforeThisTx;
+    vector <CScript> vInputPrevOutputScripts;
+    bool fIsEntity;
+    bool fReject;    
+    bool fAdminFound;
+    int err;
 
-    if(fNoDestinationInOutput && 
-      ( (MCP_ANYONE_CAN_RECEIVE == 0) || (MCP_ALLOW_ARBITRARY_OUTPUTS == 0) ) )
+    if(result)
     {
-        reason="Script rejected - destination required ";
-        return false;
+        *result=0;
     }
     
-    if((MCP_ALLOW_ARBITRARY_OUTPUTS == 0) || (mc_gState->m_Features->FixedDestinationExtraction() == 0) )
+    if(tx.IsCoinBase())
     {
-        if((typeRet == TX_MULTISIG) && (MCP_ALLOW_MULTISIG_OUTPUTS == 0))
-        {
-            reason="Script rejected - multisig is not allowed";
-            return false;
-        }
-
-        if((typeRet == TX_SCRIPTHASH) && (MCP_ALLOW_P2SH_OUTPUTS == 0))
-        {
-            reason="Script rejected - P2SH is not allowed";
-            return false;
-        }
+        return true;
+    }
+    
+    for (unsigned int i = 0; i < tx.vin.size(); i++)                            
+    {                                                                                                                                                                
+        vInputCanGrantAdminMine.push_back(false);
+        vInputPrevOutputScripts.push_back(CScript());
+        vInputDestinations.push_back(0);
     }
     
-    receive_required=addressRets.size();
-    if(typeRet == TX_MULTISIG)
+    fReject=false;
+    fAdminFound=false;
+    for (unsigned int j = 0; j < tx.vout.size(); j++)
     {
-        receive_required-=nRequiredRet;
-        receive_required+=1;
-        if(receive_required>(int)addressRets.size())
-        {
-            receive_required=addressRets.size();
+        int cs_offset,cs_new_offset,cs_size,cs_vin;
+        unsigned char *cs_script;
+            
+        const CScript& script1 = tx.vout[j].scriptPubKey;        
+        CScript::const_iterator pc1 = script1.begin();
+
+
+        mc_gState->m_TmpScript->Clear();
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+                       
+        if(mc_gState->m_TmpScript->IsOpReturnScript())                      
+        {                
+            if( mc_gState->m_TmpScript->GetNumElements() == 2 ) 
+            {
+                mc_gState->m_TmpScript->SetElement(0);
+                                                  
+                if(mc_gState->m_Features->CachedInputScript())
+                {
+                    cs_offset=0;
+                    while( (err=mc_gState->m_TmpScript->GetCachedScript(cs_offset,&cs_new_offset,&cs_vin,&cs_script,&cs_size)) != MC_ERR_WRONG_SCRIPT )
+                    {
+                        if(err != MC_ERR_NOERROR)
+                        {
+                            reason="Metadata script rejected - error in cached script";
+                            fReject=true;
+                            goto exitlbl;                                                                                                                            
+                        }
+                        if(cs_offset)
+                        {
+                            if( cs_vin >= (int)tx.vin.size() )
+                            {
+                                reason="Metadata script rejected - invalid input in cached script";
+                                fReject=true;
+                                goto exitlbl;                                                                                                                                                                
+                            }
+                            vInputPrevOutputScripts[cs_vin]=CScript(cs_script,cs_script+cs_size);                            
+                            vInputCanGrantAdminMine[cs_vin]=true;
+//                            fAdminFound=true;
+                        }
+                        cs_offset=cs_new_offset;
+                    }
+                }
+            }
         }
     }
-
-    if(addressRets.size())
-    {
-        single_destination=addressRets[0];
-    }
-    if(not_cleared)
-    {
-        receive_required=0;
-        addressRets.clear();
-    }
-    details->vOutputPermissionRequired.push_back(receive_required);
-    details->vOutputDestinations.push_back(addressRets);
-    details->vOutputSingleDestination.push_back(single_destination);
-    
-    return true;
-}
-
-bool MultiChainTransaction_ProcessPermissions(const CTransaction& tx,
-                                              int offset,  
-                                              int vout,
-                                              uint32_t permission_type,
-                                              bool fFirstPass,
-                                              CMultiChainTxDetails *details,   
-                                              string& reason)      
-{
-    bool fIsPurePermission;
-    bool fNoDestinationInOutput;    
-    unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-    mc_EntityDetails entity;
-    uint32_t type,from,to,timestamp,flags;
-    
-    fIsPurePermission=false;
-    if(mc_gState->m_TmpScript->GetNumElements())
+/*
+    if(!fAdminFound)
     {
-        fIsPurePermission=true;
+        goto exitlbl;                                                                                                                                                                        
     }
-                
-    fNoDestinationInOutput=( (details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_NO_DESTINATION) != 0);
     
-    entity.Zero();                                                  
-    for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
-    {
-        mc_gState->m_TmpScript->SetElement(e);
-        if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)                  // Entity element
+    fAdminFound=false;
+*/    
+    for (unsigned int i = 0; i < tx.vin.size(); i++)        
+    {                                                                                                                                                                
+        if(vInputCanGrantAdminMine[i])
         {
-            if(entity.GetEntityType())
-            {
-                reason="Script rejected - duplicate entity script";
-                return false;
-            }
-            if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
-            {
-                reason="Script rejected - entity not found";
-                return false;
-            }                        
-        }
-        else                                                                    // Not entity element
-        {   
-            if(mc_gState->m_TmpScript->GetPermission(&type,&from,&to,&timestamp) == 0) // Grant script
+            vInputCanGrantAdminMine[i]=false;
+            const CScript& script2 = tx.vin[i].scriptSig;        
+            CScript::const_iterator pc2 = script2.begin();
+            if(mc_gState->m_Features->FixedIn10007())
             {
-                if(fNoDestinationInOutput)
+                if (!script2.IsPushOnly())
                 {
-                    reason="Script rejected - wrong destination type in output with permission script";
-                    return false;
+                    reason="sigScript should be push-only";
+                    fReject=true;
+                    goto exitlbl;                                                                                                                                                                
                 }
-                
-                if(fFirstPass)  
+            }
+
+            const CScript& script1 = vInputPrevOutputScripts[i];        
+            CScript::const_iterator pc1 = script1.begin();
+
+            txnouttype typeRet;
+            int nRequiredRet;
+            vector<CTxDestination> addressRets;
+            int op_addr_offset,op_addr_size,is_redeem_script,sighash_type,check_last;
+
+            sighash_type=SIGHASH_NONE;
+            if(ExtractDestinations(script1,typeRet,addressRets,nRequiredRet)) 
+            {
+                if ( (typeRet != TX_NULL_DATA) && (typeRet != TX_MULTISIG) )                                  
                 {
-                    if( type & ( MC_PTP_CREATE | MC_PTP_ISSUE | MC_PTP_ACTIVATE ) )
+                    CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
+                    CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
+                    if( (lpKeyID == NULL) && (lpScriptID == NULL) )
                     {
-                        details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_CREATE;
+                        fReject=true;
+                        goto exitlbl;                                                                                                                                                                
                     }
-                    if( type & ( MC_PTP_MINE | MC_PTP_ADMIN ) )
+                    if(lpKeyID)
                     {
-                        details->fAdminMinerGrant=true;
-                        details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_ADMIN;
-                    }                    
-                }
-                
-                type &= permission_type;                                        // Processing only relevant permissions
-                
-                                                                                // Admins and activators are those having permissions before thix tx
-                for (unsigned int i = 0; i < details->vInputDestinations.size(); i++)
-                {
-                    if(details->IsRelevantInput(i,vout))
+                        vInputDestinations[i]=*(uint160*)lpKeyID;                               
+                    }
+                    if(lpScriptID)
                     {
-                        if(mc_gState->m_Permissions->CanAdmin(entity.GetTxID(),(unsigned char*)&(details->vInputDestinations[i])))
-                        {
-                            details->vAllowedAdmins.insert(strprintf("%d-%d-%d",i,vout,e));
-                        }                                        
-                        if(mc_gState->m_Permissions->CanActivate(entity.GetTxID(),(unsigned char*)&(details->vInputDestinations[i])))
-                        {
-                            details->vAllowedActivators.insert(strprintf("%d-%d-%d",i,vout,e));
-                        }
+                        vInputDestinations[i]=*(uint160*)lpScriptID;                               
                     }
-                }
-                            
-                if(type)
-                {
-                    CKeyID *lpKeyID=boost::get<CKeyID> (&(details->vOutputSingleDestination[vout]));
-                    CScriptID *lpScriptID=boost::get<CScriptID> (&(details->vOutputSingleDestination[vout]));
                     
-                                                                                // Permissions cannot be granted to nonstandard outputs or bare multisigs
-                    if(((lpKeyID == NULL) && (lpScriptID == NULL)) || (details->vOutputDestinations[vout].size() > 1))
+                    check_last=0;
+                    if( typeRet == TX_PUBKEY )
                     {
-                        reason="Permission script rejected - wrong destination type";
-                        return false;
+                        check_last=1;
                     }
-                    
-                    CBitcoinAddress address;
-                    unsigned char* ptr=NULL;
-                    flags=MC_PFL_NONE;
-                    if(lpKeyID != NULL)
+
+                                                                                // Find sighash_type
+                    mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,check_last);        
+                    if(sighash_type == SIGHASH_ALL)
                     {
-                        address=CBitcoinAddress(*lpKeyID);
-                        ptr=(unsigned char*)(lpKeyID);
-                        if(type & MC_PTP_CONNECT)                   
+                        if(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&vInputDestinations[i]))
                         {
-                            if(mc_gState->m_pSeedNode)
+                            vInputCanGrantAdminMine[i]=true;
+                            if(verify_signatures)
                             {
-                                CNode* seed_node;
-                                seed_node=(CNode*)(mc_gState->m_pSeedNode);
-
-                                                                                // If connect permission of seed node was involved, we may want to disconnect from it
-                                if(memcmp(ptr,seed_node->kAddrRemote.begin(),20) == 0)
+                                vInputCanGrantAdminMine[i]=false;
+                                if(VerifyScript(script2, script1, STANDARD_SCRIPT_VERIFY_FLAGS, CachingTransactionSignatureChecker(&tx, i, false)))
+                                {
+                                    vInputCanGrantAdminMine[i]=true;
+                                }
+                                else
                                 {
-                                    details->fSeedNodeInvolved=true;
+                                    reason="Signature verification error";
+                                    fReject=true;
+                                    goto exitlbl;                                                                                                                                                                                                    
                                 }
                             }
-                        }
+/*                            
+                            if(vInputCanGrantAdminMine[i])
+                            {
+                                fAdminFound=true;
+                            }
+ */ 
+                        } 
                     }
-                    else
+                }
+            }    
+        }        
+    }    
+/*    
+    if(!fAdminFound)
+    {
+        goto exitlbl;                                                                                                                                                                        
+    }
+*/    
+    for (unsigned int j = 0; j < tx.vout.size(); j++)
+    {
+        unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
+        uint32_t type,from,to,timestamp,flags;
+            
+        const CScript& script1 = tx.vout[j].scriptPubKey;        
+        CScript::const_iterator pc1 = script1.begin();
+
+
+        mc_gState->m_TmpScript->Clear();
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+        
+        CTxDestination addressRet;
+
+        if(ExtractDestination(script1,addressRet))
+        {            
+            fIsEntity=false;
+
+            for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
+            {
+                mc_gState->m_TmpScript->SetElement(e);
+                if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)      
+                {
+                    if(fIsEntity)
                     {
-                        flags=MC_PFL_IS_SCRIPTHASH;
-                        address=CBitcoinAddress(*lpScriptID);
-                        ptr=(unsigned char*)(lpScriptID);
+                        reason="Script rejected - duplicate entity script";
+                        fReject=true;
+                        goto exitlbl;                                                
                     }
-                                
-                    if(fDebug)LogPrint("mchn","Found permission script in tx %s for %s - (%08x: %d - %d)\n",
-                            tx.GetHash().GetHex().c_str(),
-                            address.ToString().c_str(),
-                            type, from, to);
-
-                    bool fAdminFound=false;
-                    bool fAdminFoundWithoutCachedScript=false;
-                    bool fActivateIsEnough=mc_gState->m_Permissions->IsActivateEnough(type);
-                    
-                    for (unsigned int i = 0; i < tx.vin.size(); i++)
+                    if(mc_gState->m_Features->FixedIn1000920001())
                     {
-                        if( ( !fActivateIsEnough && (details->vAllowedAdmins.count(strprintf("%d-%d-%d",i,vout,e)) > 0)) ||
-                            (  fActivateIsEnough && (details->vAllowedActivators.count(strprintf("%d-%d-%d",i,vout,e)) > 0)) )    
-                        {                 
-                            if(details->vInputDestinations[i] != 0)
+                        fIsEntity=true;
+                    }
+                }
+                else                                                        
+                {   
+                    if(mc_gState->m_TmpScript->GetPermission(&type,&from,&to,&timestamp) == 0)
+                    {                        
+                        type &= ( MC_PTP_MINE | MC_PTP_ADMIN );                                        
+                        if(fIsEntity)
+                        {
+                            type=0;
+                        }
+                        if(type)
+                        {
+                            CKeyID *lpKeyID=boost::get<CKeyID> (&addressRet);
+                            CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
+                            if((lpKeyID == NULL) && (lpScriptID == NULL))
+                            {
+                                reason="Permission script rejected - wrong destination type";
+                                fReject=true;
+                                goto exitlbl;
+                            }
+                            unsigned char* ptr=NULL;
+                            flags=MC_PFL_NONE;
+                            if(lpKeyID != NULL)
+                            {
+                                ptr=(unsigned char*)(lpKeyID);
+                            }
+                            else
+                            {
+                                flags=MC_PFL_IS_SCRIPTHASH;
+                                ptr=(unsigned char*)(lpScriptID);
+                            }
+                            fAdminFound=false;
+                            for (unsigned int i = 0; i < tx.vin.size(); i++)
                             {
-                                if( ( (type & (MC_PTP_ADMIN | MC_PTP_MINE)) == 0) || details->vInputCanGrantAdminMine[i] || (entity.GetEntityType() > 0) )
+                                if(vInputCanGrantAdminMine[i])
                                 {
-                                    details->fFullReplayCheckRequired=true;
-                                    if(mc_gState->m_Permissions->SetPermission(entity.GetTxID(),ptr,type,(unsigned char*)&(details->vInputDestinations[i]),
-                                            from,to,timestamp,flags,1,offset) == 0)
+                                    if(mc_gState->m_Permissions->SetPermission(NULL,ptr,type,(unsigned char*)&vInputDestinations[i],from,to,timestamp,flags,1,offset) == 0)
                                     {
                                         fAdminFound=true;
-                                    }
+                                    }                                
                                 }
-                                else
+                            }    
+                            if(!fAdminFound)
+                            {
+                                reason="Inputs don't belong to valid admin";
+                                fReject=true;
+                                goto exitlbl;                                                            
+                            }                                
+                            else
+                            {
+                                if(result)
                                 {
-                                    fAdminFoundWithoutCachedScript=true;                                                
-                                }
+                                    *result |= MC_PPL_ADMINMINERGRANT;
+                                }                                
                             }
                         }
+                        fIsEntity=false;
                     }
-                    
-                    if(!fAdminFound)
+                    else                                                   
                     {
-                        reason="Inputs don't belong to valid admin";
-                        if(fAdminFoundWithoutCachedScript)
+                        if(fIsEntity)                              
                         {
-                            reason="Inputs require scriptPubKey cache to support miner precheck";
+                            reason="Script rejected - entity script should be followed by permission";
+                            fReject=true;
+                            goto exitlbl;                                                
                         }
-                        return false;
                     }
-                }      
-                entity.Zero();                                                  // Entity element in the non-op-return output should be followed by permission element
-                                                                                // So only permission can reset it
-            }
-            else                                                                // Not permission script
-            {
-                if(entity.GetEntityType())                              
-                {
-                    reason="Script rejected - entity script should be followed by permission";
-                    return false;
                 }
-                fIsPurePermission=false;
-            }
+            }                                                                              
         }
-    }                                                               
-                
-    if(entity.GetEntityType())
+    }    
+    
+exitlbl:        
+    
+    if(fReject)
     {
-        reason="Script rejected - incomplete entity script";
-        return false;
+        if(fDebug)LogPrint("mchn","mchn: AcceptAdminMinerPermissions: Tx rejected: %s\n",EncodeHexTx(tx));
     }
-                
-    if(fFirstPass)
-    {
-        if(tx.vout[vout].nValue > 0)
-        {
-            fIsPurePermission=false;
-        }
 
-        if(!fIsPurePermission)
-        {
-            details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_NOT_PURE_PERMISSION;        
-        }
-        details->vOutputScriptFlags[vout] |= MC_MTX_OUTPUT_DETAIL_FLAG_NOT_OP_RETURN;        
-    }
-    
-    return true;
+    return !fReject;
 }
 
-bool MultiChainTransaction_CheckAssetTransfers(const CTransaction& tx,
-                                               int offset,  
-                                               int vout,
-                                               CMultiChainTxDetails *details,   
-                                               string& reason)      
+
+/**
+ * Used only for protocols < 10006
+ */
+
+bool AcceptAssetTransfers(const CTransaction& tx, const CCoinsViewCache &inputs, string& reason)
 {
-    int receive_required=details->vOutputPermissionRequired[vout];
+    unsigned char *ptrIn;
+    unsigned char *ptrOut;
+    int err;
+    int64_t quantity;
     
-    if(mc_gState->m_Features->PerAssetPermissions())                            // Checking per-asset receive permissions
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
     {
-        mc_gState->m_TmpAssetsTmp->Clear();
-        if(!mc_ExtractOutputAssetQuantities(mc_gState->m_TmpAssetsTmp,reason,true))   
-        {
-            return false;
-        }
-        if(!mc_VerifyAssetPermissions(mc_gState->m_TmpAssetsTmp,details->vOutputDestinations[vout],receive_required,MC_PTP_RECEIVE,reason))
-        {
-            return false;                                
-        }
-    }
-    
-    if(!mc_ExtractOutputAssetQuantities(mc_gState->m_TmpAssetsOut,reason,false))// Filling output asset quantity list
+        return true;
+    }    
+    if(tx.IsCoinBase())
     {
-        return false;                                
+        return true;
     }
-                                                                                // Check for dust and receive permissions
-                                                                                // Not required for pure grants
-    if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_NOT_PURE_PERMISSION)   
+    
+    mc_gState->m_TmpAssetsIn->Clear();
+    for (unsigned int i = 0; i < tx.vin.size(); i++)
     {
-        if((offset < 0) && Params().RequireStandard())                          // If not in block - part of IsStandard check
+        const COutPoint &prevout = tx.vin[i].prevout;
+        const CCoins *coins = inputs.AccessCoins(prevout.hash);
+        assert(coins);
+
+        mc_gState->m_TmpScript->Clear();
+        
+        const CScript& script1 = coins->vout[prevout.n].scriptPubKey;        
+        CScript::const_iterator pc1 = script1.begin();
+        
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+        
+        for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
         {
-            if (tx.vout[vout].IsDust(::minRelayTxFee))             
-            {
-                if(!tx.IsCoinBase())
-                {
-                    reason="Transaction amount too small";
-                    return false;                                
-                }                            
-            }
-        }
-        for(int a=0;a<(int)details->vOutputDestinations[vout].size();a++)
-        {                            
-            CKeyID *lpKeyID=boost::get<CKeyID> (&(details->vOutputDestinations[vout][a]));
-            CScriptID *lpScriptID=boost::get<CScriptID> (&(details->vOutputDestinations[vout][a]));
-            if((lpKeyID == NULL) && (lpScriptID == NULL))
+            mc_gState->m_TmpScript->SetElement(e);
+            err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsIn,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER | MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);
+            if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
             {
-                reason="Script rejected - wrong destination type";
+                reason="Asset transfer script rejected - error in script";
                 return false;                                
             }
-            unsigned char* ptr=NULL;
-            if(lpKeyID != NULL)
+            err=mc_gState->m_TmpScript->GetAssetGenesis(&quantity);
+            if(err == 0)
             {
-                ptr=(unsigned char*)(lpKeyID);
-            }
+                uint256 hash=prevout.hash;
+                mc_EntityDetails entity;
+                unsigned char buf_amounts[MC_AST_ASSET_FULLREF_BUF_SIZE];
+                memset(buf_amounts,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
+                if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&hash))
+                {
+                    if(entity.IsUnconfirmedGenesis())         // Not confirmed genesis has -1 in offset field
+                    {
+                        reason="Asset transfer script rejected - using unconfirmed issue";
+                        return false;                                
+                    }
+                    memcpy(buf_amounts,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
+                    int row=mc_gState->m_TmpAssetsIn->Seek(buf_amounts);
+                    if(row>=0)
+                    {
+                        int64_t last=mc_GetABQuantity(mc_gState->m_TmpAssetsIn->GetRow(row));
+                        quantity+=last;
+                        mc_SetABQuantity(mc_gState->m_TmpAssetsIn->GetRow(row),quantity);                        
+                    }
+                    else
+                    {
+                        mc_SetABQuantity(buf_amounts,quantity);
+                        mc_gState->m_TmpAssetsIn->Add(buf_amounts);
+                    }
+                }                
+                else
+                {
+                    reason="Asset transfer script rejected - issue tx not found";
+                    return false;                                
+                }                
+            }            
             else
             {
-                ptr=(unsigned char*)(lpScriptID);
-            }
-
-            bool fCanReceive=mc_gState->m_Permissions->CanReceive(NULL,ptr);
-            
-                                                                                // Miner can send funds to himself in coinbase even without receive permission
-                                                                                // It is relevant only for native currency as other assets will be unbalanced
-            if(tx.IsCoinBase())                                                 
-            {
-                fCanReceive |= mc_gState->m_Permissions->CanMine(NULL,ptr);
-            }
-            if(fCanReceive)                        
-            {
-                receive_required--;
-            }                                    
-        }
-        if(receive_required>0)
-        {
-            if( (tx.vout[vout].nValue > 0) || 
-                (mc_gState->m_TmpScript->GetNumElements() > 0) ||
-                (mc_gState->m_Features->AnyoneCanReceiveEmpty() == 0) )
-            {
-                reason="One of the outputs doesn't have receive permission";
-                return false;                                
+                if(err != MC_ERR_WRONG_SCRIPT)
+                {
+                    reason="Asset transfer script rejected - error in input issue script";
+                    return false;                                    
+                }
             }
         }
     }
 
-    return true;
-}
-
-bool MultiChainTransaction_CheckOutputs(const CTransaction& tx,                 // Tx to check
-                                        const CCoinsViewCache &inputs,          // Tx inputs from UTXO database
-                                        int offset,                             // Tx offset in block, -1 if in memppol
-                                        CMultiChainTxDetails *details,          // Tx details object
-                                        string& reason)                         // Error message
-{
-    uint32_t permission_type;
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)
-    {
-        details->vOutputScriptFlags.push_back(MC_MTX_OUTPUT_DETAIL_FLAG_NONE);
-    }
-    
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)                  // Basic checks, destinations and simple grants
+    mc_gState->m_TmpAssetsOut->Clear();
+    for (unsigned int j = 0; j < tx.vout.size(); j++)
     {
-        details->total_value_out+=tx.vout[vout].nValue;
+        mc_gState->m_TmpScript->Clear();
         
-        MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
+        const CScript& script1 = tx.vout[j].scriptPubKey;        
 
-        if(mc_gState->m_TmpScript->IsOpReturnScript())                    
+        CScript::const_iterator pc1 = script1.begin();
+        
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+        for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
         {
-            if(!MultiChainTransaction_CheckOpReturnScript(tx,inputs,vout,details,reason))
+            mc_gState->m_TmpScript->SetElement(e);
+            err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsOut,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER);
+            if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
             {
-                return false;
+                reason="Asset transfer script rejected - error in output transfer script";
+                return false;                                
             }
-        }
-        else
-        {
-            if(!MultiChainTransaction_CheckDestinations(tx.vout[vout].scriptPubKey,vout,details,reason))
+            if(err == MC_ERR_NOERROR)
             {
-                return false;
-            }            
-            
-            permission_type=MC_PTP_CONNECT | MC_PTP_SEND | MC_PTP_RECEIVE | MC_PTP_WRITE;
-            if(!MultiChainTransaction_ProcessPermissions(tx,offset,vout,permission_type,true,details,reason))
-            {
-                return false;
-            }            
+            }
         }
     }
     
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)                  // create, issue, activate grants (requiring pre-tx permissions)
+    if(fDebug)LogPrint("mchnminor","Found asset transfer script in tx %s, %d assets\n",
+            tx.GetHash().GetHex().c_str(),mc_gState->m_TmpAssetsOut->GetCount());                    
+    for(int i=0;i<mc_gState->m_TmpAssetsIn->GetCount();i++)
     {
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_CREATE)
+        ptrIn=mc_gState->m_TmpAssetsIn->GetRow(i);
+        int row=mc_gState->m_TmpAssetsOut->Seek(ptrIn);
+        quantity=mc_GetABQuantity(ptrIn);
+        if(quantity>0)
         {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-            
-            permission_type=MC_PTP_CREATE | MC_PTP_ISSUE | MC_PTP_ACTIVATE;
-            if(!MultiChainTransaction_ProcessPermissions(tx,offset,vout,permission_type,false,details,reason))
+            if(row>=0)
             {
-                return false;
-            }                        
-        }
-    }    
-
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)                  // mine, admin grants (requiring cached script) 
-    {
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_PERMISSION_ADMIN)
-        {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-            
-            permission_type=MC_PTP_MINE | MC_PTP_ADMIN;
-            if(!MultiChainTransaction_ProcessPermissions(tx,offset,vout,permission_type,false,details,reason))
+                ptrOut=mc_gState->m_TmpAssetsOut->GetRow(row);       
+                if(memcmp(ptrIn,ptrOut,MC_AST_ASSET_QUANTITY_OFFSET+MC_AST_ASSET_QUANTITY_SIZE))
+                {
+                    reason="Asset transfer script rejected - mismatch in input/output quantities";
+                    return false;                                                                    
+                }
+            }
+            else
             {
-                return false;
-            }            
+                reason="Asset transfer script rejected - mismatch in input/output quantities";
+                return false;                                                    
+            }
         }
-    }    
-
-    mc_gState->m_TmpAssetsOut->Clear();
+    }
     
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)
+    for(int i=0;i<mc_gState->m_TmpAssetsOut->GetCount();i++)
     {
-                                                                                // Entity items (stream items, upgrade approvals, updates)
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_OP_RETURN_ENTITY_ITEM)
+        ptrOut=mc_gState->m_TmpAssetsOut->GetRow(i);
+        int row=mc_gState->m_TmpAssetsIn->Seek(ptrOut);
+        quantity=mc_GetABQuantity(ptrOut);
+        if(quantity>0)
         {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-            
-            if(!MultiChainTransaction_CheckEntityItem(tx,offset,vout,details,reason))
+            if(row>=0)
             {
-                return false;                
+                ptrIn=mc_gState->m_TmpAssetsIn->GetRow(row);       
+                if(memcmp(ptrIn,ptrOut,MC_AST_ASSET_QUANTITY_OFFSET+MC_AST_ASSET_QUANTITY_SIZE))
+                {
+                    reason="Asset transfer script rejected - mismatch in input/output quantities";
+                    return false;                                                                    
+                }
             }
-        }        
-                                                                                // Assets quantities and permission checks
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_NOT_OP_RETURN)
-        {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-
-            if(!MultiChainTransaction_CheckAssetTransfers(tx,offset,vout,details,reason))
+            else
             {
-                return false;                
+                reason="Asset transfer script rejected - mismatch in input/output quantities";
+                return false;                                                    
             }
-        }        
-    }    
-    
-    if(!mc_CompareAssetQuantities(reason))                                      // Comparing input/output asset quantities
-    {
-        return false;                
-    }
-
-    return true;
-}
-
-int64_t MultiChainTransaction_OffchainFee(int64_t total_offchain_size)            // Total size of offchain items
-{
-    return (MIN_OFFCHAIN_FEE*total_offchain_size + 999)/ 1000;
-}
-
-bool MultiChainTransaction_CheckMandatoryFee(CMultiChainTxDetails *details,     // Tx details object
-                                             int64_t *mandatory_fee,            // Mandatory Fee    
-                                             string& reason)                    // Error message
-{
-    *mandatory_fee = MultiChainTransaction_OffchainFee(details->total_offchain_size);
-
-    if(*mandatory_fee)
-    {
-        if(details->total_value_in-details->total_value_out < *mandatory_fee)
-        {
-            reason="Insufficient mandatory fee";
-            return false;
         }
     }
     
     return true;
 }
 
+/**
+ * Used only for protocols < 10006
+ */
 
 
-bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,         // Tx to check
-                                                int offset,                     // Tx offset in block, -1 if in memppol
-                                                bool accept,                    // Accept to mempools if successful
-                                                CMultiChainTxDetails *details,  // Tx details object
-                                                string& reason)                 // Error message
-{
-    int update_mempool;
-    
-    
+bool AcceptAssetGenesis(const CTransaction &tx,int offset,bool accept,string& reason)
+{    
+    int update_mempool=0;
     mc_EntityDetails entity;
     mc_EntityDetails this_entity;
+    unsigned char details_script[MC_ENT_MAX_SCRIPT_SIZE];
     char asset_name[MC_ENT_MAX_NAME_SIZE+1];
     int multiple;
+    int details_script_size;
     int err;
     int64_t quantity,total;
     uint256 txid;
-    bool new_issue,follow_on,issue_in_output;
+    bool new_issue;
     unsigned char *ptrOut;
     vector <uint160> issuers;
-    vector <uint32_t> issuer_flags;
-    uint32_t flags;
-    uint32_t value_offset;
-    size_t value_size;
-    unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-    CTxDestination addressRet;
-   
+    
+    
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
+    {
+        return true;
+    }    
     if(tx.IsCoinBase())
     {
         return true;
     }
     
-    update_mempool=0;
     if(accept)
     {
         update_mempool=1;
@@ -1440,82 +2441,66 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
     asset_name[0]=0;
     multiple=1;
     new_issue=false;
-    follow_on=false;
+    mc_gState->m_TmpAssetsOut->Clear();
     
-    if(details->details_script_type == 0)                                       // New asset with details script
+    details_script_size=0;
+    for (unsigned int j = 0; j < tx.vout.size(); j++)
     {
-        value_offset=mc_FindSpecialParamInDetailsScript(details->details_script,details->details_script_size,MC_ENT_SPRM_NAME,&value_size);
-        if(value_offset<(uint32_t)details->details_script_size)
+        mc_gState->m_TmpScript->Clear();
+        
+        const CScript& script1 = tx.vout[j].scriptPubKey;        
+        CScript::const_iterator pc1 = script1.begin();
+        
+        CTxDestination addressRet;
+        
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
+        
+        if(mc_gState->m_TmpScript->IsOpReturnScript())
         {
-            if(value_size > MC_ENT_MAX_NAME_SIZE)
+            int e=mc_gState->m_TmpScript->GetNumElements()-1;
+            if(e != 0)
             {
-                if(mc_gState->m_Features->FixedIn1001120003())
-                {
-                    reason="Metadata script rejected - entity name too long";
-                    return false;                    
-                }
-                value_size=MC_ENT_MAX_NAME_SIZE;
+                reason="Asset details script rejected - error in script, too many script elements";
+                return false;                                                    
             }
-            
-            memcpy(asset_name,details->details_script+value_offset,value_size);
-            asset_name[value_size]=0x00;
-        }
-        value_offset=mc_FindSpecialParamInDetailsScript(details->details_script,details->details_script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size);
-        if(value_offset<(uint32_t)details->details_script_size)
-        {
-            multiple=mc_GetLE(details->details_script+value_offset,value_size);
-        }                                    
-    }
-
-    mc_gState->m_TmpAssetsOut->Clear();
-
-    for (unsigned int vout = 0; vout < tx.vout.size(); vout++)
-    {
-                                                                                // We already extracted the details, we just have to find entity
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_FOLLOWON_DETAILS)
-        {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-            mc_gState->m_TmpScript->SetElement(0);
-                                                                        
-            if(mc_gState->m_TmpScript->GetEntity(short_txid))           
             {
-                reason="Metadata script rejected - wrong element, should be entityref";
-                return false;
+                mc_gState->m_TmpScript->SetElement(e);
+                err=mc_gState->m_TmpScript->GetAssetDetails(asset_name,&multiple,details_script,&details_script_size);
+                if(err)
+                {
+                    if(err != MC_ERR_WRONG_SCRIPT)
+                    {
+                        reason="Asset details script rejected - error in script";
+                        return false;                                    
+                    }
+                    details_script_size=0;
+                }
+                
             }
-            
         }
-        
-        if(details->vOutputScriptFlags[vout] & MC_MTX_OUTPUT_DETAIL_FLAG_NOT_OP_RETURN)
+        else
         {
-            MultiChainTransaction_SetTmpOutputScript(tx.vout[vout].scriptPubKey);
-
-            mc_gState->m_TmpAssetsTmp->Clear();
-            issue_in_output=false;
-            
             for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
             {
                 mc_gState->m_TmpScript->SetElement(e);
-                err=mc_gState->m_TmpScript->GetAssetGenesis(&quantity);         
-                if(err == 0)                                                    // Asset genesis issuance 
+                err=mc_gState->m_TmpScript->GetAssetGenesis(&quantity);
+                if(err == 0)
                 {
-                    issue_in_output=true;
                     new_issue=true;
                     if(quantity+total<0)
                     {
-                        reason="Asset issue script rejected - overflow";
+                        reason="Asset issue script rejected - negative total amount";
                         return false;                                        
                     }
                                         
                     total+=quantity;
                     
-                    if(details->vOutputDestinations[vout].size() != 1)
+                    if(!ExtractDestination(script1, addressRet))
                     {
                         reason="Asset issue script rejected - wrong destination type";
                         return false;                
                     }
                     
-                    addressRet=details->vOutputDestinations[vout][0];
-                    
                     CKeyID *lpKeyID=boost::get<CKeyID> (&addressRet);
                     CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
                     if((lpKeyID == NULL) && (lpScriptID == NULL))
@@ -1546,16 +2531,6 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
                         reason="Asset issue script rejected - error in script";
                         return false;                                    
                     }
-                    if(mc_gState->m_Features->PerAssetPermissions())
-                    {
-                        err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsTmp,MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER);
-                        if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
-                        {
-                            reason="Script rejected - error in asset transfer script";
-                            return false;                                
-                        }
-                    }                    
-
                     err=mc_gState->m_TmpScript->GetAssetQuantities(mc_gState->m_TmpAssetsOut,MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);
                     if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
                     {
@@ -1571,44 +2546,13 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
                         }
                     }
                 }                
-            }        
-            if(issue_in_output)
-            {
-                if(mc_gState->m_Features->PerAssetPermissions())
-                {
-                    if(mc_gState->m_TmpAssetsTmp->GetCount())
-                    {
-                        reason="Asset issue script rejected - asset transfer in script";
-                        return false;                                    
-                    }                    
-                }
-            }            
-        }        
-    }    
-
-    if(details->details_script_type >= 0)
-    {
-        if(details->details_script_type)                                        // Updates are allowed only for assets
-        {
-            follow_on=true;            
-        }
-        else
-        {
-            if(details->new_entity_type == MC_ENT_TYPE_ASSET)                   // If not - we'll deal with it later
-            {
-                new_issue=true;
             }
+        
         }
-    }
-    
+    }    
+
     if(mc_gState->m_TmpAssetsOut->GetCount())
     {
-        follow_on=true;
-    }   
-    
-    if(follow_on)
-    {
-        total=0;
         if(mc_gState->m_TmpAssetsOut->GetCount() > 1)
         {
             reason="Asset follow-on script rejected - follow-on for several assets";
@@ -1619,101 +2563,69 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
             reason="Asset follow-on script rejected - follow-on and issue in one transaction";
             return false;                                                            
         }
-        ptrOut=NULL;
-        if(mc_gState->m_TmpAssetsOut->GetCount() == 0)
-        {
-            if(mc_gState->m_Assets->FindEntityByShortTxID(&entity,short_txid) == 0)
-            {
-                reason="Details script rejected - entity not found";
-                return false;                                    
-            }                                           
-        }
-        else
-        {
-            ptrOut=mc_gState->m_TmpAssetsOut->GetRow(0);       
-            if(mc_gState->m_Assets->FindEntityByFullRef(&entity,ptrOut) == 0)
-            {
-                reason="Asset follow-on script rejected - asset not found";
-                return false;                                                                        
-            }            
-        }
-        
-        if(entity.AllowedFollowOns() == 0)
-        {
-            reason="Asset follow-on script rejected - follow-ons not allowed for this asset";
-            return false;                                                                                    
-        }
-        if(details->details_script_type > 0)
-        {
-            if(memcmp(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,short_txid,MC_AST_SHORT_TXID_SIZE))
-            {
-                reason="Asset follow-on script rejected - mismatch in follow-on quantity asset and details script";
-                return false;                                                                                                    
-            }
-        }
-        if(ptrOut)
+        ptrOut=mc_gState->m_TmpAssetsOut->GetRow(0);       
+        if(mc_gState->m_Assets->FindEntityByRef(&entity,ptrOut) == 0)
         {
-            total=mc_GetABQuantity(ptrOut);
-            if(total+mc_gState->m_Assets->GetTotalQuantity(&entity) < 0)
-            {
-                reason="Asset follow-on script rejected - exceeds maximal value for asset";
-                return false;                                                                                                                
-            }
+            reason="Asset follow-on script rejected - asset not found";
+            return false;                                                                        
+        }
+        if(entity.AllowedFollowOns() == 0)
+        {
+            reason="Asset follow-on script rejected - follow-ons not allowed for this asset";
+            return false;                                                                                    
         }
+        total=mc_GetABQuantity(ptrOut);
     }
     
-    if(!new_issue && !follow_on)
+    if(!new_issue && (mc_gState->m_TmpAssetsOut->GetCount() == 0))
     {
         return true;
     }
     
-    if(details->new_entity_output >= 0)
-    {
-        if(details->new_entity_type != MC_ENT_TYPE_ASSET)
-        {
-            reason="Asset issue script rejected - not allowed in this transaction, conflicts with other entities";
-            return false;                                                                                                        
-        }
-    }
-    
-    details->fFullReplayCheckRequired=true;
-    
-    issuers.clear();                                                            // Creating issuers list
+    issuers.clear();
     for (unsigned int i = 0; i < tx.vin.size(); i++)
     {
-        if(details->vInputHashTypes[i] == SIGHASH_ALL)
+        const CScript& script2 = tx.vin[i].scriptSig;        
+        CScript::const_iterator pc2 = script2.begin();
+
+        mc_gState->m_TmpScript->Clear();
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTSIG);
+
+        if(mc_gState->m_TmpScript->GetNumElements() == 2)
         {
-            if(details->vInputDestinations[i] != 0)
+            size_t elem_size;
+            const unsigned char *elem;
+
+            elem = mc_gState->m_TmpScript->GetData(0,&elem_size);
+
+            if(elem_size > 1)                                                   // If this is multisig with one signature it should be OP_0
             {
-                bool can_issue=false;
-                if(new_issue)
-                {
-                    if(mc_gState->m_Permissions->CanIssue(NULL,(unsigned char*)&(details->vInputDestinations[i])))
-                    {                            
-                        can_issue=true;
-                    }                            
-                }
-                else
+                unsigned char hash_type=elem[elem_size-1] & 0x1f;
+
+                if(hash_type == SIGHASH_ALL)
                 {
-                    if(mc_gState->m_Permissions->CanIssue(entity.GetTxID(),(unsigned char*)&(details->vInputDestinations[i])))
+                    elem = mc_gState->m_TmpScript->GetData(1,&elem_size);
+                    const unsigned char *pubkey_hash=(unsigned char *)Hash160(elem,elem+elem_size).begin();
+
+                    if(new_issue)
                     {
-                        can_issue=true;
-                    }                                                        
-                }                
-                if(can_issue)
-                {
-                    issuers.push_back(details->vInputDestinations[i]);
-                    flags=MC_PFL_NONE;
-                    if(details->vInputScriptTypes[i] == TX_SCRIPTHASH)
+                        if(mc_gState->m_Permissions->CanIssue(NULL,pubkey_hash))
+                        {                            
+                            issuers.push_back(Hash160(elem,elem+elem_size));
+                        }                            
+                    }
+                    else
                     {
-                        flags |= MC_PFL_IS_SCRIPTHASH;
+                        if(mc_gState->m_Permissions->CanIssue(entity.GetTxID(),pubkey_hash))
+                        {
+                            issuers.push_back(Hash160(elem,elem+elem_size));
+                        }                                                        
                     }
-                    issuer_flags.push_back(flags);                        
                 }
             }
         }
-    }        
-
+    }            
+    
     if(issuers.size() == 0)
     {
         reason="Inputs don't belong to valid issuer";
@@ -1724,16 +2636,15 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
     
     mc_gState->m_TmpScript->Clear();
     mc_gState->m_TmpScript->AddElement();
-    unsigned char issuer_buf[24];
+    unsigned char issuer_buf[20];
     memset(issuer_buf,0,sizeof(issuer_buf));
-    flags=MC_PFL_NONE;        
+    uint32_t flags=MC_PFL_NONE;        
     uint32_t timestamp=0;
     set <uint160> stored_issuers;
 
-                                                                                // First per-entity record in permission database
-                                                                                // We'll need it for scanning asset-related rows
-    if(new_issue)                                                               
+    if(new_issue)
     {
+        mc_gState->m_Permissions->SetCheckPoint();
         err=MC_ERR_NOERROR;
 
         txid=tx.GetHash();
@@ -1741,27 +2652,20 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
                 (unsigned char*)issuers[0].begin(),0,(uint32_t)(-1),timestamp,flags | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
     }
 
-    uint32_t all_permissions=MC_PTP_ADMIN | MC_PTP_ISSUE;
-    if(mc_gState->m_Features->PerAssetPermissions())
-    {
-        all_permissions |= MC_PTP_ACTIVATE | MC_PTP_SEND | MC_PTP_RECEIVE;
-    }
-    
-    for (unsigned int i = 0; i < issuers.size(); i++)                           // Setting per-asset permissions and creating issuers script
+    for (unsigned int i = 0; i < issuers.size(); i++)
     {
         if(err == MC_ERR_NOERROR)
         {
             if(stored_issuers.count(issuers[i]) == 0)
             {
                 memcpy(issuer_buf,issuers[i].begin(),sizeof(uint160));
-                mc_PutLE(issuer_buf+sizeof(uint160),&issuer_flags[i],4);
-                if((int)i < mc_gState->m_Assets->MaxStoredIssuers())            // Adding list of issuers to the asset script
+                if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
                 {
                     mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,sizeof(issuer_buf));            
                 }
-                if(new_issue)                                                   // Setting first permission record - to scan from
-                {                    
-                    err=mc_gState->m_Permissions->SetPermission(&txid,issuer_buf,all_permissions,
+                if(new_issue)
+                {
+                    err=mc_gState->m_Permissions->SetPermission(&txid,issuer_buf,MC_PTP_ADMIN | MC_PTP_ISSUE,
                             (unsigned char*)issuers[0].begin(),0,(uint32_t)(-1),timestamp,flags | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
                 }
                 stored_issuers.insert(issuers[i]);
@@ -1771,6 +2675,13 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
 
     memset(issuer_buf,0,sizeof(issuer_buf));
     mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,issuer_buf,1);                    
+    if(new_issue)
+    {
+        if((err != MC_ERR_NOERROR) || !accept)
+        {
+            mc_gState->m_Permissions->RollBackToCheckPoint();            
+        }
+    }
     if(err)
     {
         reason="Cannot update permission database for issued asset";
@@ -1781,13 +2692,13 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
     size_t special_script_size=0;
     special_script=mc_gState->m_TmpScript->GetData(0,&special_script_size);
     txid=tx.GetHash();
-    if(new_issue)                                                               // Updating entity database
+    if(new_issue)
     {        
-        err=mc_gState->m_Assets->InsertAsset(&txid,offset,total,asset_name,multiple,details->details_script,details->details_script_size,special_script,special_script_size,update_mempool);                      
+        err=mc_gState->m_Assets->InsertAsset(&txid,offset,total,asset_name,multiple,details_script,details_script_size,special_script,special_script_size,update_mempool);                      
     }
     else
     {
-        err=mc_gState->m_Assets->InsertAssetFollowOn(&txid,offset,total,details->details_script,details->details_script_size,special_script,special_script_size,entity.GetTxID(),update_mempool);
+        err=mc_gState->m_Assets->InsertAssetFollowOn(&txid,offset,total,details_script,details_script_size,special_script,special_script_size,entity.GetTxID(),update_mempool);
     }
             
     if(err)           
@@ -1795,7 +2706,7 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
         reason="Asset issue script rejected - could not insert new asset to database";
         if(err == MC_ERR_FOUND)
         {
-            reason="Asset issue script rejected - entity with this name/asset-ref/txid already exists";                        
+            reason="Asset issue script rejected - asset with such name/asset-ref/txid already exists";                        
             if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&txid) == 0)
             {
                 if(strlen(asset_name) == 0)
@@ -1842,549 +2753,395 @@ bool MultiChainTransaction_ProcessAssetIssuance(const CTransaction& tx,
         }
     }
     
-    return true;    
-}
-
-
-bool MultiChainTransaction_ProcessEntityCreation(const CTransaction& tx,        // Tx to check
-                                                 int offset,                    // Tx offset in block, -1 if in memppol
-                                                 bool accept,                   // Accept to mempools if successful
-                                                 CMultiChainTxDetails *details, // Tx details object
-                                                 string& reason)                // Error message
-{
-    if(details->new_entity_output < 0)
-    {
-        return true;
-    }
-    
-    if(details->new_entity_type == MC_ENT_TYPE_ASSET)                           // Processed in another place
-    {
-        return true;        
-    }
-    
-    vector <uint160> openers;
-    vector <uint32_t> opener_flags;
-    unsigned char opener_buf[24];
-
-    int err;
-    string entity_type_str;
-    uint32_t flags=MC_PFL_NONE;        
-    uint32_t timestamp=0;
-    set <uint160> stored_openers;
-    int update_mempool;
-    uint256 txid;
-    mc_EntityDetails entity;
-        
-    details->fFullReplayCheckRequired=true;
-        
-    update_mempool=0;
-    if(accept)
-    {
-        update_mempool=1;            
-    }
-        
-    openers.clear();                                                            // List of openers
-    opener_flags.clear();
-    for (unsigned int i = 0; i < tx.vin.size(); i++)
-    {
-        if(details->IsRelevantInput(i,details->new_entity_output))
-        {
-            if(mc_gState->m_Permissions->CanCreate(NULL,(unsigned char*)&(details->vInputDestinations[i])))
-            {                            
-                if( (details->new_entity_type != MC_ENT_TYPE_UPGRADE) || (mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&(details->vInputDestinations[i])) != 0) )
-                {
-                    openers.push_back(details->vInputDestinations[i]);
-                    flags=MC_PFL_NONE;
-                    if(details->vInputScriptTypes[i] == TX_SCRIPTHASH)
-                    {
-                        flags |= MC_PFL_IS_SCRIPTHASH;
-                    }
-                    opener_flags.push_back(flags);
-                }
-            }                            
-        }
-    }                
-        
-    if(openers.size() == 0)
-    {
-        reason="Metadata script rejected - Inputs don't belong to valid creator";
-        return false;
-    }
-
-    err=MC_ERR_NOERROR;
-
-    mc_gState->m_TmpScript->Clear();
-    mc_gState->m_TmpScript->AddElement();
-    txid=tx.GetHash();                                                          // Setting first record in the per-entity permissions list
-
-    if(details->new_entity_type != MC_ENT_TYPE_UPGRADE)
-    {
-        memset(opener_buf,0,sizeof(opener_buf));
-        err=mc_gState->m_Permissions->SetPermission(&txid,opener_buf,MC_PTP_CONNECT,
-                (unsigned char*)openers[0].begin(),0,(uint32_t)(-1),timestamp, MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
-    }
-
-    for (unsigned int i = 0; i < openers.size(); i++)
-    {
-        if(err == MC_ERR_NOERROR)
-        {
-            if(stored_openers.count(openers[i]) == 0)
-            {
-                memcpy(opener_buf,openers[i].begin(),sizeof(uint160));
-                mc_PutLE(opener_buf+sizeof(uint160),&opener_flags[i],4);
-                if((int)i < mc_gState->m_Assets->MaxStoredIssuers())
-                {
-                    mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,sizeof(opener_buf));            
-                }
-                if(details->new_entity_type != MC_ENT_TYPE_UPGRADE)
-                {
-                                                                                // Granting default per-entity permissions to openers
-                    err=mc_gState->m_Permissions->SetPermission(&txid,opener_buf,MC_PTP_ADMIN | MC_PTP_ACTIVATE | MC_PTP_WRITE,
-                            (unsigned char*)openers[i].begin(),0,(uint32_t)(-1),timestamp,opener_flags[i] | MC_PFL_ENTITY_GENESIS ,update_mempool,offset);
-                }
-                stored_openers.insert(openers[i]);
-            }
-        }
-    }        
-    
-    if(err)
-    {
-        reason=" Cannot update permission database for new entity";
-        return false;
-    }
-
-    memset(opener_buf,0,sizeof(opener_buf));                                    // Storing opener list in entity metadata
-    mc_gState->m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ISSUER,opener_buf,1);                    
-
-    const unsigned char *special_script;
-    size_t special_script_size=0;
-    special_script=mc_gState->m_TmpScript->GetData(0,&special_script_size);
-                                                                                // Updating entity datanase
-    err=mc_gState->m_Assets->InsertEntity(&txid,offset,details->new_entity_type,details->details_script,details->details_script_size,special_script,special_script_size,update_mempool);
-    if(err)           
-    {
-        reason="New entity script rejected - could not insert new entity to database";
-        if(err == MC_ERR_ERROR_IN_SCRIPT)
-        {
-            reason="New entity script rejected - error in script";                        
-        }
-        if(err == MC_ERR_FOUND)
-        {
-            reason="New entity script rejected - entity with this name already exists";                        
-        }
-        return false;
-    }
-
-    if(update_mempool)
-    {
-        if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&txid))
-        {
-            entity_type_str="stream";
-            if(details->new_entity_type == MC_ENT_TYPE_UPGRADE)
-            {
-                entity_type_str="upgrade";
-            }
-            if(offset>=0)
-            {
-                LogPrintf("New %s. TxID: %s, StreamRef: %d-%d-%d, Name: %s\n",
-                        entity_type_str.c_str(),tx.GetHash().GetHex().c_str(),
-                        mc_gState->m_Assets->m_Block+1,offset,(int)(*((unsigned char*)&txid+0))+256*(int)(*((unsigned char*)&txid+1)),
-                        entity.GetName());                                        
-            }
-            else
-            {
-                LogPrintf("New %s. TxID: %s, unconfirmed, Name: %s\n",
-                        entity_type_str.c_str(),tx.GetHash().GetHex().c_str(),entity.GetName());                                                            
-            }
-        }
-        else
-        {
-            reason="New entity script rejected - could not insert new entity to database";
-            return false;
-        }
-    }
-    
     return true;
 }
 
-bool AcceptMultiChainTransaction   (const CTransaction& tx,                     // Tx to check
-                                    const CCoinsViewCache &inputs,              // Tx inputs from UTXO database
-                                    int offset,                                 // Tx offset in block, -1 if in memppol
-                                    bool accept,                                // Accept to mempools if successful
-                                    string& reason,                             // Error message
-                                    int64_t *mandatory_fee_out,                 // Mandatory fee
-                                    uint32_t *replay)                           // Replay flag - if tx should be rechecked or only permissions
-{
-    CMultiChainTxDetails details;
-    bool fReject=false;
-    int64_t mandatory_fee=0;
-            
-    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)                 
-    {
-        return true;
-    }    
-    
-    details.fCheckCachedScript=MultiChainTransaction_CheckCachedScriptFlag(tx);
-    
-    mc_gState->m_TmpAssetsIn->Clear();
-    
-    if(!MultiChainTransaction_CheckCoinbaseInputs(tx,&details))                 // Inputs
-    {
-        if(!MultiChainTransaction_CheckInputs(tx,inputs,&details,reason))
-        {
-            return false;
-        }
-    }
-   
-    mc_gState->m_Permissions->SetCheckPoint();                                  // if there is an error after this point or it is just check, permission mempool should be restored
-
-    if(!MultiChainTransaction_CheckOutputs(tx,inputs,offset,&details,reason))   // Outputs        
-    {
-        fReject=true;
-        goto exitlbl;                                                                    
-    }
-
-    if(!MultiChainTransaction_CheckMandatoryFee(&details,&mandatory_fee,reason))
-    {
-        fReject=true;
-        goto exitlbl;                                                                            
-    }
-                                                                                // Asset genesis/followon
-    if(!MultiChainTransaction_ProcessAssetIssuance(tx,offset,accept,&details,reason))           
-    {
-        fReject=true;
-        goto exitlbl;                                                                    
-    }
-
-                                                                                // Creating of (pseudo)streams/upgrades
-    if(!MultiChainTransaction_ProcessEntityCreation(tx,offset,accept,&details,reason))           
-    {
-        fReject=true;
-        goto exitlbl;                                                                    
-    }
-
-                                                                                // Custom filters
-    fReject=!custom_accept_transacton(tx,inputs,offset,accept,reason,replay);
-    
-exitlbl:
-                                    
-    if(accept)
-    {
-        if(details.fSeedNodeInvolved)                                           // Checking if we should disconnect from seed node
-        {
-            CNode* seed_node;
-            seed_node=(CNode*)(mc_gState->m_pSeedNode);
-
-            if(!mc_gState->m_Permissions->CanConnect(NULL,seed_node->kAddrRemote.begin()))
-            {
-                LogPrintf("mchn: Seed node lost connect permission \n");
-                mc_gState->m_pSeedNode=NULL;
-            }
-        }
-    }
-
-    if(!accept || fReject)                                                      // Rolling back permission database if we were just checking or error occurred    
-    {
-        mc_gState->m_Permissions->RollBackToCheckPoint();
-    }
-
-    if(mandatory_fee_out)
-    {
-        *mandatory_fee_out=mandatory_fee;
-    }
-
-    if(replay)
-    {
-        *replay=0;
-        if(details.fFullReplayCheckRequired)
-        {
-            *replay |= MC_PPL_REPLAY;
-        }
-        if(details.fAdminMinerGrant)
-        {
-            *replay |= MC_PPL_ADMINMINERGRANT;
-        }
-    }
-
-    if(fReject)
-    {
-        if(fDebug)LogPrint("mchn","mchn: Tx rejected (%s): %s\n",reason.c_str(),EncodeHexTx(tx));
-    }
-
-    return !fReject;
-    
-}
-
-bool AcceptAdminMinerPermissions(const CTransaction& tx,
-                                 int offset,
-                                 bool verify_signatures,
-                                 string& reason,
-                                 uint32_t *result)
-{
-    vector <txnouttype> vInputScriptTypes;
-    vector <uint160> vInputDestinations;
-    vector <int> vInputHashTypes;
-    vector <bool> vInputCanGrantAdminMine;
-    vector <bool> vInputHadAdminPermissionBeforeThisTx;
-    vector <CScript> vInputPrevOutputScripts;
-    bool fIsEntity;
-    bool fReject;    
-    bool fAdminFound;
-    int err;
+/**
+ * Used only for protocols < 10006
+ */
 
-    if(result)
-    {
-        *result=0;
-    }
+bool AcceptPermissionsAndCheckForDust(const CTransaction &tx,bool accept,string& reason)
+{    
+    uint32_t type,from,to,timestamp,flags;
+    int receive_required;
+    bool is_op_return;
+    bool is_pure_permission;
+    bool seed_node_involved;
+    bool reject;
+    bool sighashall_found;
+    int pass;
+    mc_Script *lpInputScript=NULL;    
     
-    if(tx.IsCoinBase())
+    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
     {
         return true;
-    }
-    
-    for (unsigned int i = 0; i < tx.vin.size(); i++)                            
-    {                                                                                                                                                                
-        vInputCanGrantAdminMine.push_back(false);
-        vInputPrevOutputScripts.push_back(CScript());
-        vInputDestinations.push_back(0);
-    }
+    }    
     
-    fReject=false;
-    fAdminFound=false;
-    for (unsigned int j = 0; j < tx.vout.size(); j++)
+    sighashall_found=false;
+    
+    std::vector <int> admin_outputs;
+    admin_outputs.resize(tx.vin.size());
+    for (unsigned int i = 0; i < tx.vin.size(); i++)
     {
-        int cs_offset,cs_new_offset,cs_size,cs_vin;
-        unsigned char *cs_script;
-            
-        const CScript& script1 = tx.vout[j].scriptPubKey;        
-        CScript::const_iterator pc1 = script1.begin();
-
+        const CScript& script2 = tx.vin[i].scriptSig;        
+        CScript::const_iterator pc2 = script2.begin();
 
         mc_gState->m_TmpScript->Clear();
-        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-                       
-        if(mc_gState->m_TmpScript->IsOpReturnScript())                      
-        {                
-            if( mc_gState->m_TmpScript->GetNumElements() == 2 ) 
+        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTSIG);
+
+        admin_outputs[i]=tx.vout.size();
+        if(tx.IsCoinBase())
+        {
+            admin_outputs[i]=-1;
+        }
+        else
+        {
+            bool is_pay_to_pubkeyhash=false;
+            if(mc_gState->m_TmpScript->GetNumElements() == 2)
             {
-                mc_gState->m_TmpScript->SetElement(0);
-                                                  
-                cs_offset=0;
-                while( (err=mc_gState->m_TmpScript->GetCachedScript(cs_offset,&cs_new_offset,&cs_vin,&cs_script,&cs_size)) != MC_ERR_WRONG_SCRIPT )
+                size_t elem_size;
+                const unsigned char *elem;
+                unsigned char hash_type;
+
+                elem = mc_gState->m_TmpScript->GetData(0,&elem_size);
+                
+                if(elem_size > 1)
                 {
-                    if(err != MC_ERR_NOERROR)
+                    is_pay_to_pubkeyhash=true;
+                    hash_type=elem[elem_size-1] & 0x1f;
+
+                    if(hash_type == SIGHASH_ALL)
                     {
-                        reason="Metadata script rejected - error in cached script";
-                        fReject=true;
-                        goto exitlbl;                                                                                                                            
+                        admin_outputs[i]=-1;
+                        sighashall_found=true;
                     }
-                    if(cs_offset)
+                    else
                     {
-                        if( cs_vin >= (int)tx.vin.size() )
+                        if(hash_type == SIGHASH_SINGLE)
                         {
-                            reason="Metadata script rejected - invalid input in cached script";
-                            fReject=true;
-                            goto exitlbl;                                                                                                                                                                
+                            admin_outputs[i]=i;
+                        }                    
+                        else
+                        {                        
+                            reason="Permission script rejected - invalid signature hash type";
+                            return false;
                         }
-                        vInputPrevOutputScripts[cs_vin]=CScript(cs_script,cs_script+cs_size);                            
-                        vInputCanGrantAdminMine[cs_vin]=true;
-                    }
-                    cs_offset=cs_new_offset;
+                    }                
                 }
             }
-        }
-    }
-    
-    for (unsigned int i = 0; i < tx.vin.size(); i++)        
-    {                                                                                                                                                                
-        if(vInputCanGrantAdminMine[i])
-        {
-            vInputCanGrantAdminMine[i]=false;
-            const CScript& script2 = tx.vin[i].scriptSig;        
-            CScript::const_iterator pc2 = script2.begin();
-            if (!script2.IsPushOnly())
-            {
-                reason="sigScript should be push-only";
-                fReject=true;
-                goto exitlbl;                                                                                                                                                                
-            }
-
-            const CScript& script1 = vInputPrevOutputScripts[i];        
-            CScript::const_iterator pc1 = script1.begin();
-
-            txnouttype typeRet;
-            int nRequiredRet;
-            vector<CTxDestination> addressRets;
-            int op_addr_offset,op_addr_size,is_redeem_script,sighash_type,check_last;
-
-            sighash_type=SIGHASH_NONE;
-            if(ExtractDestinations(script1,typeRet,addressRets,nRequiredRet)) 
+            if(!is_pay_to_pubkeyhash)
             {
-                if ( (typeRet != TX_NULL_DATA) && (typeRet != TX_MULTISIG) )                                  
+                int first_sig=1;
+                int this_sig;
+                if(mc_gState->m_TmpScript->GetNumElements() == 1)              // pay to pubkey
                 {
-                    CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
-                    CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
-                    if( (lpKeyID == NULL) && (lpScriptID == NULL) )
-                    {
-                        fReject=true;
-                        goto exitlbl;                                                                                                                                                                
-                    }
-                    if(lpKeyID)
-                    {
-                        vInputDestinations[i]=*(uint160*)lpKeyID;                               
-                    }
-                    if(lpScriptID)
-                    {
-                        vInputDestinations[i]=*(uint160*)lpScriptID;                               
-                    }
-                    
-                    check_last=0;
-                    if( typeRet == TX_PUBKEY )
-                    {
-                        check_last=1;
-                    }
+                    first_sig=0;
+                }
+                this_sig=first_sig;
+                while(this_sig<mc_gState->m_TmpScript->GetNumElements())
+                {
+                    size_t elem_size;
+                    const unsigned char *elem;
+                    unsigned char hash_type;
 
-                                                                                // Find sighash_type
-                    mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,check_last);        
-                    if(sighash_type == SIGHASH_ALL)
+                    elem = mc_gState->m_TmpScript->GetData(this_sig,&elem_size);
+                    if(elem_size > 1)
                     {
-                        if(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)&vInputDestinations[i]))
+                        hash_type=elem[elem_size-1] & 0x1f;
+
+                        if(hash_type == SIGHASH_ALL)
                         {
-                            vInputCanGrantAdminMine[i]=true;
-                            if(verify_signatures)
-                            {
-                                vInputCanGrantAdminMine[i]=false;
-                                if(VerifyScript(script2, script1, STANDARD_SCRIPT_VERIFY_FLAGS, CachingTransactionSignatureChecker(&tx, i, false)))
-                                {
-                                    vInputCanGrantAdminMine[i]=true;
-                                }
-                                else
-                                {
-                                    reason="Signature verification error";
-                                    fReject=true;
-                                    goto exitlbl;                                                                                                                                                                                                    
-                                }
-                            }
-                        } 
+                            sighashall_found=true;
+                        }                    
+                        this_sig++;
+                    }
+                    else                                                        // First element of redeemScript
+                    {
+                        this_sig=mc_gState->m_TmpScript->GetNumElements();
                     }
                 }
-            }    
-        }        
-    }    
+            }
+        }
+    }            
     
-    for (unsigned int j = 0; j < tx.vout.size(); j++)
+    reject=false;
+    seed_node_involved=false;
+    mc_gState->m_Permissions->SetCheckPoint();
+    
+    lpInputScript=new mc_Script;
+    
+    for(pass=0;pass<3;pass++)
     {
-        unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-        uint32_t type,from,to,timestamp,flags;
-            
-        const CScript& script1 = tx.vout[j].scriptPubKey;        
-        CScript::const_iterator pc1 = script1.begin();
+        for (unsigned int j = 0; j < tx.vout.size(); j++)
+        {
+            mc_gState->m_TmpScript->Clear();
 
+            const CScript& script1 = tx.vout[j].scriptPubKey;        
+            CScript::const_iterator pc1 = script1.begin();
 
-        mc_gState->m_TmpScript->Clear();
-        mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-        
-        CTxDestination addressRet;
+            CTxDestination addressRet;
 
-        if(ExtractDestination(script1,addressRet))
-        {            
-            fIsEntity=false;
+            mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
 
-            for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
+            is_op_return=false;
+            if(mc_gState->m_TmpScript->IsOpReturnScript())
             {
-                mc_gState->m_TmpScript->SetElement(e);
-                if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)      
+                is_op_return=true;
+                if(!sighashall_found)
                 {
-                    if(fIsEntity)
+                    if(!tx.IsCoinBase())
                     {
-                        reason="Script rejected - duplicate entity script";
-                        fReject=true;
-                        goto exitlbl;                                                
+                        reason="Tx with metadata should have at least one SIGHASH_ALL output";
+                        reject=true;
+                        goto exitlbl;                    
                     }
-                    if(mc_gState->m_Features->FixedIn1000920001())
+                }
+            }
+            else
+            {
+                txnouttype typeRet;
+                int nRequiredRet;
+                vector<CTxDestination> addressRets;
+
+                if(!ExtractDestinations(script1,typeRet,addressRets,nRequiredRet))
+                {
+                    reason="Script rejected - wrong destination type";
+                    reject=true;
+                    goto exitlbl;
+                }            
+
+                if((typeRet == TX_MULTISIG) && (MCP_ALLOW_MULTISIG_OUTPUTS == 0))
+                {
+                    reason="Script rejected - multisig is not allowed";
+                    reject=true;
+                    goto exitlbl;                    
+                }
+                
+                if((typeRet == TX_SCRIPTHASH) && (MCP_ALLOW_P2SH_OUTPUTS == 0))
+                {
+                    reason="Script rejected - P2SH is not allowed";
+                    reject=true;
+                    goto exitlbl;                    
+                }
+                
+                receive_required=addressRets.size();
+                if(typeRet == TX_MULTISIG)
+                {
+                    receive_required-=(pc1[0]-0x50);
+                    receive_required+=1;
+                    if(receive_required>(int)addressRets.size())
                     {
-                        fIsEntity=true;
+                        receive_required=addressRets.size();
                     }
                 }
-                else                                                        
-                {   
+
+                is_pure_permission=false;
+                if(mc_gState->m_TmpScript->GetNumElements())
+                {
+                    is_pure_permission=true;
+                }
+                for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
+                {
+                    mc_gState->m_TmpScript->SetElement(e);
                     if(mc_gState->m_TmpScript->GetPermission(&type,&from,&to,&timestamp) == 0)
-                    {                        
-                        type &= ( MC_PTP_MINE | MC_PTP_ADMIN );                                        
-                        if(fIsEntity)
+                    {
+                        switch(pass)
                         {
-                            type=0;
+                            case 0:
+                                type &= ~( MC_PTP_ACTIVATE | MC_PTP_ADMIN );
+                                break;
+                            case 1:
+                                type &= ( MC_PTP_ACTIVATE | MC_PTP_ADMIN );
+                                break;
+                            case 2:
+                                type=0;
+                                break;
                         }
                         if(type)
                         {
-                            CKeyID *lpKeyID=boost::get<CKeyID> (&addressRet);
-                            CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
-                            if((lpKeyID == NULL) && (lpScriptID == NULL))
+                            CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[0]);
+                            CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[0]);
+                            if(((lpKeyID == NULL) && (lpScriptID == NULL)) || (addressRets.size() > 1))
                             {
                                 reason="Permission script rejected - wrong destination type";
-                                fReject=true;
+                                reject=true;
                                 goto exitlbl;
                             }
+                            if(lpScriptID)
+                            {
+                                if(type != MC_PTP_RECEIVE)
+                                {
+                                    reason="Permission script rejected - only receive permission can be set for P2SH";
+                                    reject=true;
+                                    goto exitlbl;                            
+                                }
+                            }
+
+                            CBitcoinAddress address;
                             unsigned char* ptr=NULL;
                             flags=MC_PFL_NONE;
                             if(lpKeyID != NULL)
                             {
+                                address=CBitcoinAddress(*lpKeyID);
                                 ptr=(unsigned char*)(lpKeyID);
+                                if(type & MC_PTP_CONNECT)
+                                {
+                                    if(mc_gState->m_pSeedNode)
+                                    {
+                                        CNode* seed_node;
+                                        seed_node=(CNode*)(mc_gState->m_pSeedNode);
+                                        
+                                        if(memcmp(ptr,seed_node->kAddrRemote.begin(),20) == 0)
+                                        {
+                                            seed_node_involved=true;
+                                        }
+                                    }
+                                }
                             }
                             else
                             {
                                 flags=MC_PFL_IS_SCRIPTHASH;
+                                address=CBitcoinAddress(*lpScriptID);
                                 ptr=(unsigned char*)(lpScriptID);
                             }
-                            fAdminFound=false;
+                            if(fDebug)LogPrint("mchn","Found permission script in tx %s for %s - (%08x: %d - %d)\n",
+                                    tx.GetHash().GetHex().c_str(),
+                                    address.ToString().c_str(),
+                                    type, from, to);
+
+                            bool admin_found=false;
                             for (unsigned int i = 0; i < tx.vin.size(); i++)
                             {
-                                if(vInputCanGrantAdminMine[i])
+                                if((admin_outputs[i] < 0) || (admin_outputs[i] == (int)j))
                                 {
-                                    if(mc_gState->m_Permissions->SetPermission(NULL,ptr,type,(unsigned char*)&vInputDestinations[i],from,to,timestamp,flags,1,offset) == 0)
+                                    const CScript& script2 = tx.vin[i].scriptSig;        
+                                    CScript::const_iterator pc2 = script2.begin();
+
+                                    lpInputScript->Clear();
+                                    lpInputScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTSIG);
+
+                                    if(lpInputScript->GetNumElements() > 1)
                                     {
-                                        fAdminFound=true;
-                                    }                                
+                                        size_t elem_size;
+                                        const unsigned char *elem;
+
+                                        elem = lpInputScript->GetData(0,&elem_size);
+                                        if(elem_size > 1)                       // it is not multisig with one signature
+                                        {
+                                            elem = lpInputScript->GetData(1,&elem_size);
+                                            const unsigned char *pubkey_hash=(unsigned char *)Hash160(elem,elem+elem_size).begin();
+                                            if(mc_gState->m_Permissions->SetPermission(NULL,ptr,type,pubkey_hash,from,to,timestamp,flags,1,-1) == 0)
+                                            {
+                                                admin_found=true;
+                                            }
+                                        }
+                                    }                                    
                                 }
-                            }    
-                            if(!fAdminFound)
+                            }            
+                            if(!admin_found)
                             {
                                 reason="Inputs don't belong to valid admin";
-                                fReject=true;
+                                reject=true;
                                 goto exitlbl;                                                            
-                            }                                
-                            else
-                            {
-                                if(result)
-                                {
-                                    *result |= MC_PPL_ADMINMINERGRANT;
-                                }                                
                             }
                         }
-                        fIsEntity=false;
+                    }            
+                    else
+                    {
+                        is_pure_permission=false;
                     }
-                    else                                                   
+                }
+
+                if(tx.vout[j].nValue > 0)
+                {
+                    is_pure_permission=false;
+                }
+
+                
+                if( (pass == 2) && !is_op_return && !is_pure_permission )
+                {
+                    if (tx.vout[j].IsDust(::minRelayTxFee))             
                     {
-                        if(fIsEntity)                              
+                        if(!tx.IsCoinBase())
                         {
-                            reason="Script rejected - entity script should be followed by permission";
-                            fReject=true;
-                            goto exitlbl;                                                
+                            reason="Transaction amount too small";
+                            reject=true;
+                            goto exitlbl;                                                            
+                        }                            
+                    }
+
+                    for(int a=0;a<(int)addressRets.size();a++)
+                    {                            
+                        CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[a]);
+                        CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[a]);
+                        if((lpKeyID == NULL) && (lpScriptID == NULL))
+                        {
+                            reason="Script rejected - wrong destination type";
+                            reject=true;
+                            goto exitlbl;                                                            
+                        }
+                        unsigned char* ptr=NULL;
+                        if(lpKeyID != NULL)
+                        {
+                            ptr=(unsigned char*)(lpKeyID);
+                        }
+                        else
+                        {
+                            ptr=(unsigned char*)(lpScriptID);
+                        }
+
+                        bool can_receive=mc_gState->m_Permissions->CanReceive(NULL,ptr);
+
+                        if(tx.IsCoinBase())
+                        {
+                            can_receive |= mc_gState->m_Permissions->CanMine(NULL,ptr);
                         }
+
+                        if(can_receive)                        
+                        {
+                            receive_required--;
+                        }                                    
                     }
-                }
-            }                                                                              
+
+                    if(receive_required>0)
+                    {
+                        reason="One of the outputs doesn't have receive permission";
+                        reject=true;
+                        goto exitlbl;                                                                                
+                    }
+                }            
+            }
         }
     }    
-    
-exitlbl:        
-    
-    if(fReject)
+
+exitlbl:    
+
+    if(accept)
     {
-        if(fDebug)LogPrint("mchn","mchn: AcceptAdminMinerPermissions: Tx rejected: %s\n",EncodeHexTx(tx));
+        if(seed_node_involved)
+        {
+            CNode* seed_node;
+            seed_node=(CNode*)(mc_gState->m_pSeedNode);
+
+            if(!mc_gState->m_Permissions->CanConnect(NULL,seed_node->kAddrRemote.begin()))
+            {
+                LogPrintf("mchn: Seed node lost connect permission \n");
+                mc_gState->m_pSeedNode=NULL;
+            }
+        }
     }
 
-    return !fReject;
+    if(!accept || reject)
+    {
+        mc_gState->m_Permissions->RollBackToCheckPoint();
+    }
+
+    if(lpInputScript)
+    {
+        delete lpInputScript;
+    }
+
+    return !reject;
 }
 
 
diff --git a/src/protocol/relay.cpp b/src/protocol/relay.cpp
deleted file mode 100644
index 5540e22..0000000
--- a/src/protocol/relay.cpp
+++ /dev/null
@@ -1,2423 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "protocol/relay.h"
-#include "structs/base58.h"
-#include "wallet/chunkdb.h"
-#include "wallet/chunkcollector.h"
-#include "wallet/wallettxs.h"
-
-uint32_t MultichainNextChunkQueryAttempt(uint32_t attempts)
-{
-    if(attempts <  2)return 0;
-    return (uint32_t)(int64_t)(pow(1.5,attempts-1)-1);
-}
-
-string mc_MsgTypeStr(uint32_t msg_type)
-{
-    char *ptr;
-    ptr=(char*)&msg_type;
-    if(msg_type < 0x01000000)
-    {
-        return strprintf("%08x",msg_type);        
-    }
-    return strprintf("%c%c%c%c",ptr[0],ptr[1],ptr[2],ptr[3]);
-}
-
-typedef struct CRelayResponsePair
-{
-    mc_OffchainMessageID request_id;
-    int response_id;
-    
-    friend bool operator<(const CRelayResponsePair& a, const CRelayResponsePair& b)
-    {
-        return ((a.request_id < b.request_id) || 
-                (a.request_id == b.request_id && a.response_id < b.response_id));
-    }
-    
-} CRelayResponsePair;
-
-typedef struct CRelayRequestPairs
-{
-    map<int,int> m_Pairs;
-} CRelayRequestPairs;
-
-int MultichainProcessChunkResponse(const CRelayResponsePair *response_pair,map <int,int>* request_pairs,mc_ChunkCollector* collector)
-{
-    mc_RelayRequest *request;
-    mc_RelayResponse *response;
-    request=pRelayManager->FindRequest(response_pair->request_id);
-    if(request == NULL)
-    {
-        return false;
-    }
-    response=&(request->m_Responses[response_pair->response_id]);
-    
-    unsigned char *ptr;
-    unsigned char *ptrEnd;
-    unsigned char *ptrStart;
-    int shift,count,size;
-    int shiftOut,countOut,sizeOut;
-    int chunk_err;
-    mc_ChunkEntityKey *chunk;
-    mc_ChunkEntityKey *chunkOut;
-    unsigned char *ptrOut;
-    bool result=false;
-    string strError="";
-    mc_ChunkCollectorRow *collect_row;
-        
-    uint32_t total_size=0;
-    ptrStart=&(request->m_Payload[0]);
-    
-    size=sizeof(mc_ChunkEntityKey);
-    shift=0;
-    count=0;
-    
-    ptr=ptrStart;
-    ptrEnd=ptr+request->m_Payload.size();
-        
-    while(ptr<ptrEnd)
-    {
-        switch(*ptr)
-        {
-            case MC_RDT_EXPIRATION:
-                ptr+=5;
-                break;
-            case MC_RDT_CHUNK_IDS:
-                ptr++;
-                count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-                ptr+=shift;
-                if(count*size != (ptrEnd-ptr))
-                {
-                    goto exitlbl;
-                }                
-                for(int c=0;c<count;c++)
-                {
-                    total_size+=((mc_ChunkEntityKey*)ptr)->m_Size+size;
-                    ptr+=size;
-                }
-                break;
-            default:
-                goto exitlbl;
-        }
-    }
-    
-
-    if(response->m_Payload.size() != 1+shift+total_size)
-    {
-        strError="Total size mismatch";
-        goto exitlbl;        
-    }
-
-    ptrOut=&(response->m_Payload[0]);
-    if(*ptrOut != MC_RDT_CHUNKS)
-    {
-        strError="Unsupported payload format";
-        goto exitlbl;                
-    }
-    
-    ptrOut++;
-    countOut=(int)mc_GetVarInt(ptrOut,1+shift+total_size,-1,&shiftOut);
-    if( (countOut != count) || (shift != shiftOut) )
-    {
-        strError="Chunk count mismatch";
-        goto exitlbl;                        
-    }
-    ptrOut+=shift;
-    
-    ptr=ptrStart+1+shift+5;
-    for(int c=0;c<count;c++)
-    {
-        sizeOut=((mc_ChunkEntityKey*)ptr)->m_Size;
-        chunk=(mc_ChunkEntityKey*)ptr;
-        chunkOut=(mc_ChunkEntityKey*)ptrOut;
-        ptrOut+=size;
-        if(chunk->m_Size != chunkOut->m_Size)
-        {
-            for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Baddelivered+=k ? chunk->m_Size : 1;                
-            strError="Chunk info size mismatch";
-            goto exitlbl;                                        
-        }
-        if(memcmp(chunk->m_Hash,chunkOut->m_Hash,sizeof(uint256)))
-        {
-            for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Baddelivered+=k ? chunk->m_Size : 1;                
-            strError="Chunk info hash mismatch";
-            goto exitlbl;                                                    
-        }
-        if(memcmp(&(chunk->m_Entity),&(chunkOut->m_Entity),sizeof(mc_TxEntity)))
-        {
-            for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Baddelivered+=k ? chunk->m_Size : 1;                
-            strError="Chunk info entity mismatch";
-            goto exitlbl;                                                    
-        }
-        sizeOut=chunk->m_Size;
-        map <int,int>::iterator itreq = request_pairs->find(c);
-        if (itreq != request_pairs->end())
-        {
-            collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(itreq->second);
-            uint256 hash;
-            mc_gState->m_TmpBuffers->m_RpcHasher1->DoubleHash(ptrOut,sizeOut,&hash);
-            if(memcmp(&hash,chunk->m_Hash,sizeof(uint256)))
-            {
-                for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Baddelivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                strError="Chunk data hash mismatch";
-                goto exitlbl;                                        
-            }
-            chunk_err=pwalletTxsMain->m_ChunkDB->AddChunk(chunk->m_Hash,&(chunk->m_Entity),(unsigned char*)collect_row->m_TxID,collect_row->m_Vout,ptrOut,NULL,sizeOut,0,0);
-            if(chunk_err)
-            {
-                if(chunk_err != MC_ERR_FOUND)
-                {
-                    strError=strprintf("Internal chunk DB error: %d",chunk_err);
-                    goto exitlbl;                    
-                }
-            }
-            else
-            {
-                for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Delivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                LogPrint("chunks","Retrieved chunk %s\n",(*(uint256*)(chunk->m_Hash)).ToString().c_str());                
-            }
-            collect_row->m_State.m_Status |= MC_CCF_DELETED;
-        }        
-        
-        ptr+=size;
-        ptrOut+=sizeOut;
-    }
-    
-    result=true;
-    
-exitlbl:
-                
-    pRelayManager->UnLock();
-                
-    if(strError.size())
-    {
-        if(fDebug)LogPrint("chunks","Bad response from peer %d: %s\n",response->m_NodeFrom,strError.c_str());
-    }
-    return result;
-}
-
-int MultichainResponseScore(mc_RelayResponse *response,mc_ChunkCollectorRow *collect_row,map<int64_t,int64_t>& destination_loads,uint32_t max_total_size)
-{
-    unsigned char *ptr;
-    unsigned char *ptrEnd;
-    unsigned char *ptrStart;
-    int shift,count,size;
-    int64_t total_size;
-    mc_ChunkEntityKey *chunk;
-    int c;
-    if( (response->m_Status & MC_RST_SUCCESS) == 0 )
-    {
-        return MC_CCW_WORST_RESPONSE_SCORE;
-    }
-
-    total_size=0;
-    map<int64_t,int64_t>::iterator itdld = destination_loads.find(response->SourceID());
-    if (itdld != destination_loads.end())
-    {
-        total_size=itdld->second;
-    }                                    
-    
-    if(total_size + collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey) > max_total_size)
-    {
-        return MC_CCW_WORST_RESPONSE_SCORE;                
-    }
-    
-    ptrStart=&(response->m_Payload[0]);
-    
-    size=sizeof(mc_ChunkEntityKey);
-    shift=0;
-    count=0;
-    
-    ptr=ptrStart;
-    ptrEnd=ptr+response->m_Payload.size();
-    ptr++;
-    count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-    ptr+=shift;
-    
-    c=0;
-    while(c<count)
-    {
-        chunk=(mc_ChunkEntityKey*)ptr;
-        if( (memcmp(chunk->m_Hash,collect_row->m_ChunkDef.m_Hash,MC_CDB_CHUNK_HASH_SIZE) == 0) && 
-            (memcmp(&(chunk->m_Entity),&(collect_row->m_ChunkDef.m_Entity),sizeof(mc_TxEntity)) == 0))
-        {
-            if(chunk->m_Flags & MC_CCF_ERROR_MASK)
-            {
-                return MC_CCW_WORST_RESPONSE_SCORE;
-            }
-            c=count+1;
-        }
-        ptr+=size;
-        c++;
-    }
-    if(c == count)
-    {
-        return MC_CCW_WORST_RESPONSE_SCORE;        
-    }
-        
-    return (response->m_TryCount+response->m_HopCount)*1024*1024+total_size/1024;
-}
-
-int MultichainCollectChunks(mc_ChunkCollector* collector)
-{
-    uint32_t time_now,expiration,dest_expiration;    
-    vector <mc_ChunkEntityKey> vChunkDefs;
-    int row,last_row,last_count,to_end_of_query;
-    uint32_t total_size,max_total_query_size,max_total_destination_size,total_in_queries,max_total_in_queries,query_count;
-    mc_ChunkCollectorRow *collect_row;
-    mc_ChunkCollectorRow *collect_subrow;
-    time_now=mc_TimeNowAsUInt();
-    vector<unsigned char> payload;
-    unsigned char buf[16];
-    int shift,count;
-    unsigned char *ptrOut;
-    mc_OffchainMessageID query_id,request_id;
-    map <mc_OffchainMessageID,bool> query_to_delete;
-    map <CRelayResponsePair,CRelayRequestPairs> requests_to_send;    
-    map <CRelayResponsePair,CRelayRequestPairs> responses_to_process;    
-    map <int64_t,int64_t> destination_loads;    
-    mc_RelayRequest *request;
-    mc_RelayRequest *query;
-    mc_RelayResponse *response;
-    CRelayResponsePair response_pair;
-    vector<int> vRows;
-    CRelayRequestPairs request_pairs;
-    int best_score,best_response,this_score,not_processed;
-    
-    pRelayManager->CheckTime();
-    pRelayManager->InvalidateResponsesFromDisconnected();
-    
-    collector->Lock();
-
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            if(collect_row->m_State.m_RequestTimeStamp <= time_now)
-            {
-                if(!collect_row->m_State.m_Request.IsZero())
-                {
-                    pRelayManager->DeleteRequest(collect_row->m_State.m_Request);
-                    collect_row->m_State.m_Request=0;                    
-                    for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Undelivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                }                
-            }
-            request=NULL;
-            if(!collect_row->m_State.m_Request.IsZero())
-            {
-                request=pRelayManager->FindRequest(collect_row->m_State.m_Request);
-                if(request == NULL)
-                {
-                    collect_row->m_State.m_Request=0;
-                    collect_row->m_State.m_RequestTimeStamp=0;
-                    for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Undelivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                                    
-                }
-            }
-            if(request)
-            {
-                if(request->m_Responses.size())
-                {
-                    response_pair.request_id=collect_row->m_State.m_Request;
-                    response_pair.response_id=0;
-//                    printf("coll new rsp: row: %d, id: %s, %d\n",row,collect_row->m_State.m_Request.ToString().c_str(),collect_row->m_State.m_RequestPos);
-                    map<CRelayResponsePair,CRelayRequestPairs>::iterator itrsp = responses_to_process.find(response_pair);
-                    if (itrsp == responses_to_process.end())
-                    {
-                        request_pairs.m_Pairs.clear();
-                        request_pairs.m_Pairs.insert(make_pair(collect_row->m_State.m_RequestPos,row));
-                        responses_to_process.insert(make_pair(response_pair,request_pairs));
-                    }       
-                    else
-                    {
-                        itrsp->second.m_Pairs.insert(make_pair(collect_row->m_State.m_RequestPos,row));
-                    }                    
-                }            
-                pRelayManager->UnLock();
-            }
-        }        
-    }
-
-    BOOST_FOREACH(PAIRTYPE(const CRelayResponsePair, CRelayRequestPairs)& item, responses_to_process)    
-    {
-        MultichainProcessChunkResponse(&(item.first),&(item.second.m_Pairs),collector);
-        pRelayManager->DeleteRequest(item.first.request_id);
-    }
-
-
-    max_total_destination_size=(collector->m_TimeoutRequest-MC_CCW_TIMEOUT_REQUEST_SHIFT)*MC_CCW_MAX_MBS_PER_SECOND*1024*1024;
-//    max_total_size/=MC_CCW_QUERY_SPLIT;
-/*    
-    if(max_total_destination_size > MAX_SIZE-OFFCHAIN_MSG_PADDING)
-    {
-        max_total_destination_size=MAX_SIZE-OFFCHAIN_MSG_PADDING;        
-    }
-    
-    if(max_total_size < MAX_CHUNK_SIZE + sizeof(mc_ChunkEntityKey))
-    {
-        max_total_size = MAX_CHUNK_SIZE + sizeof(mc_ChunkEntityKey);
-    }
- */ 
-    max_total_query_size=MAX_CHUNK_SIZE + sizeof(mc_ChunkEntityKey);
-    
-    max_total_in_queries=(collector->m_TimeoutRequest-MC_CCW_TIMEOUT_REQUEST_SHIFT)*MC_CCW_MAX_MBS_PER_SECOND*1024*1024;
-    max_total_in_queries*=collector->m_TimeoutRequest;
-    total_in_queries=0;
-    query_count=0;
-    
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            request=NULL;
-            if(!collect_row->m_State.m_Request.IsZero())
-            {
-                request=pRelayManager->FindRequest(collect_row->m_State.m_Request);
-                if(request == NULL)
-                {
-                    collect_row->m_State.m_Request=0;
-                    collect_row->m_State.m_RequestTimeStamp=0;
-                    for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Undelivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                }
-            }
-            if(request)
-            {
-                map<int64_t,int64_t>::iterator itdld = destination_loads.find(request->m_DestinationID);
-                if (itdld == destination_loads.end())
-                {
-                    destination_loads.insert(make_pair(request->m_DestinationID,collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey)));
-                }       
-                else
-                {
-                    itdld->second+=collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey);
-                }                                    
-            }
-        }
-        else
-        {
-            if(!collect_row->m_State.m_Query.IsZero())
-            {
-                map<mc_OffchainMessageID, bool>::iterator itqry = query_to_delete.find(collect_row->m_State.m_Query);
-                if (itqry == query_to_delete.end())
-                {
-                    query_to_delete.insert(make_pair(collect_row->m_State.m_Query,true));
-                }       
-            }            
-        }
-    }
-    
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            if(collect_row->m_State.m_Request.IsZero())
-            {
-                query=NULL;
-                if(!collect_row->m_State.m_Query.IsZero())
-                {
-                    query=pRelayManager->FindRequest(collect_row->m_State.m_Query);
-                    if(query == NULL)
-                    {
-                        collect_row->m_State.m_Query=0;
-                        collect_row->m_State.m_QueryNextAttempt=time_now+MultichainNextChunkQueryAttempt(collect_row->m_State.m_QueryAttempts);                                                
-                        collect_row->m_State.m_Status |= MC_CCF_UPDATED;
-                        for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Unresponded+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                    }
-                }
-                if(query)
-                {
-                    best_response=-1;
-                    best_score=MC_CCW_WORST_RESPONSE_SCORE;
-                    for(int i=0;i<(int)query->m_Responses.size();i++)
-                    {
-                        this_score=MultichainResponseScore(&(query->m_Responses[i]),collect_row,destination_loads,max_total_destination_size);
-                        if(this_score < best_score)
-                        {
-                            best_score=this_score;
-                            best_response=i;
-                        }
-                    }
-                    if(best_response >= 0)
-                    {
-                        response_pair.request_id=collect_row->m_State.m_Query;
-                        response_pair.response_id=best_response;                        
-                        map<CRelayResponsePair,CRelayRequestPairs>::iterator itrsp = requests_to_send.find(response_pair);                                                
-                        if (itrsp == requests_to_send.end())
-                        {                            
-//                    printf("coll new req: row: %d, id:  %s, rsps: %d, score (%d,%d)\n",row,collect_row->m_State.m_Query.ToString().c_str(),(int)query->m_Responses.size(),best_score,best_response);
-                            request_pairs.m_Pairs.clear();
-                            request_pairs.m_Pairs.insert(make_pair(row,0));
-                            requests_to_send.insert(make_pair(response_pair,request_pairs));
-                        }       
-                        else
-                        {
-//                    printf("coll old req: row: %d, id:  %s, rsps: %d, score (%d,%d)\n",row,collect_row->m_State.m_Query.ToString().c_str(),(int)query->m_Responses.size(),best_score,best_response);
-                            itrsp->second.m_Pairs.insert(make_pair(row,0));
-                        }                    
-                        map<int64_t,int64_t>::iterator itdld = destination_loads.find(query->m_Responses[best_response].SourceID());
-                        if (itdld == destination_loads.end())
-                        {
-                            destination_loads.insert(make_pair(query->m_Responses[best_response].SourceID(),collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey)));
-                        }       
-                        else
-                        {
-                            itdld->second+=collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey);
-                        }                                    
-                    }
-                }
-                pRelayManager->UnLock();
-            }
-            if(!collect_row->m_State.m_Query.IsZero())
-            {
-                to_end_of_query=collect_row->m_State.m_QueryTimeStamp-time_now;
-                if(to_end_of_query<0)to_end_of_query=0;
-                if(to_end_of_query>collector->m_TimeoutRequest)to_end_of_query=collector->m_TimeoutRequest;
-                total_in_queries+=collect_row->m_ChunkDef.m_Size*to_end_of_query;
-            }
-        }        
-    }
-    
-    BOOST_FOREACH(PAIRTYPE(const CRelayResponsePair, CRelayRequestPairs)& item, requests_to_send)    
-    {
-        payload.clear();
-        shift=mc_PutVarInt(buf,16,item.second.m_Pairs.size());
-        payload.resize(5+1+shift+sizeof(mc_ChunkEntityKey)*item.second.m_Pairs.size());
-        request=pRelayManager->FindRequest(item.first.request_id);
-        if(request == NULL)
-        {
-            return false;
-        }
-
-        response=&(request->m_Responses[item.first.response_id]);
-        
-        expiration=time_now+collector->m_TimeoutRequest;
-        dest_expiration=expiration+response->m_MsgID.m_TimeStamp-request->m_MsgID.m_TimeStamp;// response->m_TimeDiff;
-        ptrOut=&(payload[0]);
-        *ptrOut=MC_RDT_EXPIRATION;
-        ptrOut++;
-        mc_PutLE(ptrOut,&dest_expiration,sizeof(dest_expiration));
-        ptrOut+=sizeof(dest_expiration);
-        *ptrOut=MC_RDT_CHUNK_IDS;
-        ptrOut++;
-        memcpy(ptrOut,buf,shift);
-        ptrOut+=shift;
-        count=0;
-        BOOST_FOREACH(PAIRTYPE(const int, int)& chunk_row, item.second.m_Pairs)    
-        {                            
-            collect_subrow=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(chunk_row.first);
-//            printf("S %d\n",chunk_row.first);
-            collect_subrow->m_State.m_RequestPos=count;
-            memcpy(ptrOut,&(collect_subrow->m_ChunkDef),sizeof(mc_ChunkEntityKey));
-            ptrOut+=sizeof(mc_ChunkEntityKey);
-            count++;
-        }
-//        mc_DumpSize("req",&(payload[0]),1+shift+sizeof(mc_ChunkEntityKey)*item.second.m_Pairs.size(),64);
-        request_id=pRelayManager->SendNextRequest(response,MC_RMT_CHUNK_REQUEST,0,payload);
-        if(fDebug)LogPrint("chunks","New chunk request: %s, response: %s, chunks: %d\n",request_id.ToString().c_str(),response->m_MsgID.ToString().c_str(),item.second.m_Pairs.size());
-        BOOST_FOREACH(PAIRTYPE(const int, int)& chunk_row, item.second.m_Pairs)    
-        {                
-            collect_subrow=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(chunk_row.first);
-            collect_subrow->m_State.m_Request=request_id;
-            collect_subrow->m_State.m_RequestTimeStamp=expiration;
-            for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Requested+=k ? collect_subrow->m_ChunkDef.m_Size : 1;                
-//            printf("T %d %d %s\n",chunk_row.first,collect_subrow->m_State.m_RequestPos,collect_subrow->m_State.m_Request.ToString().c_str());
-        }
-    }
-
-    row=0;
-    last_row=0;
-    last_count=0;
-    total_size=0;
-    
-    while(row<=collector->m_MemPool->GetCount())
-    {
-        collect_row=NULL;
-        if(row<collector->m_MemPool->GetCount())
-        {
-            collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        }
-        
-        if( (collect_row == NULL)|| (last_count >= MC_CCW_MAX_CHUNKS_PER_QUERY) || (total_size+collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey)> max_total_query_size) )
-        {
-            if(last_count)
-            {
-                payload.clear();
-                shift=mc_PutVarInt(buf,16,last_count);
-                payload.resize(1+shift+sizeof(mc_ChunkEntityKey)*last_count);
-                ptrOut=&(payload[0]);
-                
-                *ptrOut=MC_RDT_CHUNK_IDS;
-                ptrOut++;
-                memcpy(ptrOut,buf,shift);
-                ptrOut+=shift;
-                for(int r=last_row;r<row;r++)
-                {
-                    collect_subrow=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(r);
-                    if(collect_subrow->m_State.m_Status & MC_CCF_SELECTED)
-                    {
-                        memcpy(ptrOut,&(collect_subrow->m_ChunkDef),sizeof(mc_ChunkEntityKey));
-                        ptrOut+=sizeof(mc_ChunkEntityKey);
-                    }
-                }
-                query_id=pRelayManager->SendRequest(NULL,MC_RMT_CHUNK_QUERY,0,payload);
-                if(fDebug)LogPrint("chunks","New chunk query: %s, chunks: %d, rows [%d-%d)\n",query_id.ToString().c_str(),last_count,last_row,row);
-                for(int r=last_row;r<row;r++)
-                {
-                    collect_subrow=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(r);
-                    if(collect_subrow->m_State.m_Status & MC_CCF_SELECTED)
-                    {
-//                        printf("coll new qry: row: %d, id: %lu: att: %d\n",r,query_id,collect_subrow->m_State.m_QueryAttempts);
-                        collect_subrow->m_State.m_Status -= MC_CCF_SELECTED;
-                        collect_subrow->m_State.m_Query=query_id;
-                        collect_subrow->m_State.m_QueryAttempts+=1;
-                        collect_subrow->m_State.m_QueryTimeStamp=time_now+collector->m_TimeoutQuery;
-                        collect_subrow->m_State.m_QuerySilenceTimestamp=time_now+collector->m_TimeoutRequest;
-                        if(collect_subrow->m_State.m_QueryAttempts>1)
-                        {
-                            collect_subrow->m_State.m_QuerySilenceTimestamp=collect_subrow->m_State.m_QueryTimeStamp;
-                        }
-                        collect_subrow->m_State.m_Status |= MC_CCF_UPDATED;
-                        to_end_of_query=collect_subrow->m_State.m_QueryTimeStamp-time_now;
-                        if(to_end_of_query<0)to_end_of_query=0;
-                        if(to_end_of_query>collector->m_TimeoutRequest)to_end_of_query=collector->m_TimeoutRequest;
-                        total_in_queries+=(collect_subrow->m_ChunkDef.m_Size+ sizeof(mc_ChunkEntityKey))*to_end_of_query;
-                        for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Queried+=k ? collect_subrow->m_ChunkDef.m_Size : 1;                
-                    }
-                }
-                last_row=row;
-                last_count=0;     
-                total_size=0;
-            }
-        }
-        
-        if(collect_row)
-        {
-            if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-            {
-                int expired=0;
-                if(collect_row->m_State.m_QueryTimeStamp <= time_now)
-                {
-                    expired=1;
-                }
-                else
-                {                    
-                    if(collect_row->m_State.m_QuerySilenceTimestamp <= time_now)
-                    {
-                        query=NULL;
-                        if(!collect_row->m_State.m_Query.IsZero())
-                        {
-                            query=pRelayManager->FindRequest(collect_row->m_State.m_Query);
-                        }
-                        if(query)
-                        {
-                            if(query->m_Responses.size() == 0)
-                            {
-                                expired=1;
-                            }
-                        }                        
-                    }                    
-                }
-                
-                if(expired)
-                {
-                    if(!collect_row->m_State.m_Request.IsZero())
-                    {
-                        pRelayManager->DeleteRequest(collect_row->m_State.m_Request);
-                        collect_row->m_State.m_Request=0;
-                        for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Undelivered+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                    }
-                    if(!collect_row->m_State.m_Query.IsZero())
-                    {
-                        map<mc_OffchainMessageID, bool>::iterator itqry = query_to_delete.find(collect_row->m_State.m_Query);
-                        if (itqry == query_to_delete.end())
-                        {
-                            query_to_delete.insert(make_pair(collect_row->m_State.m_Query,true));
-                        }       
-                        collect_row->m_State.m_Query=0;
-                        collect_row->m_State.m_QueryNextAttempt=time_now+MultichainNextChunkQueryAttempt(collect_row->m_State.m_QueryAttempts);      
-                        collect_row->m_State.m_Status |= MC_CCF_UPDATED;
-                        for(int k=0;k<2;k++)collector->m_StatTotal[k].m_Unresponded+=k ? collect_row->m_ChunkDef.m_Size : 1;                
-                    }
-                    if((collect_row->m_State.m_QueryNextAttempt <= time_now) && (total_in_queries < max_total_in_queries) && ((int)query_count<collector->m_MaxMemPoolSize))
-                    {
-                        if( (collect_row->m_State.m_Status & MC_CCF_ERROR_MASK) == 0)
-                        {
-                            collect_row->m_State.m_Status |= MC_CCF_SELECTED;
-                            last_count++;
-                            total_size+=collect_row->m_ChunkDef.m_Size + sizeof(mc_ChunkEntityKey);
-                            query_count++;
-                        }
-                    }
-                }
-                else
-                {
-                    query_count++;
-                }
-            }
-        }
-        row++;
-    }
-        
-    not_processed=0;
-    
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            if(!collect_row->m_State.m_Query.IsZero())
-            {
-                map<mc_OffchainMessageID, bool>::iterator itqry = query_to_delete.find(collect_row->m_State.m_Query);
-                if (itqry != query_to_delete.end())
-                {
-                    itqry->second=false;
-                }            
-            }
-            not_processed++;
-        }
-    }
-
-    BOOST_FOREACH(PAIRTYPE(const mc_OffchainMessageID, bool)& item, query_to_delete)    
-    {
-        if(item.second)
-        {
-            pRelayManager->DeleteRequest(item.first);
-        }
-    }    
-    
-/*    
-    for(int k=0;k<2;k++)collector->m_StatLast[k].Zero();
-    collector->m_StatLast[0].m_Pending=collector->m_TotalChunkCount;
-    collector->m_StatLast[1].m_Pending=collector->m_TotalChunkSize;
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        size=collect_row->m_ChunkDef.m_Size;
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            if(!collect_row->m_State.m_Request.IsZero())
-            {
-                for(int k=0;k<2;k++)collector->m_StatLast[k].m_Requested+=k ? size : 1;                
-                for(int k=0;k<2;k++)collector->m_StatLast[k].m_Queried+=k ? size : 1;                                        
-            }
-            else
-            {
-                if(!collect_row->m_State.m_Query.IsZero())
-                {
-                    for(int k=0;k<2;k++)collector->m_StatLast[k].m_Queried+=k ? size : 1;                                        
-                }
-                else                    
-                {
-                    for(int k=0;k<2;k++)collector->m_StatLast[k].m_Sleeping+=k ? size : 1;                    
-                }                
-            }
-        }        
-        else
-        {
-            for(int k=0;k<2;k++)collector->m_StatLast[k].m_Pending-=k ? size : 1;                                
-        }
-    }
- */   
-    collector->UnLock();
-    if(not_processed < collector->m_MaxMemPoolSize/2)
-    {
-        if(collector->m_NextAutoCommitTimestamp < GetTimeMillis())
-        {
-            collector->Commit();
-            collector->m_NextAutoCommitTimestamp=GetTimeMillis()+collector->m_AutoCommitDelay;
-        }
-    }
-    
-    
-    return not_processed;
-}
-
-int MultichainCollectChunksQueueStats(mc_ChunkCollector* collector)
-{
-    int row;
-    int delay;
-    mc_ChunkCollectorRow *collect_row;
-    uint32_t size;
-    
-    collector->Lock();    
-    
-    for(int k=0;k<2;k++)collector->m_StatLast[k].Zero();
-    collector->m_StatLast[0].m_Pending=collector->m_TotalChunkCount;
-    collector->m_StatLast[1].m_Pending=collector->m_TotalChunkSize;
-    for(row=0;row<collector->m_MemPool->GetCount();row++)
-    {
-        collect_row=(mc_ChunkCollectorRow *)collector->m_MemPool->GetRow(row);
-        size=collect_row->m_ChunkDef.m_Size;
-        for(int k=0;k<2;k++)collector->m_StatLast[k].m_Undelivered+=k ? size : 1;                
-        if( (collect_row->m_State.m_Status & MC_CCF_DELETED ) == 0 )
-        {
-            if(!collect_row->m_State.m_Request.IsZero())
-            {
-                for(int k=0;k<2;k++)collector->m_StatLast[k].m_Requested+=k ? size : 1;                
-                for(int k=0;k<2;k++)collector->m_StatLast[k].m_Queried+=k ? size : 1;                                        
-            }
-            else
-            {
-                if(!collect_row->m_State.m_Query.IsZero())
-                {
-                    for(int k=0;k<2;k++)collector->m_StatLast[k].m_Queried+=k ? size : 1;                                        
-                }
-                else                    
-                {
-                    for(int k=0;k<2;k++)collector->m_StatLast[k].m_Sleeping+=k ? size : 1;                    
-                }                
-            }
-        }        
-        else
-        {
-            for(int k=0;k<2;k++)collector->m_StatLast[k].m_Pending-=k ? size : 1;                                
-        }
-    }
-
-    collector->UnLock();    
-    if(collector->m_MemPool->GetCount() > (int)(collector->m_MaxMemPoolSize*1.2))
-    {
-        if(collector->m_NextAutoCommitTimestamp < GetTimeMillis())
-        {
-            collector->Commit();
-            collector->m_NextAutoCommitTimestamp=GetTimeMillis()+collector->m_AutoCommitDelay;
-        }
-    }
-    
-    delay=collector->m_StatLast[0].m_Queried;
-    if(delay>MC_CCW_MAX_DELAY_BETWEEN_COLLECTS)
-    {
-        delay=MC_CCW_MAX_DELAY_BETWEEN_COLLECTS;
-    }
-    
-    return delay;
-}
-
-void mc_RelayPayload_ChunkIDs(vector<unsigned char>* payload,vector <mc_ChunkEntityKey>& vChunkDefs,int size)
-{
-    unsigned char buf[16];
-    int shift;
-    unsigned char *ptrOut;
-    
-    if(payload)
-    {
-        if(vChunkDefs.size())
-        {
-            shift=mc_PutVarInt(buf,16,vChunkDefs.size());
-            payload->resize(1+shift+size*vChunkDefs.size());
-            ptrOut=&(*payload)[0];
-
-            *ptrOut=MC_RDT_CHUNK_IDS;
-            ptrOut++;
-            memcpy(ptrOut,buf,shift);
-            ptrOut+=shift;
-
-            for(int i=0;i<(int)vChunkDefs.size();i++)
-            {
-                memcpy(ptrOut,&vChunkDefs[i],size);
-                ptrOut+=size;
-            }                        
-        }
-    }
-}
-
-bool mc_RelayProcess_Chunk_Query(unsigned char *ptrStart,unsigned char *ptrEnd,vector<unsigned char>* payload_response,vector<unsigned char>* payload_relay,string& strError)
-{
-    unsigned char *ptr;
-    int shift,count,size;
-    vector <mc_ChunkEntityKey> vToRelay;
-    vector <mc_ChunkEntityKey> vToRespond;
-    mc_ChunkEntityKey chunk;
-    mc_ChunkDBRow chunk_def;
-    
-    size=sizeof(mc_ChunkEntityKey);
-    ptr=ptrStart;
-    while(ptr<ptrEnd)
-    {
-        switch(*ptr)
-        {
-            case MC_RDT_CHUNK_IDS:
-                ptr++;
-                count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-                ptr+=shift;
-                if(count*size != (ptrEnd-ptr))
-                {
-                    strError="Bad chunk ids request";
-                    return false;                    
-                }                
-                for(int c=0;c<count;c++)
-                {
-                    chunk=*(mc_ChunkEntityKey*)ptr;
-                    if(pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,chunk.m_Hash,NULL,NULL,-1) == MC_ERR_NOERROR)
-                    {
-                        if(chunk_def.m_Size != chunk.m_Size)
-                        {
-                            chunk.m_Flags |= MC_CCF_WRONG_SIZE;
-                            chunk.m_Size=chunk_def.m_Size;
-                        }
-                        vToRespond.push_back(chunk);
-                    }                    
-                    else
-                    {
-                        vToRelay.push_back(chunk);                                                
-                    }
-                    ptr+=size;
-                }
-
-                mc_RelayPayload_ChunkIDs(payload_response,vToRespond,size);
-                mc_RelayPayload_ChunkIDs(payload_relay,vToRelay,size);
-                break;
-            default:
-                strError=strprintf("Unsupported request format (%d, %d)",MC_RMT_CHUNK_QUERY,*ptr);
-                return false;
-        }
-    }
-    
-    return true;
-}
-
-bool mc_RelayProcess_Chunk_Request(unsigned char *ptrStart,unsigned char *ptrEnd,vector<unsigned char>* payload_response,vector<unsigned char>* payload_relay,string& strError)
-{
-    unsigned char *ptr;
-    int shift,count,size;
-    mc_ChunkEntityKey chunk;
-    mc_ChunkDBRow chunk_def;
-    const unsigned char *chunk_found;
-    unsigned char buf[16];
-    size_t chunk_bytes;
-    unsigned char *ptrOut;
-    
-    uint32_t total_size=0;
-    uint32_t max_total_size=MAX_SIZE-OFFCHAIN_MSG_PADDING;
-    uint32_t expiration=0;
-    
-    mc_gState->m_TmpBuffers->m_RelayTmpBuffer->Clear();
-    mc_gState->m_TmpBuffers->m_RelayTmpBuffer->AddElement();
-            
-    size=sizeof(mc_ChunkEntityKey);
-    ptr=ptrStart;
-    while(ptr<ptrEnd)
-    {
-        switch(*ptr)
-        {
-            case MC_RDT_EXPIRATION:
-                ptr++;
-                expiration=(uint32_t)mc_GetLE(ptr,sizeof(expiration));
-                ptr+=sizeof(expiration);
-                if(expiration+1 < pRelayManager->m_LastTime)
-                {
-                    strError="Less than 1s for request expiration";
-                    return false;                                        
-                }
-                if(expiration-35 > pRelayManager->m_LastTime)                   // We are supposed to store query_hit record only for 30s, something is wrong
-                {
-                    strError="Expiration is too far in the future";
-                    return false;                                                            
-                }
-                max_total_size=MC_CCW_MAX_MBS_PER_SECOND*(expiration-pRelayManager->m_LastTime)*1024*1024;
-                break;
-            case MC_RDT_CHUNK_IDS:
-                ptr++;
-                count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-                ptr+=shift;
-                if(count*size != (ptrEnd-ptr))
-                {
-                    strError="Bad chunk ids request";
-                    return false;                    
-                }                
-                for(int c=0;c<count;c++)
-                {
-                    chunk=*(mc_ChunkEntityKey*)ptr;
-                    LogPrint("chunks","Request for chunk: %s\n",(*(uint256*)(chunk.m_Hash)).ToString().c_str());
-                    if(pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,chunk.m_Hash,NULL,NULL,-1) == MC_ERR_NOERROR)
-                    {
-                        if(chunk_def.m_Size != chunk.m_Size)
-                        {
-                            strError="Bad chunk size";
-                            return false;                    
-                        }
-                        total_size+=chunk_def.m_Size+size;
-                        if(total_size > MAX_SIZE-OFFCHAIN_MSG_PADDING)
-                        {
-                            strError="Total size of requested chunks is too big for message";
-                            return false;                                                
-                        }
-                        if(total_size > max_total_size)
-                        {
-                            strError="Total size of requested chunks is too big for response expiration";
-                            return false;                                                
-                        }
-                        chunk_found=pwalletTxsMain->m_ChunkDB->GetChunk(&chunk_def,0,-1,&chunk_bytes);
-                        mc_gState->m_TmpBuffers->m_RelayTmpBuffer->SetData((unsigned char*)&chunk,size);
-                        mc_gState->m_TmpBuffers->m_RelayTmpBuffer->SetData(chunk_found,chunk_bytes);
-                    }                    
-                    else
-                    {
-                        strError="Chunk not found";
-                        return false;                    
-                    }
-                    ptr+=size;
-                }
-                
-                chunk_found=mc_gState->m_TmpBuffers->m_RelayTmpBuffer->GetData(0,&chunk_bytes);
-                shift=mc_PutVarInt(buf,16,count);
-                payload_response->resize(1+shift+chunk_bytes);
-                ptrOut=&(*payload_response)[0];
-                
-                *ptrOut=MC_RDT_CHUNKS;
-                ptrOut++;
-                memcpy(ptrOut,buf,shift);
-                ptrOut+=shift;
-                memcpy(ptrOut,chunk_found,chunk_bytes);
-                ptrOut+=chunk_bytes;
-                
-                break;
-            default:
-                strError=strprintf("Unsupported request format (%d, %d)",MC_RMT_CHUNK_QUERY,*ptr);
-                return false;
-        }
-    }
-
-    if(total_size > max_total_size)
-    {
-        strError="Total size of requested chunks is too big for response expiration";
-        return false;                                                
-    }
-    
-    return true;
-}
-
-bool mc_RelayProcess_Address_Query(unsigned char *ptrStart,unsigned char *ptrEnd,vector<unsigned char>* payload_response,vector<unsigned char>* payload_relay,string& strError)
-{
-    unsigned char *ptr;
-    unsigned char *ptrOut;
-    unsigned char buf[16];
-    int shift;
-    CKey key;
-    
-    ptr=ptrStart;
-    while(ptr<ptrEnd)
-    {
-        switch(*ptr)
-        {
-            case MC_RDT_MC_ADDRESS:
-                ptr++;
-                if(sizeof(CKeyID) != (ptrEnd-ptr))
-                {
-                    strError="Bad address query request";
-                    return false;
-                }
-
-                if(pwalletMain->GetKey(*(CKeyID*)ptr, key))
-                {
-                    if(payload_response)
-                    {
-                        shift=mc_PutVarInt(buf,16,pRelayManager->m_MyAddress.m_NetAddresses.size());
-                        payload_response->resize(1+sizeof(CKeyID)+1+shift+sizeof(CAddress)*pRelayManager->m_MyAddress.m_NetAddresses.size());
-                        ptrOut=&(*payload_response)[0];
-                        
-                        *ptrOut=MC_RDT_MC_ADDRESS;
-                        ptrOut++;
-                        *(CKeyID*)ptrOut=pRelayManager->m_MyAddress.m_Address;
-                        ptrOut+=sizeof(CKeyID);
-                        
-                        *ptrOut=MC_RDT_NET_ADDRESS;
-                        ptrOut++;
-                        memcpy(ptrOut,buf,shift);
-                        ptrOut+=shift;
-                        for(int i=0;i<(int)pRelayManager->m_MyAddress.m_NetAddresses.size();i++)
-                        {
-                            memcpy(ptrOut,&(pRelayManager->m_MyAddress.m_NetAddresses[i]),sizeof(CAddress));
-                            ptrOut+=sizeof(CAddress);
-                        }                        
-                    }
-                }
-                else
-                {
-                    if(payload_relay)
-                    {
-                        payload_relay->resize(ptrEnd-ptrStart);
-                        memcpy(&(*payload_relay)[0],ptrStart,ptrEnd-ptrStart);                    
-                    }
-                }
-                
-                ptr+=sizeof(CKeyID);
-                break;
-            default:
-                strError=strprintf("Unsupported request format (%d, %d)",MC_RMT_MC_ADDRESS_QUERY,*ptr);
-                return false;
-        }
-    }
-    
-    return true;
-}
-
-bool MultichainRelayResponse(uint32_t msg_type_stored, CNode *pto_stored,
-                             uint32_t msg_type_in, uint32_t  flags, vector<unsigned char>& vPayloadIn,vector<CKeyID>&  vAddrIn,
-                             uint32_t* msg_type_response,uint32_t  *flags_response,vector<unsigned char>& vPayloadResponse,vector<CKeyID>&  vAddrResponse,
-                             uint32_t* msg_type_relay,uint32_t  *flags_relay,vector<unsigned char>& vPayloadRelay,vector<CKeyID>&  vAddrRelay,string& strError)
-{
-    unsigned char *ptr;
-    unsigned char *ptrEnd;
-    vector<unsigned char> *payload_relay_ptr=NULL;
-    vector<unsigned char> *payload_response_ptr=NULL;
-    
-    if(msg_type_response)
-    {
-        payload_response_ptr=&vPayloadResponse;
-    }
-    
-    if(msg_type_relay)
-    {
-        payload_relay_ptr=&vPayloadRelay;
-    }
-    
-    ptr=&vPayloadIn[0];
-    ptrEnd=ptr+vPayloadIn.size();
-            
-//    mc_DumpSize("H",ptr,ptrEnd-ptr,32);
-    strError="";
-    switch(msg_type_in)
-    {
-        case MC_RMT_MC_ADDRESS_QUERY:
-            if(msg_type_stored)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr == NULL)
-            {
-                if(payload_relay_ptr)
-                {
-                    vPayloadRelay=vPayloadIn;
-                    *msg_type_relay=msg_type_in;                    
-                }
-            }
-            else
-            {
-                if(mc_RelayProcess_Address_Query(ptr,ptrEnd,payload_response_ptr,payload_relay_ptr,strError))
-                {
-                    if(payload_response_ptr && (payload_response_ptr->size() != 0))
-                    {
-                        *msg_type_response=MC_RMT_NODE_DETAILS;
-                    }
-                    if(payload_relay_ptr && (payload_relay_ptr->size() != 0))
-                    {
-                        *msg_type_relay=MC_RMT_MC_ADDRESS_QUERY;
-                    }
-                }
-            }
-            break;
-        case MC_RMT_NODE_DETAILS:
-            if(msg_type_stored != MC_RMT_MC_ADDRESS_QUERY)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr)
-            {
-                *msg_type_response=MC_RMT_ADD_RESPONSE;
-            }
-
-            break;
-        case MC_RMT_CHUNK_QUERY:
-            if(msg_type_stored)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr == NULL)
-            {
-                if(payload_relay_ptr)
-                {
-                    vPayloadRelay=vPayloadIn;
-                    *msg_type_relay=msg_type_in;                    
-                }
-            }
-            else
-            {
-                if(mc_RelayProcess_Chunk_Query(ptr,ptrEnd,payload_response_ptr,payload_relay_ptr,strError))
-                {
-                    if(payload_response_ptr && (payload_response_ptr->size() != 0))
-                    {
-                        *msg_type_response=MC_RMT_CHUNK_QUERY_HIT;
-                    }
-                    if(payload_relay_ptr && (payload_relay_ptr->size() != 0))
-                    {
-                        *msg_type_relay=MC_RMT_CHUNK_QUERY;
-                    }
-                }
-            }            
-            break;
-        case MC_RMT_CHUNK_QUERY_HIT:
-            if(msg_type_stored != MC_RMT_CHUNK_QUERY)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr)
-            {
-                *msg_type_response=MC_RMT_ADD_RESPONSE;
-            }
-            break;
-        case MC_RMT_CHUNK_REQUEST:
-            if(msg_type_stored != MC_RMT_CHUNK_QUERY_HIT)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr == NULL)
-            {
-                if(payload_relay_ptr)
-                {
-                    vPayloadRelay=vPayloadIn;
-                    *msg_type_relay=msg_type_in;                    
-                }
-            }
-            else
-            {
-                if(mc_RelayProcess_Chunk_Request(ptr,ptrEnd,payload_response_ptr,payload_relay_ptr,strError))
-                {
-                    if(payload_response_ptr && (payload_response_ptr->size() != 0))
-                    {
-                        *msg_type_response=MC_RMT_CHUNK_RESPONSE;
-                    }
-                    if(payload_relay_ptr && (payload_relay_ptr->size() != 0))
-                    {
-                        *msg_type_relay=MC_RMT_CHUNK_REQUEST;
-                    }
-                }
-            }            
-            break;
-        case MC_RMT_CHUNK_RESPONSE:
-            if(msg_type_stored != MC_RMT_CHUNK_REQUEST)
-            {
-                strError=strprintf("Unexpected response message type (%s,%s)",mc_MsgTypeStr(msg_type_stored).c_str(),mc_MsgTypeStr(msg_type_in).c_str());
-                goto exitlbl;
-            } 
-            if(payload_response_ptr)
-            {
-                *msg_type_response=MC_RMT_ADD_RESPONSE;
-            }
-
-            break;
-    }
-    
-exitlbl:
-            
-    if(strError.size())
-    {
-        return false;
-    }
-
-    return true;
-}
-
-void mc_Limiter::Zero()
-{
-    memset(this,0,sizeof(mc_Limiter));    
-}
-
-int mc_Limiter::Initialize(int seconds,int measures)
-{
-    Zero();
-    
-    if(seconds > MC_LIM_MAX_SECONDS)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    if(measures > MC_LIM_MAX_MEASURES)
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    m_SecondCount=seconds;
-    m_MeasureCount=measures;
-    m_Time=mc_TimeNowAsUInt();
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_Limiter::SetLimit(int meausure, int64_t limit)
-{
-    if( (meausure > MC_LIM_MAX_MEASURES) || (meausure <0) )
-    {
-        return MC_ERR_INVALID_PARAMETER_VALUE;        
-    }
-    m_Limits[meausure]=limit*m_SecondCount;
-    return MC_ERR_NOERROR;    
-}
-
-void mc_Limiter::CheckTime()
-{
-    CheckTime(mc_TimeNowAsUInt());
-}
-
-void mc_Limiter::CheckTime(uint32_t time_now)
-{
-    if(m_SecondCount == 0)
-    {
-        return;        
-    }
-    if(time_now == m_Time)
-    {
-        return;
-    }
-    if(time_now >= m_Time + m_SecondCount)
-    {
-        memset(m_Totals,0,MC_LIM_MAX_MEASURES);
-        memset(m_Measures,0,MC_LIM_MAX_MEASURES*MC_LIM_MAX_SECONDS);
-    }
-    
-    for(uint32_t t=m_Time;t<time_now;t++)
-    {
-        int p=(t+1)%m_SecondCount;
-        for(int m=0;m<m_MeasureCount;m++)
-        {
-            m_Totals[m]-=m_Measures[m*MC_LIM_MAX_SECONDS+p];
-            m_Measures[m*MC_LIM_MAX_SECONDS+p]=0;
-        }
-    }
-    
-    m_Time=time_now;
-}
-
-void mc_Limiter::SetEvent(int64_t m1)
-{
-    SetEvent(m1,0,0,0);
-}
-
-void mc_Limiter::SetEvent(int64_t m1,int64_t m2)
-{
-    SetEvent(m1,m2,0,0);    
-}
-
-void mc_Limiter::SetEvent(int64_t m1,int64_t m2,int64_t m3)
-{
-    SetEvent(m1,m2,m3,0);        
-}
-
-void mc_Limiter::SetEvent(int64_t m1,int64_t m2,int64_t m3,int64_t m4)
-{
-    m_Event[0]=m1;
-    m_Event[1]=m2;
-    m_Event[2]=m3;
-    m_Event[3]=m4;
-}
-
-int mc_Limiter::Disallowed()
-{
-    return Disallowed(mc_TimeNowAsUInt());
-}
-
-int mc_Limiter::Disallowed(uint32_t t)
-{
-    CheckTime(t);
-    
-    for(int m=0;m<m_MeasureCount;m++)
-    {
-        if(m_Totals[m]+m_Event[m] > m_Limits[m])
-        {
-            return 1;
-        }
-    }
-    
-    return 0;
-}
-
-void mc_Limiter::Increment()
-{
-    if(m_SecondCount == 0)
-    {
-        return;        
-    }
-    
-    int p=(m_Time+1)%m_SecondCount;
-    for(int m=0;m<m_MeasureCount;m++)
-    {
-        m_Totals[m]+=m_Event[m];
-        m_Measures[m*MC_LIM_MAX_SECONDS+p]+=m_Event[m];
-    }    
-}
-
-void mc_NodeFullAddress::Zero()
-{
-    m_Address=CKeyID(0);
-    m_NetAddresses.clear();
-}
-
-void mc_RelayManager::SetMyIPs(uint32_t *ips,int ip_count)
-{
-    m_MyIPCount=ip_count;
-    for(int i=0;i<ip_count;i++)
-    {
-        m_MyIPs[i]=ips[i];
-    }
-}
-
-void mc_RelayManager::InitNodeAddress(mc_NodeFullAddress *node_address,CNode* pto,uint32_t action)
-{
-    uint32_t pto_address_local;
-    in_addr addr;
-    CKey key;
-    CPubKey pkey;            
-    bool key_found=false;
-    
-    if(action & MC_PRA_MY_ORIGIN_MC_ADDRESS)
-    {
-        if(pto)
-        {
-            node_address->m_Address=pto->kAddrLocal;        
-        }
-    }
-    else
-    {
-        if(pto == NULL)
-        {
-            if(mapArgs.count("-handshakelocal"))
-            {
-                CBitcoinAddress address(mapArgs["-handshakelocal"]);
-                if (address.IsValid())    
-                {
-                    CTxDestination dst=address.Get();
-                    CKeyID *lpKeyID=boost::get<CKeyID> (&dst);
-                    if(lpKeyID)
-                    {
-                        if(pwalletMain->GetKey(*lpKeyID, key))
-                        {
-                            node_address->m_Address=*lpKeyID;
-                            key_found=true;
-                        }
-                    }
-                }        
-            }
-
-            if(!key_found)
-            {
-                if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_CONNECT))
-                {
-                    pkey=pwalletMain->vchDefaultKey;
-                }
-                node_address->m_Address=pkey.GetID();
-            }  
-        }
-    }
-    
-    node_address->m_NetAddresses.clear();
-    
-    pto_address_local=0;
-    if(action & MC_PRA_MY_ORIGIN_NT_ADDRESS)
-    {
-        node_address->m_NetAddresses.push_back(CAddress(pto->addrLocal));
-
-        if(pto->addrLocal.IsIPv4())
-        {
-            pto_address_local=(pto->addrLocal.GetByte(3)<<24)+(pto->addrLocal.GetByte(2)<<16)+(pto->addrLocal.GetByte(1)<<8)+pto->addrLocal.GetByte(0);            
-            addr.s_addr=pto_address_local;
-            node_address->m_NetAddresses.push_back(CAddress(CService(addr,GetListenPort())));
-        }
-    }
-    
-    
-    for(int i=0;i<m_MyIPCount;i++)
-    {
-        if(m_MyIPs[i] != pto_address_local)
-        {
-            addr.s_addr=htonl(m_MyIPs[i]);
-            node_address->m_NetAddresses.push_back(CAddress(CService(addr,GetListenPort())));
-        }
-    }        
-}
-
-void mc_RelayManager::InitNodeAddress(mc_NodeFullAddress *node_address,CKeyID& mc_address, vector<CAddress>& net_addresses)
-{
-    node_address->m_Address=mc_address;
-    node_address->m_NetAddresses=net_addresses;
-}
-
-void mc_RelayManager::MsgTypeSettings(uint32_t msg_type,int latency,int seconds,int64_t serves_per_second,int64_t bytes_per_second)
-{
-    mc_Limiter limiter;
-    
-    map<uint32_t, int>::iterator itlat = m_Latency.find(msg_type);
-    if (itlat == m_Latency.end())
-    {
-        m_Latency.insert(make_pair(msg_type,latency));
-    }                    
-    else
-    {
-        itlat->second=latency;
-    }
-    
-    limiter.Initialize(seconds,2);
-    limiter.SetLimit(0,serves_per_second);
-    limiter.SetLimit(1,bytes_per_second);
-    
-    map<uint32_t, mc_Limiter>::iterator itlim = m_Limiters.find(msg_type);
-    if (itlim == m_Limiters.end())
-    {
-        m_Limiters.insert(make_pair(msg_type,limiter));
-    }                    
-    else
-    {
-        itlim->second=limiter;
-    }
-}
-
-
-
-void mc_RelayManager::Zero()
-{
-    m_Semaphore=NULL;
-    m_LockedBy=0;         
-}
-
-void mc_RelayManager::Destroy()
-{
-    if(m_Semaphore)
-    {
-        __US_SemDestroy(m_Semaphore);
-    }
-    
-    Zero();    
-}
-
-int mc_RelayManager::Initialize()
-{
-    m_Semaphore=__US_SemCreate();
-    InitNodeAddress(&m_MyAddress,NULL,MC_PRA_NONE);
-    SetDefaults();
-    return MC_ERR_NOERROR;    
-}
-
-int mc_RelayManager::Lock(int write_mode,int allow_secondary)
-{        
-    uint64_t this_thread;
-    this_thread=__US_ThreadID();
-    
-    if(this_thread == m_LockedBy)
-    {
-        return allow_secondary;
-    }
-    
-    __US_SemWait(m_Semaphore); 
-    m_LockedBy=this_thread;
-    
-    return 0;
-}
-
-void mc_RelayManager::UnLock()
-{    
-    m_LockedBy=0;
-    __US_SemPost(m_Semaphore);
-}
-
-int mc_RelayManager::Lock()
-{        
-    return Lock(1,0);
-}
-
-void mc_RelayManager::SetDefaults()
-{
-    MsgTypeSettings(MC_RMT_NONE            , 0,10,1000,100*1024*1024);
-    MsgTypeSettings(MC_RMT_MC_ADDRESS_QUERY,10,10, 100,  1*1024*1024);
-    MsgTypeSettings(MC_RMT_NODE_DETAILS    , 0,10, 100,  1*1024*1024);
-    MsgTypeSettings(MC_RMT_CHUNK_QUERY     ,pwalletTxsMain->m_ChunkCollector->m_TimeoutQuery+5,10, 100,  1*1024*1024);
-    MsgTypeSettings(MC_RMT_CHUNK_QUERY_HIT ,pwalletTxsMain->m_ChunkCollector->m_TimeoutQuery+5,10, 100,  1*1024*1024);
-    MsgTypeSettings(MC_RMT_CHUNK_REQUEST   ,pwalletTxsMain->m_ChunkCollector->m_TimeoutRequest+5,10, 100, (MC_CCW_MAX_MBS_PER_SECOND+2)*1024*1024);
-    MsgTypeSettings(MC_RMT_CHUNK_RESPONSE  , 0,10, 100,100*1024*1024);
-    MsgTypeSettings(MC_RMT_ERROR_IN_MESSAGE,30,10,1000,  1*1024*1024);
-    MsgTypeSettings(MC_RMT_NEW_REQUEST     ,30,10,1000,  1*1024*1024);
-    
-    
-    m_MinTimeShift=2 * 6 * Params().TargetSpacing();
-    m_MaxTimeShift=2 * 6 * Params().TargetSpacing();
-    m_MaxResponses=16;
-}
-
-void mc_RelayManager::CheckTime()
-{
-    uint32_t time_now=mc_TimeNowAsUInt();
-    if(time_now == m_LastTime)
-    {
-        return;
-    }
-
-    Lock();
-    for(map<const mc_RelayRecordKey,mc_RelayRecordValue>::iterator it = m_RelayRecords.begin(); it != m_RelayRecords.end();)
-    {
-        if(it->second.m_Timestamp < m_LastTime)
-        {
-/*            
-            mc_OffchainMessageID msg_id=it->first.m_ID;
-            LogPrint("offchain","Offchain rrdl:  %s, from: %d, to: %d, msg: %s, now: %d, exp: %d\n",
-            msg_id.ToString().c_str(),it->second.m_NodeFrom,it->first.m_NodeTo,mc_MsgTypeStr(it->second.m_MsgType).c_str(),m_LastTime,it->second.m_Timestamp);
-*/
-            m_RelayRecords.erase(it++);
-        }
-        else
-        {
-            it++;
-        }
-    }        
-    m_LastTime=time_now;
-    UnLock();
-}
-
-void mc_RelayManager::SetRelayRecord(CNode *pto,CNode *pfrom,uint32_t msg_type,mc_OffchainMessageID msg_id)
-{
-    map<uint32_t, int>::iterator itlat = m_Latency.find(msg_type);
-    if (itlat == m_Latency.end())
-    {
-        return;
-    }                    
-    if(itlat->second <= 0 )
-    {
-        return;        
-    }    
-    
-    NodeId pto_id=0;
-    if(pto)
-    {
-        pto_id=pto->GetId();
-    }
-    const mc_RelayRecordKey key=mc_RelayRecordKey(msg_id,pto_id);
-    mc_RelayRecordValue value;
-    value.m_NodeFrom=0;
-    if(pfrom)
-    {
-        value.m_NodeFrom=pfrom->GetId();
-    }
-    value.m_MsgType=msg_type;
-    value.m_Timestamp=m_LastTime+itlat->second;
-    value.m_Count=1;
-    
-    map<const mc_RelayRecordKey, mc_RelayRecordValue>::iterator it = m_RelayRecords.find(key);
-    if (it == m_RelayRecords.end())
-    {
-        m_RelayRecords.insert(make_pair(key,value));
-    }                    
-    else
-    {
-        value.m_Timestamp=(it->second).m_Timestamp;
-        value.m_Count=(it->second).m_Count;
-        it->second=value;
-    }
-/*   
-    LogPrint("offchain","Offchain rrst:  %s, from: %d, to: %d, msg: %s, now: %d, exp: %d\n",
-    msg_id.ToString().c_str(),pfrom ? pfrom->GetId() : 0,pto ? pto->GetId() : 0,mc_MsgTypeStr(msg_type).c_str(),m_LastTime,value.m_Timestamp);
-*/    
-
-}
-
-int mc_RelayManager::GetRelayRecord(CNode *pfrom,mc_OffchainMessageID msg_id,uint32_t* msg_type,CNode **pto)
-{
-    NodeId pfrom_id,pto_id;
-    
-    pfrom_id=0;
-    if(pfrom)
-    {
-        pfrom_id=pfrom->GetId();
-    }
-//    printf("getrr: %d, ts: %u, nc: %u\n",pfrom_id,timestamp,nonce);
-    const mc_RelayRecordKey key=mc_RelayRecordKey(msg_id,pfrom_id);
-    map<const mc_RelayRecordKey, mc_RelayRecordValue>::iterator it = m_RelayRecords.find(key);
-    if (it == m_RelayRecords.end())
-    {
-        return MC_ERR_NOT_FOUND;
-    }
-    
-    if(it->second.m_MsgType == MC_RMT_ERROR_IN_MESSAGE)
-    {
-        return MC_ERR_ERROR_IN_SCRIPT;
-    }
-    
-    if(msg_type)
-    {
-        *msg_type=it->second.m_MsgType;        
-    }
-    
-    
-    if(pto)
-    {
-        pto_id=it->second.m_NodeFrom;
-    
-        if(pto_id)
-        {
-            LOCK(cs_vNodes);
-            BOOST_FOREACH(CNode* pnode, vNodes)
-            {
-                if(pnode->GetId() == pto_id)
-                {
-                    *pto=pnode;
-                    return MC_ERR_NOERROR;
-                }
-            }
-        }
-        else
-        {
-            return MC_ERR_NOERROR;            
-        }
-    }
-    else
-    {
-        it->second.m_Count+=1;
-        if(it->second.m_Count > m_MaxResponses)
-        {
-            return MC_ERR_NOT_ALLOWED;            
-        }
-        return MC_ERR_NOERROR;                    
-    }
-    
-    return MC_ERR_NOT_ALLOWED;
-}
-
-mc_OffchainMessageID mc_RelayManager::GenerateMsgID(uint32_t timestamp)
-{
-    mc_OffchainMessageID msg_id;
-    msg_id.m_TimeStamp=timestamp;
-    GetRandBytes((unsigned char*)&(msg_id.m_Nonce), sizeof(msg_id.m_Nonce));
-    return msg_id;
-}
-
-mc_OffchainMessageID mc_RelayManager::GenerateMsgID()
-{
-    return GenerateMsgID(mc_TimeNowAsUInt());
-}
-
-uint32_t mc_RelayManager::GenerateNonce()
-{
-    uint32_t nonce;     
-    
-    GetRandBytes((unsigned char*)&nonce, sizeof(nonce));
-    
-    nonce &= 0x7FFFFFFF;
-    
-    return nonce;
-}
-
-mc_OffchainMessageID mc_RelayManager::PushRelay(CNode*    pto, 
-                                uint32_t  msg_format,        
-                                vector <int32_t> &vHops,
-                                vector <int32_t> &vSendPaths,                                
-                                uint32_t  msg_type,
-                                mc_OffchainMessageID msg_id,
-                                mc_OffchainMessageID msg_id_to_respond,
-                                uint32_t  flags,
-                                vector<unsigned char>& payload,
-                                vector<CScript>&  sigScripts_to_relay,
-                                CNode*    pfrom, 
-                                uint32_t  action)
-{
-    vector <unsigned char> vOriginAddress;
-    vector <unsigned char> vDestinationAddress;    
-    vector<CScript>  sigScripts;
-    CScript sigScript;
-    uint256 message_hash;
-    
-    if( (action & MC_PRA_SIGN_WITH_HANDSHAKE_ADDRESS) && (MCP_ANYONE_CAN_CONNECT == 0) )
-    {
-        CHashWriter ssHash(SER_GETHASH, 0);
-        ssHash << msg_type;        
-        ssHash << msg_id.m_TimeStamp;
-        ssHash << msg_id.m_Nonce;
-        ssHash << msg_id_to_respond.m_TimeStamp;
-        ssHash << msg_id_to_respond.m_Nonce;
-        ssHash << flags;
-        ssHash << payload;
-        
-        message_hash=ssHash.GetHash();    
-        
-        CHashWriter ssSig(SER_GETHASH, 0);
-        
-        ssSig << message_hash;
-        ssSig << vector<unsigned char>((unsigned char*)&msg_id_to_respond, (unsigned char*)&msg_id_to_respond+sizeof(msg_id_to_respond));
-        uint256 signed_hash=ssSig.GetHash();
-        CKey key;
-        CKeyID keyID;
-        CPubKey pkey;            
-
-        keyID=pto->kAddrLocal;
-        
-        if(pwalletMain->GetKey(keyID, key))
-        {
-            pkey=key.GetPubKey();
-            vector<unsigned char> vchSig;
-            sigScript.clear();
-            if (key.Sign(signed_hash, vchSig))
-            {
-                vchSig.push_back(0x00);
-                sigScript << vchSig;
-                sigScript << ToByteVector(pkey);
-            }
-            else
-            {
-                LogPrintf("PushRelay(): Internal error: Cannot sign\n");                
-            }
-        }
-        else
-        {
-            LogPrintf("PushRelay(): Internal error: Cannot find key for signature\n");
-        }
-        sigScripts.push_back(sigScript);
-    }    
-    
-    for(unsigned int i=0;i<sigScripts_to_relay.size();i++)
-    {
-        sigScripts.push_back(sigScripts_to_relay[i]);
-    }
-    
-    if(pfrom)
-    {
-        vHops.push_back((int32_t)pfrom->GetId());
-    }
-    
-//    printf("send: %d, to: %d, from: %d, hc: %d, size: %d, ts: %u, nc: %u\n",msg_type,pto->GetId(),pfrom ? pfrom->GetId() : 0,(int)vHops.size(),(int)payload.size(),timestamp,nonce);
-    if(fDebug)LogPrint("offchain","Offchain send: %s, request: %s, to: %d, from: %d, msg: %s, hops: %d, size: %d\n",
-            msg_id.ToString().c_str(),msg_id_to_respond.ToString().c_str(),pto->GetId(),pfrom ? pfrom->GetId() : 0,mc_MsgTypeStr(msg_type).c_str(),(int)vHops.size(),(int)payload.size());
-    pto->PushMessage("offchain",
-                        msg_format,
-                        vHops,
-                        vSendPaths,
-                        msg_type,
-                        msg_id.m_TimeStamp,
-                        msg_id.m_Nonce,
-                        msg_id_to_respond.m_TimeStamp,
-                        msg_id_to_respond.m_Nonce,
-                        flags,
-                        payload,
-                        sigScripts);        
-    
-//    SetRelayRecord(pto,NULL,msg_type,timestamp,nonce);
-    SetRelayRecord(pto,pfrom,msg_type,msg_id);
-    
-    return msg_id;
-}
-    
-bool mc_RelayManager::ProcessRelay( CNode* pfrom, 
-                                    CDataStream& vRecv, 
-                                    CValidationState &state, 
-                                    uint32_t verify_flags_in)
-{
-    uint32_t  msg_type_in;
-    uint32_t verify_flags;
-    int err;
-    mc_OffchainMessageID msg_id_received;
-    mc_OffchainMessageID msg_id_to_respond;
-    vector<unsigned char> vPayloadIn;
-    vector<CScript> vSigScripts;
-    vector<CScript> vSigScriptsEmpty;
-    vector <int32_t> vHops;
-    vector <int32_t> vHopsToRelay;
-    vector <int32_t> vSendPaths;
-    vector <int32_t> vEmptyHops;
-    uint256   message_hash;
-    uint32_t  flags_in,flags_response,flags_relay;
-    vector<unsigned char> vchSigOut;
-    vector<unsigned char> vchPubKey;
-    CPubKey pubkey;
-    vector<CAddress> path;    
-    CNode *pto_stored;
-    uint32_t msg_type_stored;
-    uint32_t msg_format;
-    unsigned char hop_count;
-    uint32_t msg_type_response,msg_type_relay;
-    uint32_t *msg_type_relay_ptr;
-    uint32_t *msg_type_response_ptr;
-    vector<unsigned char> vPayloadResponse;
-    vector<unsigned char> vPayloadRelay;
-    vector<CKeyID>  vAddrIn;    
-    vector<CKeyID>  vAddrResponse;    
-    vector<CKeyID>  vAddrRelay;    
-    string strError;    
-    
-    msg_type_stored=MC_RMT_NONE;
-    msg_type_response=MC_RMT_NONE;
-    msg_type_relay=MC_RMT_NONE;
-    pto_stored=NULL;
-    
-    verify_flags=verify_flags_in;
-    vRecv >> msg_format;
-    if(msg_format != 0)
-    {
-        LogPrintf("ProcessOffchain() : Unsupported message format %08X\n",msg_format);     
-        return false;        
-    }
-        
-    vRecv >> vHops;
-    hop_count=(int)vHops.size();
-    vRecv >> vSendPaths;
-    if(vSendPaths.size())
-    {
-        LogPrintf("ProcessOffchain() : Unsupported send path\n");     
-        return false;                
-    }
-    vRecv >> msg_type_in;
-    switch(msg_type_in)
-    {
-        case MC_RMT_MC_ADDRESS_QUERY:
-            verify_flags |= MC_VRA_IS_NOT_RESPONSE | MC_VRA_NOT_ALLOWED;
-            break;
-        case MC_RMT_NODE_DETAILS:
-            verify_flags |= MC_VRA_IS_RESPONSE | MC_VRA_SIGNATURE_ORIGIN  | MC_VRA_NOT_ALLOWED;
-            break;
-        case MC_RMT_CHUNK_QUERY:
-            verify_flags |= MC_VRA_IS_NOT_RESPONSE;
-            break;
-        case MC_RMT_CHUNK_QUERY_HIT:
-            verify_flags |= MC_VRA_IS_RESPONSE | MC_VRA_SIGNATURE_ORIGIN | MC_VRA_PROCESS_ONCE;
-            break;            
-        case MC_RMT_CHUNK_REQUEST:
-            verify_flags |= MC_VRA_IS_RESPONSE | MC_VRA_DOUBLE_HOP | MC_VRA_SIGNATURE_ORIGIN;
-            break;
-        case MC_RMT_CHUNK_RESPONSE:
-            verify_flags |= MC_VRA_IS_RESPONSE | MC_VRA_DOUBLE_HOP | MC_VRA_SIGNATURE_ORIGIN | MC_VRA_PROCESS_ONCE;
-            break;
-        default:
-            if(verify_flags & MC_VRA_MESSAGE_TYPE)    
-            {
-                LogPrintf("ProcessOffchain() : Unsupported offchain message type %s\n",mc_MsgTypeStr(msg_type_in).c_str());     
-                return false;
-            }
-            break;
-    }
-    
-    if(verify_flags & MC_VRA_NOT_ALLOWED)
-    {
-        LogPrintf("ProcessOffchain() : Not allowed offchain message type %s\n",mc_MsgTypeStr(msg_type_in).c_str());             
-        return false;            
-    }
-    
-    if(verify_flags & MC_VRA_SINGLE_HOP)
-    {
-        if(hop_count)
-        {
-            LogPrintf("ProcessOffchain() : Unsupported hop count %d for msg type %s\n",hop_count,mc_MsgTypeStr(msg_type_in).c_str());     
-            return false;            
-        }
-    }
-    
-    if(verify_flags & MC_VRA_DOUBLE_HOP)
-    {
-        if(hop_count > 1)
-        {
-            LogPrintf("ProcessOffchain() : Unsupported hop count %d for msg type %s\n",hop_count,mc_MsgTypeStr(msg_type_in).c_str());     
-            return false;            
-        }
-    }
-        
-    CheckTime();
-        
-    vRecv >> msg_id_received.m_TimeStamp;
-    
-    if(verify_flags & MC_VRA_TIMESTAMP)
-    {
-        if(msg_id_received.m_TimeStamp+m_MinTimeShift < m_LastTime)
-        {
-            LogPrintf("ProcessOffchain() : Timestamp too far in the past: %d\n",msg_id_received.m_TimeStamp);     
-            return false;                        
-        }
-        if(msg_id_received.m_TimeStamp > m_LastTime + m_MaxTimeShift)
-        {
-            LogPrintf("ProcessOffchain() : Timestamp too far in the future: %d\n",msg_id_received.m_TimeStamp);     
-            return false;                        
-        }
-    }    
-    
-    vRecv >> msg_id_received.m_Nonce;    
-    
-    
-    msg_type_relay_ptr=&msg_type_relay;
-    msg_type_response_ptr=&msg_type_response;
-    
-    if( verify_flags & (MC_VRA_PROCESS_ONCE | MC_VRA_BROADCAST_ONCE))
-    {
-        switch(GetRelayRecord(NULL,msg_id_received,NULL,NULL))
-        {
-            case MC_ERR_NOERROR:
-                if(verify_flags & MC_VRA_PROCESS_ONCE)
-                {
-                    return false;
-                }
-                if(verify_flags & MC_VRA_BROADCAST_ONCE)
-                {
-                    msg_type_relay_ptr=NULL;
-                }
-                break;
-            case MC_ERR_ERROR_IN_SCRIPT:                                        // We already processed this message, it has errors
-                return false;                                        
-            case MC_ERR_NOT_ALLOWED:
-                LogPrintf("ProcessOffchain() : Processing this message is not allowed by current limits or requesting peer was disconnected\n");     
-                return false;                                        
-        }
-    }
-    
-    if(verify_flags & MC_VRA_DOUBLE_HOP)
-    {
-        if(hop_count)
-        {
-            msg_type_relay_ptr=NULL;
-        }
-    }
-    
-        
-    vRecv >> msg_id_to_respond.m_TimeStamp;
-    vRecv >> msg_id_to_respond.m_Nonce;
-    
-    if( verify_flags & MC_VRA_IS_NOT_RESPONSE ) 
-    {
-        if( (msg_id_to_respond.m_TimeStamp != 0) || (msg_id_to_respond.m_Nonce != 0) )
-        {
-            return state.DoS(100, error("ProcessOffchain() : This message should not be response"),REJECT_INVALID, "bad-nonce");                
-        }
-    }
-        
-    if( verify_flags & MC_VRA_IS_RESPONSE ) 
-    {
-        if( msg_id_to_respond.m_TimeStamp == 0 )
-        {
-            return state.DoS(100, error("ProcessOffchain() : This message should be response"),REJECT_INVALID, "bad-nonce");                
-        }
-        
-        if((err=GetRelayRecord(pfrom,msg_id_to_respond,&msg_type_stored,&pto_stored)))
-        {
-            LogPrintf("ProcessOffchain() : Orphan response: %s, request: %s, from: %d, to: %d, msg: %s, hops: %d, size: %d, error: %d\n",
-            msg_id_received.ToString().c_str(),msg_id_to_respond.ToString().c_str(),pfrom->GetId(),pto_stored ? pto_stored->GetId() : 0,mc_MsgTypeStr(msg_type_in).c_str(),hop_count,(int)vPayloadIn.size(),err);
-            return false;
-        }
-    }
-    
-    SetRelayRecord(NULL,pfrom,MC_RMT_ERROR_IN_MESSAGE,msg_id_received);
-    
-    if(msg_id_to_respond.m_TimeStamp)
-    {
-        if(pto_stored)
-        {
-            msg_type_response_ptr=NULL;        
-        }
-        else
-        {
-            msg_type_relay_ptr=NULL;
-        }
-    }
-    
-    map<uint32_t, mc_Limiter>::iterator itlim_all = m_Limiters.find(MC_RMT_NONE);
-    map<uint32_t, mc_Limiter>::iterator itlim_msg = m_Limiters.find(msg_type_in);
-    
-    if(itlim_all != m_Limiters.end())
-    {
-        itlim_all->second.SetEvent(1,vRecv.size());
-        if( verify_flags & MC_VRA_LIMIT_ALL ) 
-        {
-            if(itlim_all->second.Disallowed(m_LastTime))
-            {
-                return false;
-            }
-        }        
-    }
-    
-    if(itlim_msg != m_Limiters.end())
-    {
-        itlim_msg->second.SetEvent(1,vRecv.size());
-        if( verify_flags & MC_VRA_LIMIT_MSG_TYPE ) 
-        {
-            if(itlim_msg->second.Disallowed(m_LastTime))
-            {
-                return false;
-            }
-        }        
-    }
-    
-    vRecv >> flags_in;
-    vRecv >> vPayloadIn;
-    vRecv >> vSigScripts;
-            
-//    printf("recv: %d, from: %d, to: %d, hc: %d, size: %d, ts: %u, nc: %u\n",msg_type_in,pfrom->GetId(),pto_stored ? pto_stored->GetId() : 0,hop_count,(int)vPayloadIn.size(),timestamp_received,nonce_received);
-    if(fDebug)LogPrint("offchain","Offchain recv: %s, request: %s, from: %d, to: %d, msg: %s, hops: %d, size: %d\n",
-            msg_id_received.ToString().c_str(),msg_id_to_respond.ToString().c_str(),pfrom->GetId(),pto_stored ? pto_stored->GetId() : 0,mc_MsgTypeStr(msg_type_in).c_str(),hop_count,(int)vPayloadIn.size());
-    
-    if( verify_flags & MC_VRA_SIGNATURES )
-    {
-        CHashWriter ssHash(SER_GETHASH, 0);
-        ssHash << msg_type_in;        
-        ssHash << msg_id_received.m_TimeStamp;
-        ssHash << msg_id_received.m_Nonce;
-        ssHash << msg_id_to_respond.m_TimeStamp;
-        ssHash << msg_id_to_respond.m_Nonce;
-        ssHash << flags_in;
-        ssHash << vPayloadIn;
-        
-        message_hash=ssHash.GetHash();                
-    
-        if( verify_flags & MC_VRA_SIGNATURE_ORIGIN )
-        {
-            if(vSigScripts.size() < 1)
-            {
-                return state.DoS(100, error("ProcessOffchain() : Missing sigScript"),REJECT_INVALID, "bad-sigscript");                            
-            }
-            if(vSigScripts[0].size())
-            {
-                CScript scriptSig=vSigScripts[0];
-
-                opcodetype opcode;
-
-                CScript::const_iterator pc = scriptSig.begin();
-
-                if (!scriptSig.GetOp(pc, opcode, vchSigOut))
-                {
-                    return state.DoS(100, error("ProcessOffchain() : Cannot extract signature from sigScript"),REJECT_INVALID, "bad-sigscript-signature");                
-                }
-
-                vchSigOut.resize(vchSigOut.size()-1);
-                if (!scriptSig.GetOp(pc, opcode, vchPubKey))
-                {
-                    return state.DoS(100, error("ProcessOffchain() : Cannot extract pubkey from sigScript"),REJECT_INVALID, "bad-sigscript-pubkey");                
-                }
-
-                CPubKey pubKeyOut(vchPubKey);
-                if (!pubKeyOut.IsValid())
-                {
-                    return state.DoS(100, error("ProcessOffchain() : Invalid pubkey"),REJECT_INVALID, "bad-sigscript-pubkey");                
-                }        
-
-                pubkey=pubKeyOut;
-
-                CHashWriter ss(SER_GETHASH, 0);
-                
-                ss << vector<unsigned char>((unsigned char*)&message_hash, (unsigned char*)&message_hash+32);
-                ss << vector<unsigned char>((unsigned char*)&msg_id_to_respond, (unsigned char*)&msg_id_to_respond+sizeof(msg_id_to_respond));
-                uint256 signed_hash=ss.GetHash();
-
-                if(!pubkey.Verify(signed_hash,vchSigOut))
-                {
-                    return state.DoS(100, error("ProcessOffchain() : Wrong signature"),REJECT_INVALID, "bad-signature");                            
-                }        
-            }
-            else
-            {
-                return state.DoS(100, error("ProcessOffchain() : Empty sigScript"),REJECT_INVALID, "bad-sigscript");                
-            }
-        }
-    }
-    
-    if(itlim_all != m_Limiters.end())
-    {
-        itlim_all->second.Increment();
-    }
-    
-    if(itlim_msg != m_Limiters.end())
-    {
-        itlim_msg->second.Increment();        
-    }    
-
-    if(pto_stored)
-    {
-        PushRelay(pto_stored,msg_format,vHops,vSendPaths,msg_type_in,msg_id_received,msg_id_to_respond,flags_in,
-                  vPayloadIn,vSigScripts,pfrom,MC_PRA_NONE);
-    }
-    else
-    {
-        if( (msg_type_relay_ptr != NULL) || (msg_type_response_ptr != NULL) )
-        {
-            if(MultichainRelayResponse(msg_type_stored,pto_stored,
-                                       msg_type_in,flags_in,vPayloadIn,vAddrIn,
-                                       msg_type_response_ptr,&flags_response,vPayloadResponse,vAddrResponse,
-                                       msg_type_relay_ptr,&flags_relay,vPayloadRelay,vAddrRelay,strError))
-            {
-                if(msg_type_response_ptr && *msg_type_response_ptr)
-                {
-                    if(*msg_type_response_ptr != MC_RMT_ADD_RESPONSE)
-                    {
-                        PushRelay(pfrom,0,vEmptyHops,vSendPaths,*msg_type_response_ptr,GenerateMsgID(m_LastTime),msg_id_received,flags_response,
-                                  vPayloadResponse,vSigScriptsEmpty,NULL,MC_PRA_NONE);                    
-                    }
-                    else
-                    {
-                        map<mc_OffchainMessageID, mc_RelayRequest>::iterator itreq = m_Requests.find(msg_id_to_respond);
-                        if(itreq != m_Requests.end())
-                        {
-                            Lock();
-                            AddResponse(itreq->second.m_MsgID,pfrom,vHops.size() ? vHops[0] : 0,hop_count,msg_id_received,msg_type_in,flags_in,vPayloadIn,MC_RST_SUCCESS);
-                            UnLock();
-                        }                        
-                        else
-                        {
-                            if(fDebug)LogPrint("offchain","ProcessOffchain() : Deleted request: %s, request: %s, from: %d, to: %d, msg: %s, hops: %d, size: %d\n",
-                            msg_id_received.ToString().c_str(),msg_id_to_respond.ToString().c_str(),pfrom->GetId(),pto_stored ? pto_stored->GetId() : 0,mc_MsgTypeStr(msg_type_in).c_str(),hop_count,(int)vPayloadIn.size());
-                            return false;                            
-                        }
-                    }
-                }
-                if(msg_type_relay_ptr && *msg_type_relay_ptr)
-                {
-                    LOCK(cs_vNodes);
-                    BOOST_FOREACH(CNode* pnode, vNodes)
-                    {
-                        if(pnode != pfrom)
-                        {
-                            vHopsToRelay=vHops;
-                            PushRelay(pnode,msg_format,vHopsToRelay,vSendPaths,*msg_type_relay_ptr,msg_id_received,msg_id_to_respond,flags_relay,
-                                      vPayloadRelay,vSigScriptsEmpty,pfrom,MC_PRA_NONE);
-                        }
-                    }
-                }                
-            }
-            else
-            {
-                LogPrintf("ProcessOffchain() : Error processing %s (request %s) from peer %d: %s\n",mc_MsgTypeStr(msg_type_in).c_str(),
-                        msg_id_received.ToString().c_str(),pfrom->GetId(),strError.c_str());     
-                return false;                
-            }
-        }        
-    }
-    
-    if(msg_id_to_respond.m_TimeStamp)
-    {
-        SetRelayRecord(NULL,pfrom,msg_type_in,msg_id_received);        
-    }
-    else
-    {
-        SetRelayRecord(NULL,pfrom,MC_RMT_NEW_REQUEST,msg_id_received);
-    }
-    
-    return true;
-}
-
-void mc_RelayResponse::Zero()
-{
-    m_MsgID=0;
-    m_MsgType=MC_RMT_NONE;
-    m_Flags=0;
-    m_NodeFrom=0;
-    m_HopCount=0;
-    m_TryCount=0;
-    m_Source=0;
-    m_LastTryTimestamp=0;
-    m_Status=MC_RST_NONE;
-    m_Payload.clear();
-    m_Requests.clear();    
-    m_TimeDiff=0;
-}
-
-void mc_RelayRequest::Zero()
-{
-    m_MsgID=0;
-    m_MsgType=MC_RMT_NONE;
-    m_Flags=0;
-    m_NodeTo=0;
-    m_LastTryTimestamp=0;
-    m_TryCount=0;
-    m_Status=MC_RST_NONE;
-    m_DestinationID=0;
-    m_Payload.clear();   
-    m_Responses.clear();
-}
-
-int mc_RelayManager::AddRequest(CNode *pto,int64_t destination,mc_OffchainMessageID msg_id,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status)
-{    
-    int err=MC_ERR_NOERROR;
- 
-    map<mc_OffchainMessageID, mc_RelayRequest>::iterator itreq_this = m_Requests.find(msg_id);
-    if(itreq_this == m_Requests.end())
-    {    
-        mc_RelayRequest request;
-
-        request.m_MsgID=msg_id;
-        request.m_MsgType=msg_type;
-        request.m_Flags=flags;
-        request.m_NodeTo=pto ? pto->GetId() : 0;
-        request.m_LastTryTimestamp=0;
-        request.m_TryCount=0;
-        request.m_Status=status;
-        request.m_DestinationID=destination;
-        request.m_Payload=payload;   
-        request.m_Responses.clear();
-
-        if(fDebug)LogPrint("offchain","Offchain rqst: %s, to: %d, msg: %s, size: %d\n",msg_id.ToString().c_str(),pto ? pto->GetId() : 0,mc_MsgTypeStr(msg_type).c_str(),(int)payload.size());
-        m_Requests.insert(make_pair(msg_id,request));
-    }
-    else
-    {
-        err=MC_ERR_FOUND;
-    }    
-    
-    return err;            
-}
-
-int64_t mc_RelayResponse::SourceID()
-{
-    int64_t result=(int64_t)m_NodeFrom;
-    result = (result << 32) + (int64_t)m_Source;
-    return result;
-}
-
-int mc_RelayManager::AddResponse(mc_OffchainMessageID request,CNode *pfrom,int32_t source,int hop_count,mc_OffchainMessageID msg_id,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status)
-{
-//    printf("resp: %lu, mt: %d, node: %d, size: %d, rn: %lu\n",request,msg_type,pfrom ? pfrom->GetId() : 0,(int)payload.size(),nonce);
-    if(fDebug)LogPrint("offchain","Offchain resp: %s, request: %s, from: %d, msg: %s, size: %d\n",
-            msg_id.ToString().c_str(),request.ToString().c_str(),pfrom ? pfrom->GetId() : 0,mc_MsgTypeStr(msg_type).c_str(),(int)payload.size());
-    if(request.IsZero())
-    {
-        return MC_ERR_NOERROR;
-    }
-    
-    mc_RelayResponse response;
-    response.m_MsgID=msg_id;    
-    response.m_MsgType=msg_type;
-    response.m_TimeDiff=msg_id.m_TimeStamp-m_LastTime;
-    response.m_Flags=flags;
-    response.m_NodeFrom=pfrom ? pfrom->GetId() : 0;
-    response.m_HopCount=hop_count;
-    response.m_Source=source;
-    response.m_LastTryTimestamp=0;
-    response.m_Status=status;
-    response.m_Payload=payload;
-    response.m_Requests.clear();    
-    
-    if(!request.IsZero())
-    {
-        map<mc_OffchainMessageID, mc_RelayRequest>::iterator itreq = m_Requests.find(request);
-        if(itreq != m_Requests.end())
-        {    
-            itreq->second.m_Responses.push_back(response);
-            if(status & MC_RST_SUCCESS)
-            {
-                itreq->second.m_Status |= MC_RST_SUCCESS;
-            }
-        }
-        else
-        {
-            return MC_ERR_NOT_FOUND;
-        }
-    }
-    
-    return MC_ERR_NOERROR; 
-}
-
-int mc_RelayManager::DeleteRequest(mc_OffchainMessageID request)
-{
-    int err=MC_ERR_NOERROR;
-
-    Lock();
-    map<mc_OffchainMessageID, mc_RelayRequest>::iterator itreq = m_Requests.find(request);
-    if(itreq != m_Requests.end())
-    {
-        m_Requests.erase(itreq);       
-        if(fDebug)LogPrint("offchain","Offchain delete: %s, msg: %s, size: %d. Open requests: %d\n",itreq->second.m_MsgID.ToString().c_str(),
-            mc_MsgTypeStr(itreq->second.m_MsgType).c_str(),(int)itreq->second.m_Payload.size(),(int)m_Requests.size());
-    }    
-    else
-    {
-        err= MC_ERR_NOT_FOUND;
-    }
-    
-    UnLock();
-    return err;     
-}
-
-mc_RelayRequest *mc_RelayManager::FindRequest(mc_OffchainMessageID request)
-{
-    Lock();
-    map<mc_OffchainMessageID, mc_RelayRequest>::iterator itreq = m_Requests.find(request);
-    if(itreq != m_Requests.end())
-    {
-        return &(itreq->second);
-    }    
-    
-    UnLock();
-    return NULL;    
-}
-
-
-mc_OffchainMessageID mc_RelayManager::SendRequest(CNode* pto,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload)
-{
-    mc_OffchainMessageID msg_id;
-    vector <int32_t> vEmptyHops;
-    vector <int32_t> vEmptySendPaths;
-    vector<CScript> vSigScriptsEmpty;
-
-    msg_id=GenerateMsgID();
-    
-    Lock();
-    {
-        LOCK(cs_vNodes);
-        BOOST_FOREACH(CNode* pnode, vNodes)
-        {
-            if( (pto == NULL) || (pnode == pto) )
-            {
-                PushRelay(pnode,0,vEmptyHops,vEmptySendPaths,msg_type,msg_id,mc_OffchainMessageID(),flags,payload,vSigScriptsEmpty,NULL,0);                    
-            }
-        }
-    }
-
-    if(AddRequest(pto,0,msg_id,msg_type,flags,payload,MC_RST_NONE) != MC_ERR_NOERROR)
-    {
-        UnLock();
-        return mc_OffchainMessageID();
-    }
-    
-    return msg_id;
-}
-
-mc_OffchainMessageID mc_RelayManager::SendNextRequest(mc_RelayResponse* response,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload)
-{
-    mc_OffchainMessageID msg_id;
-    vector <int32_t> vEmptyHops;
-    vector <int32_t> vEmptySendPaths;
-    vector<CScript> vSigScriptsEmpty;
-    
-    msg_id=GenerateMsgID();
-
-    Lock();
-    {
-        LOCK(cs_vNodes);
-        BOOST_FOREACH(CNode* pnode, vNodes)
-        {
-            if( pnode->GetId() == response->m_NodeFrom )
-            {
-                msg_id=PushRelay(pnode,0,vEmptyHops,vEmptySendPaths,msg_type,msg_id,response->m_MsgID,
-                                     flags,payload,vSigScriptsEmpty,NULL,MC_PRA_NONE);                    
-                if(AddRequest(pnode,response->SourceID(),msg_id,msg_type,flags,payload,MC_RST_NONE) != MC_ERR_NOERROR)
-                {                    
-                    UnLock();
-                    return mc_OffchainMessageID();
-                }
-            }
-        }
-    }
-    
-    UnLock();
-    return msg_id;
-}
-
-
-void mc_RelayManager::InvalidateResponsesFromDisconnected()
-{
-    LOCK(cs_vNodes);
-    int m=(int)vNodes.size();
-    Lock();
-    BOOST_FOREACH(PAIRTYPE(const mc_OffchainMessageID,mc_RelayRequest)& item, m_Requests)    
-    {
-        for(int i=0;i<(int)item.second.m_Responses.size();i++)
-        {
-            int n=0;
-            while(n<m)
-            {
-                if(vNodes[n]->GetId() == item.second.m_Responses[i].m_NodeFrom)
-                {
-                    n=m+1;
-                }
-                n++;
-            }
-            if(n == m)
-            {
-                item.second.m_Responses[i].m_Status &= ~MC_RST_SUCCESS;
-                item.second.m_Responses[i].m_Status |= MC_RST_DISCONNECTED;
-            }
-        }
-    }    
-    UnLock();
-}
-
diff --git a/src/protocol/relay.h b/src/protocol/relay.h
deleted file mode 100644
index 82cfee0..0000000
--- a/src/protocol/relay.h
+++ /dev/null
@@ -1,343 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-
-#ifndef RELAY_H
-#define RELAY_H
-
-#include "core/init.h"
-#include "core/main.h"
-#include "utils/util.h"
-#include "wallet/wallet.h"
-#include "multichain/multichain.h"
-#include "keys/pubkey.h"
-#include "keys/key.h"
-#include "net/net.h"
-
-#define MC_PRA_NONE                          0x00000000
-#define MC_PRA_MY_ORIGIN_MC_ADDRESS          0x00000001
-#define MC_PRA_MY_ORIGIN_NT_ADDRESS          0x00000002
-#define MC_PRA_USE_DESTINATION_ADDRESS       0x00000004
-#define MC_PRA_SIGN_WITH_HANDSHAKE_ADDRESS   0x00000020
-
-#define MC_VRA_NONE                          0x00000000
-#define MC_VRA_IS_RESPONSE                   0x00000002
-#define MC_VRA_IS_NOT_RESPONSE               0x00000004
-#define MC_VRA_SIGSCRIPT                     0x00000080
-#define MC_VRA_SIGNATURE_ORIGIN              0x00000100
-#define MC_VRA_SIGNATURE_ALL                 0x00000200
-#define MC_VRA_MESSAGE_TYPE                  0x00010000
-#define MC_VRA_LIMIT_ALL                     0x00020000
-#define MC_VRA_LIMIT_MSG_TYPE                0x00040000
-#define MC_VRA_SINGLE_HOP                    0x00080000
-#define MC_VRA_DOUBLE_HOP                    0x00100000
-#define MC_VRA_SIGNATURES                    0x00200000
-#define MC_VRA_PROCESS_ONCE                  0x00400000
-#define MC_VRA_BROADCAST_ONCE                0x00800000
-#define MC_VRA_SINGLE_HOP_BROADCAST          0x01000000
-#define MC_VRA_TIMESTAMP                     0x02000000
-#define MC_VRA_NOT_ALLOWED                   0x80000000
-
-#define MC_VRA_DEFAULT                       0x03970000
-
-#define MC_RMT_NONE                                   0
-#define MC_RMT_MC_ADDRESS_QUERY              0x7971616d     //maqy
-#define MC_RMT_NODE_DETAILS                  0x7464646e     //nddt
-#define MC_RMT_CHUNK_QUERY                   0x79716863     //chqy
-#define MC_RMT_CHUNK_QUERY_HIT               0x68716863     //chqh
-#define MC_RMT_CHUNK_REQUEST                 0x71726863     //chrq
-#define MC_RMT_CHUNK_RESPONSE                0x73726863     //chrs
-#define MC_RMT_ADD_RESPONSE                  0x00800001
-#define MC_RMT_ERROR_IN_MESSAGE              0x00800002
-#define MC_RMT_NEW_REQUEST                   0x00800003
-#define MC_RMT_SPECIAL_MASK                  0x80000000
-#define MC_RMT_SPECIAL_COLLECT_CHUNKS        0x80000001
-#define MC_RMT_SPECIAL_VIEW_CHUNKS           0x80000002
-
-#define MC_RDT_UNKNOWN                                0
-#define MC_RDT_MC_ADDRESS                          0x01
-#define MC_RDT_NET_ADDRESS                         0x02
-#define MC_RDT_EXPIRATION                          0x03
-#define MC_RDT_CHUNK_IDS                           0x11
-#define MC_RDT_CHUNKS                              0x12
-
-#define MC_LIM_MAX_SECONDS                60
-#define MC_LIM_MAX_MEASURES                4
-
-#define MC_RST_NONE                          0x00000000
-#define MC_RST_DELETED                       0x00000001
-#define MC_RST_SUCCESS                       0x00000002
-#define MC_RST_PERMANENT_FAILURE             0x00000004
-#define MC_RST_TEMPORARY_FAILURE             0x00000008
-#define MC_RST_DISCONNECTED                  0x00000010
-
-using namespace std;
-
-struct mc_ChunkCollector;
-
-bool MultichainRelayResponse(uint32_t msg_type_stored, CNode *pto_stored,
-                             uint32_t msg_type_in, uint32_t  flags, vector<unsigned char>& vPayloadIn,vector<CKeyID>&  vAddrIn,
-                             uint32_t* msg_type_response,uint32_t  *flags_response,vector<unsigned char>& vPayloadResponse,vector<CKeyID>&  vAddrResponse,
-                             uint32_t* msg_type_relay,uint32_t  *flags_relay,vector<unsigned char>& vPayloadRelay,vector<CKeyID>&  vAddrRelay,
-                             string& strError);
-
-int MultichainCollectChunks(mc_ChunkCollector* collector);
-int MultichainCollectChunksQueueStats(mc_ChunkCollector* collector);
-
-
-
-typedef struct mc_Limiter
-{
-    int m_SecondCount;
-    int m_MeasureCount;
-    uint32_t m_Time;
-    int64_t m_Limits[MC_LIM_MAX_MEASURES];
-    int64_t m_Totals[MC_LIM_MAX_MEASURES];
-    int64_t m_Event[MC_LIM_MAX_MEASURES];
-    int64_t m_Measures[MC_LIM_MAX_MEASURES*MC_LIM_MAX_SECONDS];
-    void Zero();
-    int Initialize(int seconds,int measures);
-    int SetLimit(int meausure,int64_t limit);
-    
-    void CheckTime();
-    void CheckTime(uint32_t t);
-    
-    void SetEvent(int64_t m1);
-    void SetEvent(int64_t m1,int64_t m2);
-    void SetEvent(int64_t m1,int64_t m2,int64_t m3);
-    void SetEvent(int64_t m1,int64_t m2,int64_t m3,int64_t m4);
-
-    int Disallowed();
-    int Disallowed(uint32_t t);
-    void Increment();
-    
-} mc_Limiter;
-
-typedef struct mc_OffchainMessageID
-{
-    uint32_t m_TimeStamp;
-    uint96 m_Nonce;
-    
-    mc_OffchainMessageID()
-    {
-        m_TimeStamp=0;
-        m_Nonce=0;
-    }
-       
-    
-    friend bool operator<(const mc_OffchainMessageID& a, const mc_OffchainMessageID& b)
-    {
-        return ((a.m_TimeStamp < b.m_TimeStamp) || 
-                (a.m_TimeStamp == b.m_TimeStamp && a.m_Nonce < b.m_Nonce));
-    }
-
-    friend bool operator==(const mc_OffchainMessageID& a, const mc_OffchainMessageID& b)
-    {
-        return (a.m_TimeStamp == b.m_TimeStamp && a.m_Nonce == b.m_Nonce);
-    }
-    
-    friend bool operator!=(const mc_OffchainMessageID& a, const mc_OffchainMessageID& b)
-    {
-        return (a.m_TimeStamp != b.m_TimeStamp || a.m_Nonce != b.m_Nonce);
-    }
-    
-    
-    mc_OffchainMessageID& operator=(const mc_OffchainMessageID& b)
-    {
-        m_TimeStamp=b.m_TimeStamp;
-        m_Nonce=b.m_Nonce;
-        return *this;
-    }
-    
-    mc_OffchainMessageID& operator=(const uint32_t& b)
-    {
-        m_TimeStamp=b;
-        m_Nonce=0;
-        return *this;
-    }
-    
-    bool IsZero()
-    {
-        return (m_TimeStamp == 0 && m_Nonce == 0);        
-    }
-    
-    std::string ToString()
-    {
-        return strprintf("%s-%d",m_Nonce.ToString().c_str(),m_TimeStamp);
-    }
-} mc_OffchainMessageID;
-
-
-typedef struct mc_NodeFullAddress
-{
-    CKeyID              m_Address;
-    vector<CAddress>    m_NetAddresses;
-    
-    void Zero();   
-    
-    mc_NodeFullAddress()
-    {
-        Zero();
-    }
-    
-} mc_NodeFullAddress;
-
-typedef struct mc_RelayRecordKey
-{
-    mc_OffchainMessageID m_ID;
-    NodeId m_NodeTo;
-
-    mc_RelayRecordKey(mc_OffchainMessageID msg_id,NodeId node)
-    {
-        m_ID=msg_id;
-        m_NodeTo=node;
-    }
-    
-    friend bool operator<(const mc_RelayRecordKey& a, const mc_RelayRecordKey& b)
-    {
-        return ((a.m_ID < b.m_ID) || 
-                (a.m_ID == b.m_ID && a.m_NodeTo < b.m_NodeTo));
-    }
-    
-} mc_RelayRecordKey;
-
-typedef struct mc_RelayRecordValue
-{
-    uint32_t m_MsgType;
-    NodeId m_NodeFrom;
-    uint32_t m_Timestamp;
-    int m_Count;
-    
-} mc_RelayRecordValue;
-
-struct mc_RelayRequest;
-
-typedef struct mc_RelayResponse
-{
-    mc_OffchainMessageID m_MsgID;
-    int m_TimeDiff;
-    uint32_t m_MsgType;
-    uint32_t m_Flags;
-    NodeId m_NodeFrom;
-    int m_HopCount;
-    int m_TryCount;
-    int32_t m_Source;
-    uint32_t m_LastTryTimestamp;
-    uint32_t m_Status;
-    vector <unsigned char> m_Payload;
-    vector <mc_RelayRequest> m_Requests;
-    
-    mc_RelayResponse()
-    {
-        Zero();
-    }
-    
-    void Zero();
-    int64_t SourceID();
-} mc_RelayResponse;
-
-typedef struct mc_RelayRequest
-{
-    mc_OffchainMessageID m_MsgID;
-    uint32_t m_MsgType;
-    uint32_t m_Flags;
-    NodeId m_NodeTo;
-    uint32_t m_LastTryTimestamp;
-    int m_TryCount;
-    uint32_t m_Status;
-    int64_t m_DestinationID;
-    vector <unsigned char> m_Payload;   
-    vector <mc_RelayResponse> m_Responses;
-    
-    mc_RelayRequest()
-    {
-        Zero();
-    }
-    
-    void Zero();
-} mc_RelayRequest;
-
-typedef struct mc_RelayManager
-{
-    uint32_t m_MyIPs[64];
-    int m_MaxResponses;
-    int m_MyIPCount;
-    uint32_t m_LastTime;    
-    uint32_t m_MinTimeShift;
-    uint32_t m_MaxTimeShift;
-    void *m_Semaphore;                                                          
-    uint64_t m_LockedBy;                                                        
-    mc_NodeFullAddress m_MyAddress;
-            
-    mc_RelayManager()
-    {
-        Zero();        
-    };
-    
-    ~mc_RelayManager()
-    {
-        Destroy();        
-    };
-    
-    map<uint32_t,int> m_Latency;
-    map<uint32_t,mc_Limiter> m_Limiters;
-    map<const mc_RelayRecordKey,mc_RelayRecordValue> m_RelayRecords;
-    map<mc_OffchainMessageID,mc_RelayRequest> m_Requests;
-    
-    void Zero();
-    void Destroy();
-    int Lock();
-    int Lock(int write_mode, int allow_secondary);
-    void UnLock();        
-    int Initialize();
-    
-    uint32_t GenerateNonce();
-    mc_OffchainMessageID GenerateMsgID(uint32_t timestamp);
-    mc_OffchainMessageID GenerateMsgID();
-    void SetDefaults();
-    void SetMyIPs(uint32_t *ips,int ip_count);
-    void MsgTypeSettings(uint32_t msg_type,int latency,int seconds,int64_t serves_per_second,int64_t bytes_per_second); 
-    void InitNodeAddress(mc_NodeFullAddress* node_address,CNode* pto,uint32_t action);
-    void InitNodeAddress(mc_NodeFullAddress* node_address,CKeyID& mc_address, vector<CAddress>& net_addresses);
-    void CheckTime();
-    void SetRelayRecord(CNode *pto,CNode *pfrom,uint32_t msg_type,mc_OffchainMessageID msg_id);
-    int GetRelayRecord(CNode *pfrom,mc_OffchainMessageID msg_id,uint32_t *msg_type,CNode **pto);
-    
-    mc_OffchainMessageID PushRelay(CNode*    pto, 
-                                uint32_t  msg_format,        
-                                vector <int32_t> &vHops,
-                                vector <int32_t> &vSendPaths,                                
-                                uint32_t  msg_type,
-                                mc_OffchainMessageID msg_id,
-                                mc_OffchainMessageID msg_id_to_respond,
-                                uint32_t  flags,
-                                vector<unsigned char>& payload,
-                                vector<CScript>&  sigScripts_to_relay,
-                                CNode*    pfrom, 
-                                uint32_t  action);
-    
-    bool ProcessRelay       (   CNode* pfrom, 
-                                CDataStream& vRecv, 
-                                CValidationState &state, 
-                                uint32_t verify_flags_in);
-
-    int AddRequest(CNode *pto,int64_t destination,mc_OffchainMessageID msg_id,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status);
-//    int AddRequest(int64_t parent_nonce,int parent_response_id,CNode *pto,int64_t nonce,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status);
-    int AddResponse(mc_OffchainMessageID request,CNode *pfrom,int32_t source,int hop_count,mc_OffchainMessageID msg_id,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status);
-    //int AddResponse(int64_t request,CNode *pfrom,int32_t source,int hop_count,int64_t nonce,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload,uint32_t status);
-    int DeleteRequest(mc_OffchainMessageID request);
-    int ProcessRequest(mc_OffchainMessageID request);
-    mc_RelayRequest *FindRequest(mc_OffchainMessageID request);
-    void InvalidateResponsesFromDisconnected();
-    
-    mc_OffchainMessageID SendRequest(CNode* pto,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload);
-//    int64_t SendRequest(CNode* pto,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload);
-    mc_OffchainMessageID SendNextRequest(mc_RelayResponse* response,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload);
-//    int64_t SendNextRequest(mc_RelayResponse* response,uint32_t msg_type,uint32_t flags,vector <unsigned char>& payload);
-}   mc_RelayManager;
-
-
-
-
-#endif /* RELAY_H */
-
diff --git a/src/rpc/rpcassets.cpp b/src/rpc/rpcassets.cpp
index 94b86eb..2529730 100644
--- a/src/rpc/rpcassets.cpp
+++ b/src/rpc/rpcassets.cpp
@@ -9,6 +9,11 @@
 
 void mergeGenesisWithAssets(mc_Buffer *genesis_amounts, mc_Buffer *asset_amounts)
 {
+    if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+    {
+        return; 
+    }
+    
     unsigned char buf[MC_AST_ASSET_FULLREF_BUF_SIZE];
     int64_t quantity;
     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
@@ -127,7 +132,6 @@ Value issuefromcmd(const Array& params, bool fHelp)
     string asset_name="";
     bool is_open=false;
     bool name_is_found=false;
-    uint32_t permissions=0;
     
     if (params.size() > 2 && params[2].type() != null_type)// && !params[2].get_str().empty())
     {
@@ -155,24 +159,6 @@ Value issuefromcmd(const Array& params, bool fHelp)
                         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid value for 'open' field, should be boolean");                                                                
                     }
                 }
-                if(s.name_ == "restrict")
-                {
-                    if(mc_gState->m_Features->PerAssetPermissions() == 0)
-                    {
-                        throw JSONRPCError(RPC_NOT_SUPPORTED, "Per-asset permissions not supported for this protocol version");   
-                    }
-                    if(permissions == 0)
-                    {
-                        if(s.value_.type() == str_type)
-                        {
-                            permissions=mc_gState->m_Permissions->GetPermissionType(s.value_.get_str().c_str(),MC_PTP_SEND | MC_PTP_RECEIVE);
-                            if(permissions == 0)
-                            {
-                                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid value for restrict field");                                                                                                
-                            }
-                        }
-                    }
-                }
             }
         }
         else
@@ -184,9 +170,12 @@ Value issuefromcmd(const Array& params, bool fHelp)
         }
     }
     
-    if(asset_name == "*")
+    if(mc_gState->m_Features->Streams())
     {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid asset name: *");                                                                                            
+        if(asset_name == "*")
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid asset name: *");                                                                                            
+        }
     }
     
     unsigned char buf_a[MC_AST_ASSET_REF_SIZE];    
@@ -214,11 +203,14 @@ Value issuefromcmd(const Array& params, bool fHelp)
     lpDetails->Clear();
     lpDetails->AddElement();
     
-    if(asset_name.size())
+    if(mc_gState->m_Features->OpDropDetailsScripts())
     {
-        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(asset_name.c_str()),asset_name.size());//+1);
-    }        
-    lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
+        if(asset_name.size())
+        {
+            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(asset_name.c_str()),asset_name.size());//+1);
+        }        
+        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
+    }
     
     if(is_open)
     {
@@ -226,12 +218,6 @@ Value issuefromcmd(const Array& params, bool fHelp)
         lpDetails->SetSpecialParamValue(MC_ENT_SPRM_FOLLOW_ONS,&b,1);
     }
     
-    if(permissions)
-    {
-        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_PERMISSIONS,(unsigned char*)&permissions,1);                                
-    }
-
-/*    
     if (params.size() > 6)
     {
         if(params[6].type() == obj_type)
@@ -247,7 +233,6 @@ Value issuefromcmd(const Array& params, bool fHelp)
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields, expecting object");                                        
         }
     }
- */ 
     int err;
     size_t bytes;
     const unsigned char *script;
@@ -255,40 +240,38 @@ Value issuefromcmd(const Array& params, bool fHelp)
     const unsigned char *elem;
     CScript scriptOpReturn=CScript();
     
-    
-        
-    vector<CTxDestination> addresses;    
-    vector<CTxDestination> fromaddresses;        
-    int errorCode=RPC_INVALID_PARAMETER;
-    string strError;    
+    script=lpDetails->GetData(0,&bytes);
     lpDetailsScript->Clear();
-    if (params.size() > 6)
+        
+    if(mc_gState->m_Features->OpDropDetailsScripts())
     {
-        ParseRawDetails(&(params[6]),lpDetails,lpDetailsScript,&errorCode,&strError);        
-        if(strError.size())
+        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,0,script,bytes);
+        if(err)
         {
-            goto exitlbl;
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or asset name, too long");                                                        
         }
-    }
-    
-    script=lpDetails->GetData(0,&bytes);
-    lpDetailsScript->Clear();
         
-    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,0,script,bytes);
-    if(err)
-    {
-        strError= "Invalid custom fields or asset name, too long";
-        goto exitlbl;
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or asset name, too long");                                                        
+        elem = lpDetailsScript->GetData(0,&elem_size);
+        scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                    
     }
+    else
+    {
+        err=lpDetailsScript->SetAssetDetails(asset_name.c_str(),multiple,script,bytes);
+        if(err)
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or asset name, too long");                                                    
+        }
 
-    elem = lpDetailsScript->GetData(0,&elem_size);
-    scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                    
+        elem = lpDetailsScript->GetData(0,&elem_size);
+        scriptOpReturn << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+    }
         
     
 
+    vector<CTxDestination> addresses;    
     addresses.push_back(address.Get());
     
+    vector<CTxDestination> fromaddresses;        
     
     if(params[0].get_str() != "*")
     {
@@ -296,17 +279,12 @@ Value issuefromcmd(const Array& params, bool fHelp)
 
         if(fromaddresses.size() != 1)
         {
-            strError= "Single from-address should be specified";
-            goto exitlbl;
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
         }
 
         if( (IsMine(*pwalletMain, fromaddresses[0]) & ISMINE_SPENDABLE) != ISMINE_SPENDABLE )
         {
-            strError= "Private key for from-address is not found in this wallet";
-            errorCode=RPC_WALLET_ADDRESS_NOT_FOUND;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
+            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
         }
         
         set<CTxDestination> thisFromAddresses;
@@ -319,10 +297,7 @@ Value issuefromcmd(const Array& params, bool fHelp)
         CPubKey pkey;
         if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_ISSUE,&thisFromAddresses))
         {
-            strError= "from-address doesn't have issue permission";
-            errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have issue permission");                
+            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have issue permission");                
         }   
     }
     else
@@ -330,28 +305,15 @@ Value issuefromcmd(const Array& params, bool fHelp)
         CPubKey pkey;
         if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_ISSUE))
         {
-            strError= "This wallet doesn't have keys with issue permission";
-            errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "This wallet doesn't have keys with issue permission");                
+            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "This wallet doesn't have keys with issue permission");                
         }        
     }
     
     EnsureWalletIsUnlocked();
-    {
-        LOCK (pwalletMain->cs_wallet_send);
-
-        SendMoneyToSeveralAddresses(addresses, nAmount, wtx, lpScript, scriptOpReturn,fromaddresses);
-    }
-
-exitlbl:    
-    
+    LOCK (pwalletMain->cs_wallet_send);
     
-    if(strError.size())
-    {
-        throw JSONRPCError(errorCode, strError);            
-    }
-                
+    SendMoneyToSeveralAddresses(addresses, nAmount, wtx, lpScript, scriptOpReturn,fromaddresses);
+  
     return wtx.GetHash().GetHex();    
 }
  
@@ -401,6 +363,13 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
     {        
         ParseEntityIdentifier(params[2],&entity, MC_ENT_TYPE_ASSET);           
         memcpy(buf,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
+        if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+        {
+            if(entity.IsUnconfirmedGenesis())
+            {
+                throw JSONRPCError(RPC_UNCONFIRMED_ENTITY, string("Unconfirmed asset: ")+params[2].get_str());            
+            }
+        }
         multiple=entity.GetAssetMultiple();        
     }
     else
@@ -444,22 +413,6 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
     
     lpDetails->AddElement();
         
-    vector<CTxDestination> addresses;    
-    vector<CTxDestination> fromaddresses;        
-    CScript scriptOpReturn=CScript();
-    int errorCode=RPC_INVALID_PARAMETER;
-    string strError;    
-    if (params.size() > 5)
-    {
-        ParseRawDetails(&(params[5]),lpDetails,lpDetailsScript,&errorCode,&strError);        
-        if(strError.size())
-        {
-            goto exitlbl;
-        }
-    }
-    lpDetailsScript->Clear();
-
-/*    
     if (params.size() > 5)
     {
         if(params[5].type() == obj_type)
@@ -475,34 +428,46 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid extra-params, expecting object");                                        
         }
     }
-*/    
+    
     int err;
     size_t bytes;
     const unsigned char *script;
     size_t elem_size;
     const unsigned char *elem;
+    CScript scriptOpReturn=CScript();
     
     script=lpDetails->GetData(0,&bytes);
     if(bytes > 0)
     {
-        lpDetailsScript->SetEntity(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,1,script,bytes);
-        if(err)
+//        mc_DumpSize("script",script,bytes,bytes);
+        if(mc_gState->m_Features->OpDropDetailsScripts())
         {
-            strError= "Invalid custom fields, too long";
-            goto exitlbl;
-        }
+            lpDetailsScript->SetEntity(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET);
+            err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,1,script,bytes);
+            if(err)
+            {
+                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields, too long");                                                        
+            }
 
-        elem = lpDetailsScript->GetData(0,&elem_size);
-        scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
-        elem = lpDetailsScript->GetData(1,&elem_size);
-        scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                
+            elem = lpDetailsScript->GetData(0,&elem_size);
+            scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
+            elem = lpDetailsScript->GetData(1,&elem_size);
+            scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;                
+        }
+        else
+        {
+            lpDetailsScript->SetGeneralDetails(script,bytes);
+            elem = lpDetailsScript->GetData(0,&elem_size);
+            scriptOpReturn << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+        }
     }
         
     
 
+    vector<CTxDestination> addresses;    
     addresses.push_back(address.Get());
     
+    vector<CTxDestination> fromaddresses;        
     
     if(params[0].get_str() != "*")
     {
@@ -510,17 +475,12 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
 
         if(fromaddresses.size() != 1)
         {
-            strError= "Single from-address should be specified";
-            goto exitlbl;
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
         }
         
         if( (IsMine(*pwalletMain, fromaddresses[0]) & ISMINE_SPENDABLE) != ISMINE_SPENDABLE )
         {
-            strError= "Private key for from-address is not found in this wallet";
-            errorCode=RPC_WALLET_ADDRESS_NOT_FOUND;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
+            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
         }        
     }
     else
@@ -545,17 +505,12 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
                 {
                     if(mc_gState->m_Permissions->CanIssue(entity.GetTxID(),(unsigned char*)(lpKeyID)) == 0)
                     {
-                        strError= "Issuing more units for this asset is not allowed from this address";
-                        errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-                        goto exitlbl;
-//                        throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "Issuing more units for this asset is not allowed from this address");                                                                        
+                        throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "Issuing more units for this asset is not allowed from this address");                                                                        
                     }                                                 
                 }
                 else
                 {
-                    strError= "Issuing more units is allowed only from P2PKH addresses";
-                    goto exitlbl;
-//                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Issuing more units is allowed only from P2PKH addresses");                                                
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Issuing more units is allowed only from P2PKH addresses");                                                
                 }
             }
             else
@@ -576,44 +531,26 @@ Value issuemorefromcmd(const Array& params, bool fHelp)
                 }                    
                 if(!issuer_found)
                 {
-                    strError= "Issuing more units for this asset is not allowed from this wallet";
-                    errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-                    goto exitlbl;
-//                    throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "Issuing more units for this asset is not allowed from this wallet");                                                                                            
+                    throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "Issuing more units for this asset is not allowed from this wallet");                                                                                            
                 }
             }
         }
         else
         {
-            strError= "Issuing more units not allowed for this asset: "+params[2].get_str();
-            errorCode=RPC_NOT_ALLOWED;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_NOT_ALLOWED, "Issuing more units not allowed for this asset: "+params[2].get_str());                            
+            throw JSONRPCError(RPC_NOT_ALLOWED, "Issuing more units not allowed for this asset: "+params[2].get_str());                            
         }
     }   
     else
     {
-        strError= "Asset not found";
-        errorCode=RPC_ENTITY_NOT_FOUND;
-        goto exitlbl;
-//        throw JSONRPCError(RPC_ENTITY_NOT_FOUND, "Asset not found");                
+        throw JSONRPCError(RPC_ENTITY_NOT_FOUND, "Asset not found");                
     }
     
     
     EnsureWalletIsUnlocked();
-    {
-        LOCK (pwalletMain->cs_wallet_send);
-
-        SendMoneyToSeveralAddresses(addresses, nAmount, wtx, lpScript, scriptOpReturn,fromaddresses);
-    }
-    
-exitlbl:    
+    LOCK (pwalletMain->cs_wallet_send);
     
-    if(strError.size())
-    {
-        throw JSONRPCError(errorCode, strError);            
-    }
-                
+    SendMoneyToSeveralAddresses(addresses, nAmount, wtx, lpScript, scriptOpReturn,fromaddresses);
+
     return wtx.GetHash().GetHex();    
 }
  
@@ -1172,19 +1109,26 @@ Value getaddressbalances(const Array& params, bool fHelp)
                     quantity=mc_GetABQuantity(asset_amounts->GetRow(a));
                     if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&hash))
                     {
-                        ptr=(unsigned char *)entity.GetFullRef();
-                        memcpy(buf,ptr,MC_AST_ASSET_FULLREF_SIZE);
-                        int row=asset_amounts->Seek(buf);
-                        if(row >= 0)
+                        if((entity.IsUnconfirmedGenesis() != 0) && (mc_gState->m_Features->ShortTxIDInTx() == 0) )
                         {
-                            int64_t last=mc_GetABQuantity(asset_amounts->GetRow(row));
-                            quantity+=last;
-                            mc_SetABQuantity(asset_amounts->GetRow(row),quantity);
+                            is_genesis=true;                                
                         }
                         else
                         {
-                            mc_SetABQuantity(buf,quantity);
-                            asset_amounts->Add(buf);                        
+                            ptr=(unsigned char *)entity.GetFullRef();
+                            memcpy(buf,ptr,MC_AST_ASSET_FULLREF_SIZE);
+                            int row=asset_amounts->Seek(buf);
+                            if(row >= 0)
+                            {
+                                int64_t last=mc_GetABQuantity(asset_amounts->GetRow(row));
+                                quantity+=last;
+                                mc_SetABQuantity(asset_amounts->GetRow(row),quantity);
+                            }
+                            else
+                            {
+                                mc_SetABQuantity(buf,quantity);
+                                asset_amounts->Add(buf);                        
+                            }
                         }
                     }                
                     
@@ -1388,19 +1332,26 @@ Value getassetbalances(const Array& params, bool fHelp)
                     quantity=mc_GetABQuantity(asset_amounts->GetRow(a));
                     if(mc_gState->m_Assets->FindEntityByTxID(&entity,(unsigned char*)&hash))
                     {
-                        ptr=(unsigned char *)entity.GetFullRef();
-                        memcpy(buf,ptr,MC_AST_ASSET_FULLREF_SIZE);
-                        int row=asset_amounts->Seek(buf);
-                        if(row >= 0)
+                        if((entity.IsUnconfirmedGenesis() != 0) && (mc_gState->m_Features->ShortTxIDInTx() == 0) )
                         {
-                            int64_t last=mc_GetABQuantity(asset_amounts->GetRow(row));
-                            quantity+=last;
-                            mc_SetABQuantity(asset_amounts->GetRow(row),quantity);
+                            is_genesis=true;
                         }
                         else
                         {
-                            mc_SetABQuantity(buf,quantity);
-                            asset_amounts->Add(buf);                        
+                            ptr=(unsigned char *)entity.GetFullRef();
+                            memcpy(buf,ptr,MC_AST_ASSET_FULLREF_SIZE);
+                            int row=asset_amounts->Seek(buf);
+                            if(row >= 0)
+                            {
+                                int64_t last=mc_GetABQuantity(asset_amounts->GetRow(row));
+                                quantity+=last;
+                                mc_SetABQuantity(asset_amounts->GetRow(row),quantity);
+                            }
+                            else
+                            {
+                                mc_SetABQuantity(buf,quantity);
+                                asset_amounts->Add(buf);                        
+                            }
                         }
                     }                
                     
@@ -1455,7 +1406,7 @@ Value getassetbalances(const Array& params, bool fHelp)
         asset_entry=AssetEntry(ptr,mc_GetLE(ptr+32,MC_AST_ASSET_QUANTITY_SIZE),0x00);
         assets.push_back(asset_entry);
     }
-        
+
 /* MCHN END */        
     return assets;
 }
@@ -1636,16 +1587,8 @@ Object ListAssetTransactions(const CWalletTx& wtx, mc_EntityDetails *entity, boo
     unsigned char bufEmptyAssetRef[MC_AST_ASSET_QUANTITY_OFFSET];
     uint32_t new_entity_type;
     set<uint256> streams_already_seen;
-//    Array aMetaData;
+    Array aMetaData;
     Array aItems;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status;
-    Array aFormatMetaData;
-    vector<Array> aFormatMetaDataPerOutput;
-//    string format_text_str;
     
     double units=1.;
     units= 1./(double)(entity->GetAssetMultiple());
@@ -1713,8 +1656,6 @@ Object ListAssetTransactions(const CWalletTx& wtx, mc_EntityDetails *entity, boo
         }
     }    
 
-    aFormatMetaDataPerOutput.resize(wtx.vout.size());
-
     for (int i = 0; i < (int)wtx.vout.size(); ++i)
     {
         const CTxOut& txout = wtx.vout[i];
@@ -1771,32 +1712,23 @@ Object ListAssetTransactions(const CWalletTx& wtx, mc_EntityDetails *entity, boo
             lpScript->Clear();
             lpScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTPUBKEY);
             
-//            lpScript->ExtractAndDeleteDataFormat(&format);
-            lpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
+            size_t elem_size;
             const unsigned char *elem;
 
             if(lpScript->GetNumElements()<=1)
             {
                 if(lpScript->GetNumElements()==1)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-                    Value metadata=OpReturnFormatEntry(elem,out_size,wtx.GetHash(),i,format,NULL,retrieve_status);
-                    aFormatMetaData.push_back(metadata);
-                    aFormatMetaDataPerOutput[i].push_back(metadata);
+                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
                 }                        
             }
             else
             {
-                if(mc_gState->m_Compatibility & MC_VCM_1_0)
+                elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                if(elem_size)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-                    if(out_size)
-                    {
-//                        aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
-                        aFormatMetaData.push_back(OpReturnFormatEntry(elem,out_size,wtx.GetHash(),i,format,NULL,retrieve_status));
-                    }
+                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
                 }
                 
                 lpScript->SetElement(0);
@@ -1837,18 +1769,7 @@ Object ListAssetTransactions(const CWalletTx& wtx, mc_EntityDetails *entity, boo
                 aTxOutItems.push_back(data_item_entry);
             }
             Object txout_entry=TxOutEntry(wtx.vout[i],i,TxIn,wtx.GetHash(),amounts,lpScript);
-            if( (aTxOutItems.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-            {
-                txout_entry.push_back(Pair("items", aTxOutItems));
-            }
-            if( (mc_gState->m_Compatibility & MC_VCM_1_0) == 0)
-            {
-                if(aFormatMetaDataPerOutput[i].size())
-                {
-                    txout_entry.push_back(Pair("data", aFormatMetaDataPerOutput[i]));                    
-                }
-            }
-            
+            txout_entry.push_back(Pair("items", aTxOutItems));
             vout.push_back(txout_entry);
         }
     }        
@@ -1877,7 +1798,7 @@ Object ListAssetTransactions(const CWalletTx& wtx, mc_EntityDetails *entity, boo
     
     entry.push_back(Pair("addresses", oBalance));
     entry.push_back(Pair("items", aItems));
-    entry.push_back(Pair("data", aFormatMetaData));
+    entry.push_back(Pair("data", aMetaData));
     
     WalletTxToJSON(wtx, entry, true);
 
@@ -2012,7 +1933,7 @@ Value listassettransactions(const Array& params, bool fHelp)
     mc_Script *lpScript=mc_gState->m_TmpBuffers->m_RpcScript3;
     lpScript->Clear();    
 
-    pwalletTxsMain->GetList(&entStat.m_Entity,1,1,entity_rows);
+    CheckWalletError(pwalletTxsMain->GetList(&entStat.m_Entity,1,1,entity_rows));
     shift=1;
     if(entity_rows->GetCount())
     {
@@ -2040,7 +1961,7 @@ Value listassettransactions(const Array& params, bool fHelp)
         }
     }
     
-    pwalletTxsMain->GetList(&entStat.m_Entity,start+1,count,entity_rows);
+    CheckWalletError(pwalletTxsMain->GetList(&entStat.m_Entity,start+1,count,entity_rows));
     
     
     for(int i=0;i<entity_rows->GetCount()+shift;i++)
diff --git a/src/rpc/rpcblockchain.cpp b/src/rpc/rpcblockchain.cpp
index 6078981..ab51c39 100644
--- a/src/rpc/rpcblockchain.cpp
+++ b/src/rpc/rpcblockchain.cpp
@@ -30,7 +30,6 @@ vector<int> ParseBlockSetIdentifier(Value blockset_identifier);
 bool CreateAssetBalanceList(const CTxOut& out,mc_Buffer *amounts,mc_Script *lpScript);
 Object AssetEntry(const unsigned char *txid,int64_t quantity,uint32_t output_level);
 Array PermissionEntries(const CTxOut& txout,mc_Script *lpScript,bool fLong);
-Array PerOutputDataEntries(const CTxOut& txout,mc_Script *lpScript,uint256 txid,int vout);
 string EncodeHexTx(const CTransaction& tx);
 int OrphanPoolSize();
 bool paramtobool(Value param);
@@ -526,7 +525,7 @@ Value gettxout(const Array& params, bool fHelp)
        
     mc_Script *lpScript=mc_gState->m_TmpBuffers->m_RpcScript3;
     lpScript->Clear();
-    
+       
     asset_amounts->Clear();
     CTxOut txout=coins.vout[n];
     if(CreateAssetBalanceList(txout,asset_amounts,lpScript))
@@ -562,21 +561,11 @@ Value gettxout(const Array& params, bool fHelp)
             assets.push_back(asset_entry);
         }
 
-        if( (assets.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-        {
-            ret.push_back(Pair("assets", assets));
-        }
+        ret.push_back(Pair("assets", assets));
     }
     Array permissions=PermissionEntries(txout,lpScript,false);
-    if( (permissions.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-    {
-        ret.push_back(Pair("permissions", permissions));
-    }
-    Array data=PerOutputDataEntries(txout,lpScript,hash,n);
-    if(data.size())
-    {
-        ret.push_back(Pair("data", data));
-    }
+    ret.push_back(Pair("permissions", permissions));
+    
 /* MCHN END */        
 
     return ret;
diff --git a/src/rpc/rpccache.cpp b/src/rpc/rpccache.cpp
deleted file mode 100644
index 87d1dd9..0000000
--- a/src/rpc/rpccache.cpp
+++ /dev/null
@@ -1,116 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "rpc/rpcutils.h"
-
-
-Value createbinarycache(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() != 0)  
-        throw runtime_error("Help message not found\n");
-    
-    unsigned char dest[8];
-    string str;
-    int fHan;
-    
-    while(true)
-    {
-        GetRandBytes((unsigned char*)dest, 8);
-        str=EncodeBase58((unsigned char*)(&dest[0]),(unsigned char*)(&dest[0])+8);
-        fHan=mc_BinaryCacheFile(str,0);
-        if(fHan > 0)
-        {
-            close(fHan);
-        }
-        else
-        {
-            fHan=mc_BinaryCacheFile(str,1);
-            if(fHan > 0)
-            {
-                close(fHan);
-            }
-            else
-            {
-                throw JSONRPCError(RPC_INTERNAL_ERROR, "Cannot store binary cache item"); 
-            }
-            return str;
-        }
-    }
-    
-
-    return Value::null;
-}
-
-Value appendbinarycache(const Array& params, bool fHelp)
-{
-    vector<unsigned char> vValue;
-    int64_t size;
-    
-    if (fHelp || params.size() != 2)  
-        throw runtime_error("Help message not found\n");
-    
-    if(params[0].type() != str_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "cache identifier should be string");                                                                                                                
-    }
-
-    if(params[1].type() != str_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data should be hexadecimal string");                                                                                                                
-    }
-    
-    bool fIsHex;
-    vValue=ParseHex(params[1].get_str().c_str(),fIsHex);    
-    if(!fIsHex)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data should be hexadecimal string");                                                                                                                
-    }        
-    
-    int fHan=mc_BinaryCacheFile(params[0].get_str(),2);
-    if(fHan <= 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Binary cache item with this identifier not found");                                                                                                                        
-    }
-    
-    size=lseek64(fHan,0,SEEK_END);
-    
-    if(vValue.size())
-    {
-        if(write(fHan,&vValue[0],vValue.size()) != (int)vValue.size())
-        {
-            close(fHan);
-            throw JSONRPCError(RPC_INTERNAL_ERROR, "Cannot store binary cache item");                                                                                                                                    
-        }
-    }
-    
-    close(fHan);
-    
-    size+=vValue.size();
-    
-    return size;
-}
-
-Value deletebinarycache(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() != 1)  
-        throw runtime_error("Help message not found\n");
-    
-    if(params[0].type() != str_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "cache identifier should be string");                                                                                                                
-    }
-    
-    int fHan=mc_BinaryCacheFile(params[0].get_str(),0);
-    if(fHan <= 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Binary cache item with this identifier not found");                                                                                                                        
-    }
-    
-    close(fHan);
-    
-    mc_RemoveBinaryCacheFile(params[0].get_str());
-    
-    return Value::null;    
-}
-
-
diff --git a/src/rpc/rpcchunks.cpp b/src/rpc/rpcchunks.cpp
deleted file mode 100644
index d7c0a6e..0000000
--- a/src/rpc/rpcchunks.cpp
+++ /dev/null
@@ -1,56 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "core/init.h"
-#include "wallet/chunkcollector.h"
-#include "rpc/rpcutils.h"
-#include "wallet/wallettxs.h"
-
-
-Value getchunkqueueinfo(const Array& params, bool fHelp)
-{
-    Object result;
-    mc_ChunkCollector *collector=pwalletTxsMain->m_ChunkCollector;
-    
-    collector->Lock();
-    
-    
-    for(int k=0;k<2;k++)
-    {
-        Object stat;
-        stat.push_back(Pair("waiting",collector->m_StatLast[k].m_Pending-collector->m_StatLast[k].m_Queried));
-//        stat.push_back(Pair("processing",collector->m_StatLast[k].m_Undelivered));
-        stat.push_back(Pair("querying",collector->m_StatLast[k].m_Queried-collector->m_StatLast[k].m_Requested));
-        stat.push_back(Pair("retrieving",collector->m_StatLast[k].m_Requested));
-        result.push_back(Pair(k ? "bytes" : "chunks",stat));
-    }
-    
-    collector->UnLock();
-    
-    return result;
-}
-
-Value getchunkqueuetotals(const Array& params, bool fHelp)
-{
-    Object result;
-    mc_ChunkCollector *collector=pwalletTxsMain->m_ChunkCollector;
-    
-    collector->Lock();
-        
-    for(int k=0;k<2;k++)
-    {
-        Object stat;
-        stat.push_back(Pair("queries",collector->m_StatTotal[k].m_Queried));
-        stat.push_back(Pair("responded",collector->m_StatTotal[k].m_Queried-collector->m_StatTotal[k].m_Unresponded-collector->m_StatLast[k].m_Queried));
-        stat.push_back(Pair("unresponded",collector->m_StatTotal[k].m_Unresponded));
-        stat.push_back(Pair("requests",collector->m_StatTotal[k].m_Requested));
-        stat.push_back(Pair("delivered",collector->m_StatTotal[k].m_Delivered));
-        stat.push_back(Pair("undelivered",collector->m_StatTotal[k].m_Undelivered));
-        stat.push_back(Pair("baddelivered",collector->m_StatTotal[k].m_Baddelivered));
-        result.push_back(Pair(k ? "bytes" : "chunks",stat));
-    }
-    
-    collector->UnLock();
-    
-    return result;
-}
diff --git a/src/rpc/rpcclient.cpp b/src/rpc/rpcclient.cpp
index b46e614..446c7dc 100644
--- a/src/rpc/rpcclient.cpp
+++ b/src/rpc/rpcclient.cpp
@@ -36,8 +36,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "send", 1 },
 /* MCHN START */    
 //    { "setruntimeparam", 1 },                                                             
-    { "debug", 1 },                                                             
-    { "debug", 2 },                                                             
     { "createkeypairs", 0 },                                                             
     { "combineunspent", 1 },                                                             
     { "combineunspent", 2 },                                                             
@@ -76,10 +74,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "listupgrades", 1 },                                                            
     { "listupgrades", 2 },                                                            
     { "listupgrades", 3 },                                                            
-    { "publishfrom", 2 },                                                            
-    { "publishfrom", 3 },                                                            
-    { "publish", 1 },
-    { "publish", 2 },                                                            
     { "getassetbalances", 1 },
     { "getassetbalances", 2 },
     { "getassetbalances", 3 },
@@ -171,15 +165,12 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "subscribe", 0 },
     { "subscribe", 1 },
     { "unsubscribe", 0 },
-    { "unsubscribe", 1 },
     { "listassettransactions", 1 },
     { "listassettransactions", 2 },
     { "listassettransactions", 3 },
     { "listassettransactions", 4 },
     { "getassettransaction", 2 },
     { "getstreamitem", 2 },
-    { "liststreamtxitems", 1 },
-    { "liststreamtxitems", 2 },
     { "liststreamitems", 1 },
     { "liststreamitems", 2 },
     { "liststreamitems", 3 },
@@ -197,8 +188,6 @@ static const CRPCConvertParam vRPCConvertParams[] =
     { "liststreampublishers", 3 },
     { "liststreampublishers", 4 },
     { "liststreampublishers", 5 },
-    { "liststreamqueryitems", 1 },
-    { "liststreamqueryitems", 2 },
     { "liststreamkeyitems", 2 },
     { "liststreamkeyitems", 3 },
     { "liststreamkeyitems", 4 },
@@ -342,15 +331,10 @@ static const CRPCConvertParamMayBeString vRPCConvertParamsMayBeString[] =
     { "unsubscribe", 0 },
     { "liststreamkeys", 1 },
     { "liststreampublishers", 1 },
-    { "liststreamtxitems", 1 },
     { "listassets", 0 },
     { "liststreams", 0 },
     { "listupgrades", 0 },
     { "listpermissions", 1 },
-    { "publishfrom", 2 },                                                            
-    { "publishfrom", 3 },                                                            
-    { "publish", 1 },
-    { "publish", 2 },                                                            
     { "setgenerate", 0 },
     { "liststreamblockitems", 1 },
     { "listblocks", 0 },
diff --git a/src/rpc/rpcdebug.cpp b/src/rpc/rpcdebug.cpp
deleted file mode 100644
index 6445172..0000000
--- a/src/rpc/rpcdebug.cpp
+++ /dev/null
@@ -1,797 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "core/init.h"
-#include "rpc/rpcutils.h"
-#include "protocol/relay.h"
-#include "wallet/wallettxs.h"
-#include "net/net.h"
-
-void parseStreamIdentifier(Value stream_identifier,mc_EntityDetails *entity);
-
-string mcd_ParamStringValue(const Object& params,string name,string default_value)
-{
-    string value=default_value;
-    BOOST_FOREACH(const Pair& d, params) 
-    {
-        if(d.name_ == name)
-        {
-            if(d.value_.type() == str_type)
-            {
-                value=d.value_.get_str();
-            }
-        }
-    }
-    return value;
-}
-
-int mcd_ParamIntValue(const Object& params,string name,int default_value)
-{
-    int value=default_value;
-    BOOST_FOREACH(const Pair& d, params) 
-    {
-        if(d.name_ == name)
-        {
-            if(d.value_.type() == int_type)
-            {
-                value=d.value_.get_int();
-            }
-        }
-    }
-    return value;
-}
-
-int64_t mcd_OpenDatabase(const char *name,const char *dbname,int key_size,int value_size,mc_Database **lpDB)
-{
-    int err,value_len;   
-    int64_t size;
-    mc_Database *m_DB;
-    char m_DBName[MC_DCT_DB_MAX_PATH];     
-    char m_DirName[MC_DCT_DB_MAX_PATH];     
-    char *kbuf;
-    char *vbuf;
-    string rel_dbname=strprintf("debug/%s",dbname);
-    unsigned char *ptr;
-    
-    m_DB=new mc_Database;
-    
-    mc_GetFullFileName(name,"debug","",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,m_DirName);
-    mc_CreateDir(m_DirName);
-    mc_GetFullFileName(name,rel_dbname.c_str(),".db",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,m_DBName);
-    
-    m_DB->SetOption("KeySize",0,key_size);
-    m_DB->SetOption("ValueSize",0,value_size);
-    
-    
-    err=m_DB->Open(m_DBName,MC_OPT_DB_DATABASE_CREATE_IF_MISSING | MC_OPT_DB_DATABASE_TRANSACTIONAL | MC_OPT_DB_DATABASE_LEVELDB);
-    if(err)
-    {
-        return -1;
-    }
-
-    kbuf=new char[key_size];
-    vbuf=new char[value_size];
-    
-    memset(kbuf,0,key_size);
-    memset(vbuf,0,value_size);
-    
-    ptr=(unsigned char*)m_DB->Read(kbuf,key_size,&value_len,0,&err);
-    if(err)
-    {
-        return -2;
-    }
-
-    size=0;
-    if(ptr)                                                                     
-    {        
-        size=mc_GetLE(ptr,8);
-    }
-    else
-    {
-        err=m_DB->Write(kbuf,key_size,vbuf,value_size,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return -3;
-        }        
-                
-        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return -4;
-        }                
-    }
-    
-    delete [] kbuf;
-    delete [] vbuf;
-    
-    *lpDB=m_DB;
-
-    return size;
-}
-
-void mcd_CloseDatabase(mc_Database *m_DB)
-{
-    if(m_DB)
-    {
-        m_DB->Close();
-        delete m_DB;    
-    }    
-}
-
-int64_t mcd_AddRows(mc_Database *m_DB,int key_size,int value_size,int row_count,int64_t prev_rows)
-{
-    int err;
-    int per_commit_count=1000;
-    int commit_count=row_count/per_commit_count;
-    int64_t total_rows=prev_rows;
-    char *kbuf;
-    char *vbuf;
-    kbuf=new char[key_size];
-    vbuf=new char[value_size];
-
-    double tb,ta;
-    tb=mc_TimeNowAsDouble();
-    for(int c=0;c<commit_count;c++)
-    {
-        for(int r=0;r<per_commit_count;r++)
-        {    
-            GetRandBytes((unsigned char*)kbuf, key_size);
-            GetRandBytes((unsigned char*)vbuf, value_size);
-            err=m_DB->Write(kbuf,key_size,vbuf,value_size,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            if(err)
-            {
-                return total_rows;
-            }        
-        }   
-        memset(kbuf,0,key_size);
-        memset(vbuf,0,value_size);
-        total_rows+=per_commit_count;
-        mc_PutLE(vbuf,&total_rows,8);
-        err=m_DB->Write(kbuf,key_size,vbuf,value_size,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return total_rows;
-        }        
-        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return total_rows;
-        }                        
-    }
-    ta=mc_TimeNowAsDouble();    
-    printf("%8.3f\n",ta-tb);
-    
-    delete [] kbuf;
-    delete [] vbuf;
-    
-    return total_rows; 
-}
-
-double mcd_ReadRows(mc_Database *m_DB,int key_size,int row_count,int read_type)
-{
-    int err,value_len;
-    int options;
-    char *kbuf;
-    char *vbuf;    
-    kbuf=new char[key_size];
-    int64_t sum=0;
-    
-    options=0;
-    if(read_type == 1 )
-    {
-        options=MC_OPT_DB_DATABASE_SEEK_ON_READ;
-    }
-    if(read_type == 2 )
-    {
-        options=MC_OPT_DB_DATABASE_NEXT_ON_READ;
-    }
-    double tb,ta;
-    tb=mc_TimeNowAsDouble();
-    for(int r=0;r<row_count;r++)
-    {    
-        GetRandBytes((unsigned char*)kbuf, key_size);
-        vbuf=(char*)m_DB->Read(kbuf,key_size,&value_len,options,&err);
-        if(err)
-        {
-            return 0;
-        }
-        if(vbuf)
-        {
-            if(read_type == 2)
-            {
-                sum+=mc_GetLE(vbuf,4);
-            }
-            else
-            {
-                return 0;
-            }
-        }
-        else
-        {
-            if(read_type == 2)
-            {
-                return 0;
-            }            
-        }
-    }   
-    ta=mc_TimeNowAsDouble();
-    
-    delete [] kbuf;
-    printf("%8.3f   %ld\n",ta-tb,sum);
-    return ta-tb; 
-}
-
-
-Value mcd_DebugRequest(string method,const Object& params)
-{
-    if(method == "dbopen")
-    {
-        mc_Database *m_DB;
-        string dbname=mcd_ParamStringValue(params,"dbname","");
-        int key_size=mcd_ParamIntValue(params,"keysize",-1);
-        int value_size=mcd_ParamIntValue(params,"valuesize",-1);
-        int sleep=mcd_ParamIntValue(params,"sleep",1000);
-        int64_t res;
-        if( (dbname.size() == 0) || (key_size < 0) || (value_size < 0) )
-        {            
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameters");                                            
-        }
-        res=mcd_OpenDatabase(mc_gState->m_NetworkParams->Name(),dbname.c_str(),key_size,value_size,&m_DB);
-        __US_Sleep(sleep);
-        mcd_CloseDatabase(m_DB);
-        return res;
-    }
-    if(method == "dbwrite")
-    {
-        mc_Database *m_DB;
-        string dbname=mcd_ParamStringValue(params,"dbname","");
-        int key_size=mcd_ParamIntValue(params,"keysize",-1);
-        int value_size=mcd_ParamIntValue(params,"valuesize",-1);
-        int row_count=mcd_ParamIntValue(params,"rows",-1);
-        int sleep=mcd_ParamIntValue(params,"sleep",1000);
-        int64_t res;
-        if( (dbname.size() == 0) || (key_size < 0) || (value_size < 0) || (row_count < 0) )
-        {            
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameters");                                            
-        }
-        res=mcd_OpenDatabase(mc_gState->m_NetworkParams->Name(),dbname.c_str(),key_size,value_size,&m_DB);
-        res=mcd_AddRows(m_DB,key_size,value_size,row_count,res);
-        __US_Sleep(sleep);
-        mcd_CloseDatabase(m_DB);
-        return res;
-    }
-    if(method == "dbread")
-    {
-        mc_Database *m_DB;
-        string dbname=mcd_ParamStringValue(params,"dbname","");
-        int key_size=mcd_ParamIntValue(params,"keysize",-1);
-        int value_size=mcd_ParamIntValue(params,"valuesize",-1);
-        int read_type=mcd_ParamIntValue(params,"type",-1);
-        int row_count=mcd_ParamIntValue(params,"rows",-1);
-        int sleep=mcd_ParamIntValue(params,"sleep",1000);
-        double dres;
-        if( (dbname.size() == 0) || (key_size < 0) || (read_type < 0) || (value_size < 0) || (row_count < 0)  )
-        {            
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameters");                                            
-        }
-        mcd_OpenDatabase(mc_gState->m_NetworkParams->Name(),dbname.c_str(),key_size,value_size,&m_DB);
-        dres=mcd_ReadRows(m_DB,key_size,row_count,read_type);
-        __US_Sleep(sleep);
-        mcd_CloseDatabase(m_DB);
-        return dres;
-    }
-    if(method == "chunksdump")
-    {
-        int force=mcd_ParamIntValue(params,"force",0);
-        string message=mcd_ParamStringValue(params,"message","Debug");        
-        pwalletTxsMain->m_ChunkDB->Dump("Debug",force);
-        return Value::null;
-    }
-    if(method == "chunkscommit")
-    {
-        pwalletTxsMain->m_ChunkDB->Commit(-3);
-        return Value::null;
-    }
-    if(method == "walletdump")
-    {
-        int force=mcd_ParamIntValue(params,"force",0);        
-        string message=mcd_ParamStringValue(params,"message","Debug");
-        pwalletTxsMain->m_Database->Dump("Debug",force);
-        return Value::null;
-    }
-    if(method == "publishrandom")
-    {
-        int size=mcd_ParamIntValue(params,"size",-1);
-        string stream=mcd_ParamStringValue(params,"stream","");
-        string options=mcd_ParamStringValue(params,"options","");
-        string key=mcd_ParamStringValue(params,"key","");        
-        if( (stream.size() == 0) || (size < 0))
-        {            
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameters");                                            
-        }
-        Array cbc_params;
-        string bcname=createbinarycache(cbc_params,false).get_str();
-        int part_size=100000;
-        int total_size=0;
-        int num_parts=(size-1)/part_size+1;
-        char *vbuf;
-        vbuf=new char[part_size];
-        for(int p=0;p<num_parts;p++)
-        {
-            Array abc_params;
-            abc_params.push_back(bcname);
-            int this_size=part_size;
-            if(p == num_parts-1)
-            {
-                this_size=size-p*part_size;
-            }
-            GetRandBytes((unsigned char*)vbuf, this_size);            
-            string strHex = HexStr(vbuf, vbuf+this_size);
-            abc_params.push_back(strHex);
-            total_size+=this_size;
-            if(appendbinarycache(abc_params,false).get_int() != total_size)
-            {
-                throw JSONRPCError(RPC_INTERNAL_ERROR, "Cannot add to binary cache");                                                            
-            }
-        }
-        delete [] vbuf;
-
-        Array p_params;
-        p_params.push_back(stream);
-        p_params.push_back(key);
-        Object c_obj;
-        c_obj.push_back(Pair("cache",bcname));
-        p_params.push_back(c_obj);
-        p_params.push_back(options);
-        string strTxID=publish(p_params,false).get_str();        
-        Array dbc_params;
-        dbc_params.push_back(bcname);
-        deletebinarycache(dbc_params,false);
-        
-        return strTxID;
-    }    
-    
-    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid request type");         
-    
-    return Value::null;
-}
-
-Value debug(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() < 2 || params.size() > 4)  
-        throw runtime_error("Help message not found\n");
-    
-    if(!GetBoolArg("-rpcallowdebug",false))
-    {
-        throw JSONRPCError(RPC_NOT_ALLOWED, "API is not allowed");                 
-    }
-    
-    uint32_t request_type=MC_RMT_NONE;
-    int timeout=5;
-    vector <unsigned char> payload;
-    mc_OffchainMessageID request_id;      
-    CNode *pto=NULL;
-    string request_str="";
-    mc_RelayRequest *request;
-    mc_RelayResponse *response;
-    int attempts,delay; 
-    Object res;
-    mc_ChunkCollector collector;
-    bool res_found=false;
-            
-    if(params[0].type() == str_type)
-    {
-        if(params[0].get_str() == "findaddress")
-        {            
-            request_type=MC_RMT_MC_ADDRESS_QUERY;
-            request_str="query for address ";
-        }
-        if(params[0].get_str() == "getchunks")
-        {            
-            request_type=MC_RMT_SPECIAL_COLLECT_CHUNKS;
-            request_str="query for address ";
-        }        
-        if(params[0].get_str() == "viewchunks")
-        {            
-            request_type=MC_RMT_SPECIAL_VIEW_CHUNKS;
-        }        
-    }
-           
-    if(params[1].type() != obj_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid request details, should be object");                    
-    }
-    
-    if(request_type == MC_RMT_NONE)
-    {
-        return mcd_DebugRequest(params[0].get_str(),params[1].get_obj());
-//        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid request type");                    
-    }
-    
-    
-    if(request_type & MC_RMT_SPECIAL_MASK)
-    {
-        switch(request_type)
-        {
-            case MC_RMT_SPECIAL_COLLECT_CHUNKS:
-                collector.Initialize(NULL,NULL,0);
-                attempts=10;
-                delay=1000;
-                BOOST_FOREACH(const Pair& d, params[1].get_obj()) 
-                {
-                    if(d.name_ == "attempts")
-                    {
-                        if(d.value_.type() == int_type)
-                        {
-                            attempts=d.value_.get_int();
-                        }
-                    }
-                    if(d.name_ == "delay")
-                    {
-                        if(d.value_.type() == int_type)
-                        {
-                            delay=d.value_.get_int();
-                        }
-                    }
-                    if(d.name_ == "chunks")
-                    {
-                        if(d.value_.type() == array_type)
-                        {
-                            for(int c=0;c<(int)d.value_.get_array().size();c++)
-                            {
-                                Value cd=d.value_.get_array()[c];
-                                if(cd.type() != obj_type)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid chunk");                                
-                                }
-                                uint256 chunk_hash=0;
-                                int chunk_size=0;
-                                mc_EntityDetails stream_entity;
-                                
-                                uint256 txid=0;
-                                int vout=0;
-                                mc_TxEntity entity;
-                                entity.Zero();
-                                BOOST_FOREACH(const Pair& dd, cd.get_obj()) 
-                                {
-                                    if(dd.name_ == "stream")
-                                    {
-                                        parseStreamIdentifier(dd.value_.get_str(),&stream_entity);           
-                                        memcpy(&entity,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-                                        entity.m_EntityType=MC_TET_STREAM;
-                                    }
-                                    if(dd.name_ == "hash")
-                                    {
-                                        chunk_hash = ParseHashV(dd.value_.get_str(), "hash");
-                                    }
-                                    if(dd.name_ == "txid")
-                                    {
-                                        txid = ParseHashV(dd.value_.get_str(), "hash");
-                                    }
-                                    if(dd.name_ == "vout")
-                                    {
-                                        if(dd.value_.type() != int_type)
-                                        {
-                                            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid vout");                                                                        
-                                        }
-                                        vout=dd.value_.get_int();
-                                    }
-                                    if(dd.name_ == "size")
-                                    {
-                                        if(dd.value_.type() != int_type)
-                                        {
-                                            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid size");                                                                        
-                                        }
-                                        chunk_size=dd.value_.get_int();
-                                    }
-                                }
-                                if(chunk_hash == 0)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Missing hash");
-                                }
-                                if(chunk_size == 0)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Missing size");
-                                }
-                                if(entity.m_EntityType == MC_TET_NONE)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Missing stream");                                    
-                                }
-                                collector.InsertChunk((unsigned char*)&chunk_hash,&entity,(unsigned char*)&txid,vout,chunk_size);
-                            }
-                        }
-                    }            
-                }    
-
-                if(collector.m_MemPool->GetCount() == 0)
-                {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Missing chunks");                
-                }
-
-                break;
-            case MC_RMT_SPECIAL_VIEW_CHUNKS:
-                Array arr_res;
-                BOOST_FOREACH(const Pair& d, params[1].get_obj()) 
-                {
-                    if(d.name_ == "chunks")
-                    {
-                        if(d.value_.type() == array_type)
-                        {
-                            for(int c=0;c<(int)d.value_.get_array().size();c++)
-                            {
-                                Value cd=d.value_.get_array()[c];
-                                if(cd.type() != obj_type)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid chunk");                                
-                                }
-                                uint256 chunk_hash=0;                                
-                                uint256 txid=0;
-                                int vout=-1;
-                                mc_TxEntity entity;
-                                mc_EntityDetails stream_entity;
-                                entity.Zero();
-                                BOOST_FOREACH(const Pair& dd, cd.get_obj()) 
-                                {
-                                    if(dd.name_ == "hash")
-                                    {
-                                        chunk_hash = ParseHashV(dd.value_.get_str(), "hash");
-                                    }
-                                    if(dd.name_ == "stream")
-                                    {
-                                        parseStreamIdentifier(dd.value_.get_str(),&stream_entity);           
-                                        memcpy(&entity,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-                                        entity.m_EntityType=MC_TET_STREAM;
-                                    }
-                                    if(dd.name_ == "txid")
-                                    {
-                                        txid = ParseHashV(dd.value_.get_str(), "hash");
-                                    }
-                                    if(dd.name_ == "vout")
-                                    {
-                                        if(dd.value_.type() != int_type)
-                                        {
-                                            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid vout");                                                                        
-                                        }
-                                        vout=dd.value_.get_int();
-                                    }
-                                }
-                                if(chunk_hash == 0)
-                                {
-                                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Missing hash");
-                                }
-                                
-                                unsigned char *chunk_found;
-                                size_t chunk_bytes;
-                                mc_ChunkDBRow chunk_def;
-                                
-                                Object chunk_obj;
-                                chunk_obj.push_back(Pair("hash",chunk_hash.ToString()));
-                                
-                                if(pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,(unsigned char *)&chunk_hash,
-                                        (entity.m_EntityType == MC_TET_NONE) ? NULL: &entity,(txid == 0) ? NULL : (unsigned char*)&txid,vout) == MC_ERR_NOERROR)
-                                {
-                                    chunk_found=pwalletTxsMain->m_ChunkDB->GetChunk(&chunk_def,0,-1,&chunk_bytes);
-                                    if(chunk_found)
-                                    {
-                                        chunk_obj.push_back(Pair("size",(int)chunk_bytes));
-                                        chunk_obj.push_back(Pair("data",HexStr(chunk_found,chunk_found+chunk_bytes)));
-                                    }
-                                    else
-                                    {
-                                        chunk_obj.push_back(Pair("error","Internal error"));
-                                    }
-                                }
-                                else
-                                {
-                                    chunk_obj.push_back(Pair("error","Chunk not found"));
-                                }
-                                arr_res.push_back(chunk_obj);
-                            }
-                        }
-                    }                    
-                }     
-                return arr_res;
-        }        
-    }
-    else
-    {
-        switch(request_type)
-        {
-            case MC_RMT_MC_ADDRESS_QUERY:
-                string addr_to_find="";
-                BOOST_FOREACH(const Pair& d, params[1].get_obj()) 
-                {
-                    if(d.name_ == "address")
-                    {
-                        if(d.value_.type() ==str_type)
-                        {
-                            addr_to_find=d.value_.get_str();
-                            request_str+=addr_to_find;
-                        }
-                    }            
-                }    
-
-                CBitcoinAddress address(addr_to_find);
-                CKeyID keyID;
-                if (!address.GetKeyID(keyID))
-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
-
-                payload.resize(1+sizeof(CKeyID));
-                payload[0]=MC_RDT_MC_ADDRESS;
-                memcpy(&payload[1],&keyID,sizeof(CKeyID));            
-                break;
-        }
-    }
-    
-    if(params.size() > 2)
-    {
-        if(params[2].type() != int_type)
-        {
-            timeout=params[2].get_int();
-            if( (timeout <= 0) || (timeout > 15 ) )
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid timeout");                                
-            }
-        }    
-        else
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid timeout");                                            
-        }
-    }
-    
-    if(request_type & MC_RMT_SPECIAL_MASK)
-    {
-        int remaining=0;
-        for(int a=0;a<attempts;a++)
-        {
-            if(a)
-            {
-                __US_Sleep(delay);
-            }
-            remaining=MultichainCollectChunks(&collector);
-            if(remaining == 0)
-            {
-                return 0;
-            }
-        }
-        return remaining;
-    }
-    else        
-    {
-        {
-            LOCK(cs_vNodes);
-            if(params.size() > 3)
-            {
-                if(params[3].type() != str_type)
-                {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid destination");                                            
-                }
-
-                BOOST_FOREACH(CNode* pnode, vNodes) 
-                {
-                    CNodeStats stats;
-                    pnode->copyStats(stats);
-                    if( (params[3].get_str() == stats.addrName) || 
-                        (params[3].get_str() == CBitcoinAddress(stats.kAddrRemote).ToString()) )
-                    {
-                        pto=pnode;
-                    }
-                }
-            }
-
-            if(pto)
-            {
-                request_str="Sending " + request_str + strprintf(" to node %d",pto->GetId());
-            }
-            else
-            {
-                request_str="Broadcasting " + request_str;
-            }
-        }
-        
-        request_id=pRelayManager->SendRequest(pto,request_type,0,payload);
-/*        
-        printf("%s",request_str.c_str());        
-        printf(". Request ID: %s\n",request_id.ToString().c_str());
- */ 
-    }    
-
-    uint32_t time_now;
-    uint32_t time_stop;
-    
-    time_now=mc_TimeNowAsUInt();
-    time_stop=time_now+timeout;
-    res_found=false;
-    
-    while(time_now<time_stop)
-    {
-        request=pRelayManager->FindRequest(request_id);
-        if(request)
-        {
-            if(request->m_Responses.size())
-            {
-                switch(request_type)
-                {
-                    case MC_RMT_MC_ADDRESS_QUERY:
-                        mc_NodeFullAddress node_addr;
-                        int count,shift;
-                        bool take_it=true;
-                        unsigned char *ptr;
-                        unsigned char *ptrEnd;
-                        for(int r=0;r<(int)request->m_Responses.size();r++)
-                        {
-                            if(!res_found)
-                            {
-                                response=&(request->m_Responses[r]);
-                                ptr=&(response->m_Payload[0]);
-                                ptrEnd=ptr+response->m_Payload.size();
-                                while( (ptr<ptrEnd) && take_it )
-                                {
-                                    switch(*ptr)
-                                    {
-                                        case MC_RDT_MC_ADDRESS:
-                                            ptr++;
-                                            if((int)sizeof(CKeyID) > (ptrEnd-ptr))
-                                            {
-                                                take_it=false;
-                                            }
-                                            else
-                                            {
-                                                node_addr.m_Address=*(CKeyID*)ptr;
-                                                ptr+=sizeof(CKeyID);
-                                            }
-                                            break;
-                                        case MC_RDT_NET_ADDRESS:
-                                            ptr++;
-                                            count=(int)mc_GetVarInt(ptr,ptrEnd-ptr,-1,&shift);
-                                            ptr+=shift;
-                                            if(count*(int)sizeof(CAddress) > (ptrEnd-ptr))
-                                            {
-                                                take_it=false;
-                                            }
-                                            else
-                                            {
-                                                for(int a=0;a<count;a++)
-                                                {
-                                                    node_addr.m_NetAddresses.push_back(*(CAddress*)ptr);
-                                                    ptr+=sizeof(CAddress);
-                                                }
-                                            }
-                                            break;
-                                        default:
-                                            take_it=false;
-                                            break;
-                                    }
-                                }
-                                
-                                if(take_it)
-                                {
-                                    Array addresses;
-                                    res.push_back(Pair("handshake",CBitcoinAddress(node_addr.m_Address).ToString()));
-                                    for(int a=0;a<(int)node_addr.m_NetAddresses.size();a++)
-                                    {
-                                        addresses.push_back(node_addr.m_NetAddresses[a].ToStringIPPort());                                        
-                                    }                                    
-                                    res.push_back(Pair("addresses",addresses));
-                                    res.push_back(Pair("neighbour",response->m_Source ? false : true));
-                                    res_found=true;
-                                }
-                            }
-                        }                        
-                        
-                        break;
-                }
-            }
-            pRelayManager->UnLock();
-            if(res_found)
-            {
-                pRelayManager->DeleteRequest(request_id);
-                return res; 
-            }
-        }
-        __US_Sleep(100);
-        time_now=mc_TimeNowAsUInt();
-    }
-    
-    return Value::null;    
-}
diff --git a/src/rpc/rpcexchange.cpp b/src/rpc/rpcexchange.cpp
index b30f986..9d0ebb3 100644
--- a/src/rpc/rpcexchange.cpp
+++ b/src/rpc/rpcexchange.cpp
@@ -214,7 +214,6 @@ Object DecodeExchangeTransaction(const CTransaction tx,int verbose,int64_t& nati
     strError="";
     native_balance=0;
     bool can_disable=false;
-    uint32_t format;
     
     vector <CTxOut> input_txouts;
     vector <string> input_errors;
@@ -312,8 +311,6 @@ Object DecodeExchangeTransaction(const CTransaction tx,int verbose,int64_t& nati
                 lpScript->Clear();
                 lpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);                
                 
-                lpScript->ExtractAndDeleteDataFormat(&format);
-                
                 if(lpScript->GetNumElements()<=1)
                 {
                     if(lpScript->GetNumElements()==1)
@@ -920,7 +917,7 @@ Value completerawexchange(const json_spirit::Array& params, bool fHelp)
     if(params.size() > 4)
     {    
         mc_EntityDetails found_entity;
-        CScript scriptOpReturn=ParseRawMetadata(params[4],MC_DATA_API_PARAM_TYPE_SIMPLE,NULL,&found_entity);
+        CScript scriptOpReturn=ParseRawMetadata(params[4],0x0002,NULL,&found_entity);
         
         if(found_entity.GetEntityType() == MC_ENT_TYPE_STREAM)
         {        
diff --git a/src/rpc/rpchelp.cpp b/src/rpc/rpchelp.cpp
index de09acd..e3205fc 100644
--- a/src/rpc/rpchelp.cpp
+++ b/src/rpc/rpchelp.cpp
@@ -791,14 +791,57 @@ void mc_InitRPCHelpMap04()
         ));
     
     mapHelpStrings.insert(std::make_pair("appendrawmetadata",
-            "appendrawmetadata \"tx-hex\" data \n"
+            "appendrawmetadata \"tx-hex\" \"data-hex\"|object \n"
             "\nAppends new OP_RETURN output to existing raw transaction\n"
             "Returns hex-encoded raw transaction.\n"
             "\nArguments:\n"
             "1. \"tx-hex\"                           (string, required) The transaction hex string\n"
-            "2. data                               (string or object, required) Data, see help data-all for details.\n"
+            "2. \"data-hex\"                         (string, required) Data hex string\n"
+            " or\n"
+            "2. issue-details                      (object, required) A json object with issue metadata\n"
+            "    {\n"
+            "      \"create\" : \"asset\"              (string,required) asset\n" 
+            "      \"name\" : \"asset-name\"           (string,optional) Asset name\n"
+            "      \"multiple\" : n                  (numeric,optional, default 1) Number of raw units in one displayed unit\n"
+            "      \"open\" : true|false             (boolean, optional, default false) True if follow-on issues are allowed\n"                
+            "      \"details\" :                     (object, optional)  a json object with custom fields\n"           
+            "        {\n"
+            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
+            "          ,...\n"
+            "        }\n"
+            " or\n"
+            "2. issuemore-details                  (object, required) A json object with issuemore metadata\n"
+            "    {\n"
+            "      \"update\" : \"asset-identifier\"   (string,required) Asset identifier - one of the following: asset txid, asset reference, asset name.\n"
+            "      \"details\" :                     (object, optional)  a json object with custom fields\n"           
+            "        {\n"
+            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
+            "          ,...\n"
+            "        }\n"
+            "    }\n"                                
+            " or\n"
+            "2. create-new-stream                  (object, required) A json object with new stream details\n"
+            "    {\n"                
+            "      \"create\" : \"stream\"             (string,required) stream\n"
+            "      \"name\" : \"stream-name\"          (string,optional) Stream name\n"
+            "      \"open\" : true|false             (boolean,optional, default: false) If true, anyone can publish\n"
+            "      \"details\" :                     (object, optional)  a json object with custom fields\n"           
+            "        {\n"
+            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
+            "          ,...\n"
+            "        }\n"
+            "    }\n"                                
+            " or\n"
+            "2. publish-new-stream-item            (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : \"stream-identifier\"     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : \"key\"                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : \"data-hex\"             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
-            "\"transaction\"                         (string) hex string of the transaction\n"
+            "{\n"
+            "  \"hex\": \"value\",                     (string) The raw transaction with appended data output (hex-encoded string)\n"
+            "}\n"
             "\nExamples:\n"
             + HelpExampleCli("appendrawmetadata", "\"tx-hexstring\" 48656C6C6F20576F726C64210A" )
             + HelpExampleRpc("appendrawmetadata", "\"tx-hexstring\",\"48656C6C6F20576F726C64210A\"")
@@ -809,25 +852,13 @@ void mc_InitRPCHelpMap04()
 void mc_InitRPCHelpMap05()
 {
     mapHelpStrings.insert(std::make_pair("appendrawdata",
-            "appendrawdata tx-hex data \n"
+            "appendrawdata tx-hex data-hex|object \n"
             "\nAppends new OP_RETURN output to existing raw transaction\n"
             "Returns hex-encoded raw transaction.\n"
             "\nArguments:\n"
             "1. \"tx-hex\"                           (string, required) The transaction hex string\n"
-            "2. data                               (string or object, required) Data, see help data-all for details.\n"
-/*    
             "2. \"data-hex\"                         (string, required) Data hex string\n"
             " or\n"
-            "2. data-json                          (object, required) JSON data object\n"
-            "    {\n"
-            "      \"json\" : json-data              (object, required) Valid JSON object\n" 
-            "    }\n"                                
-            " or\n"
-            "2. data-text                          (object, required) Text data object\n"
-            "    {\n"
-            "      \"text\" : text                   (string, required) Data string\n" 
-            "    }\n"                                
-            " or\n"
             "2. issue-details                      (object, required) A json object with issue metadata\n"
             "    {\n"
             "      \"create\" : asset                (string,required) asset\n" 
@@ -839,7 +870,6 @@ void mc_InitRPCHelpMap05()
             "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
             "          ,...\n"
             "        }\n"
-            "    }\n"                                
             " or\n"
             "2. issuemore-details                  (object, required) A json object with issuemore metadata\n"
             "    {\n"
@@ -855,7 +885,7 @@ void mc_InitRPCHelpMap05()
             "    {\n"                
             "      \"create\" : stream               (string,required) stream\n"
             "      \"name\" : stream-name            (string,optional) Stream name\n"
-            "      \"open\" : true|false             (string,optional, default: false) If true, anyone can publish\n"
+            "      \"open\" : true|false             (boolean,optional, default: false) If true, anyone can publish\n"
             "      \"details\" :                     (object,optional) a json object with custom fields\n"           
             "        {\n"
             "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
@@ -867,18 +897,7 @@ void mc_InitRPCHelpMap05()
             "    {\n"                
             "      \"for\" : stream-identifier       (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
             "      \"key\" : key                     (string,optional, default: \"\") Item key\n"
-            "      \"keys\" : keys                   (array,optional) Item keys, array of strings\n"
             "      \"data\" : data-hex               (string,optional, default: \"\") Data hex string\n"
-            "        or\n"
-            "      \"data\" :                        (object, required) JSON data object\n"
-            "        {\n"
-            "          \"json\" : json-data          (object, required) Valid JSON string\n" 
-            "        }\n"                                
-            "        or\n"
-            "      \"data\" :                        (object, required) JSON data object\n"
-            "        {\n"
-            "          \"text\" : \"text\"             (string, required) Data string\n" 
-            "        }\n"                                
             "    }\n"                                
             " or\n"
             "2. create-new-upgrade                 (object, required) A json object with new upgrade details\n"
@@ -897,9 +916,10 @@ void mc_InitRPCHelpMap05()
             "      \"approve\" : approve             (boolean,required) Approve or disapprove\n"
             "      \"for\" : upgrade-identifier      (string,required)  Upgrade identifier - one of the following: upgrade txid, upgrade name.\n"
             "    }\n"                                
- */ 
             "\nResult:\n"
-            "\"transaction\"                         (string) hex string of the transaction\n"
+            "{\n"
+            "  \"hex\": \"value\",                     (string) The raw transaction with appended data output (hex-encoded string)\n"
+            "}\n"
             "\nExamples:\n"
             + HelpExampleCli("appendrawdata", "\"tx-hexstring\" 48656C6C6F20576F726C64210A" )
             + HelpExampleRpc("appendrawdata", "\"tx-hexstring\",\"48656C6C6F20576F726C64210A\"")
@@ -921,8 +941,6 @@ void mc_InitRPCHelpMap05()
             "       }\n"
             "       ,...\n"
             "     ]\n"
-            "2. addresses                              (object, required) Object with addresses as keys, see help addresses-all for details.\n"
-/*    
             "2. addresses                              (object, required) a json object with addresses as keys and amounts as values\n"
             "    {\n"
             "      \"address\": \n"
@@ -967,9 +985,8 @@ void mc_InitRPCHelpMap05()
             "        }\n"                                
             "      ,...\n"
             "    }\n"
- */ 
-            "3. data                                   (array, optional) Array of hexadecimal strings or data objects, see help data-all for details.\n"
-            "4. \"action\"                               (string, optional, default \"\") Additional actions: \"lock\", \"sign\", \"lock,sign\", \"sign,lock\", \"send\". \n"
+            "3. data                                   (array, optional) Array of hexadecimal strings or data objects, see help appendrawdata for details.\n"
+            "4.\"action\"                                (string, optional, default \"\") Additional actions: \"lock\", \"sign\", \"lock,sign\", \"sign,lock\", \"send\". \n"
                 
 
             "\nResult:\n"
@@ -1393,11 +1410,6 @@ void mc_InitRPCHelpMap06()
             "1. \"entity-type\"                    (string, required) stream\n"
             "2. \"stream-name\"                    (string, required) Stream name, if not \"\" should be unique.\n"
             "3. open                             (boolean, required ) Allow anyone to publish in this stream\n"
-            "  or \n"
-            "3. restrictions                     (object, optional) Stream restrictions\n"
-            "    {\n"
-            "      \"restrict\" : \"restrictions\"   (string, optional) Stream restrictions, comma delimited. Possible values: write,offchain,onchain\n"
-            "    }\n"
             "4  custom-fields                    (object, optional)  a json object with custom fields\n"
             "    {\n"
             "      \"param-name\": \"param-value\"   (strings, required) The key is the parameter name, the value is parameter value\n"
@@ -1409,15 +1421,7 @@ void mc_InitRPCHelpMap06()
             "3. open                             (boolean, required ) Should be false\n"
             "4  custom-fields                    (object, required)  a json object with custom fields\n"
             "    {\n"
-            "      \"protocol-version\": version   (numeric, optional) Protocol version to upgrade to\n"
-            "      \"parameter-name\": value       (numeric, optional) New value for upgradable parameter, one of the following: \n"
-            "                                                        target-block-time,\n"
-            "                                                        maximum-block-size,\n"
-            "                                                        max-std-tx-size,\n"
-            "                                                        max-std-op-returns-count,\n"
-            "                                                        max-std-op-return-size,\n"
-            "                                                        max-std-op-drops-count,\n"
-            "                                                        max-std-element-size\n"
+            "      \"protocol-version\": version   (numeric, required) Protocol version to upgrade to\n"
             "      \"startblock\": block           (numeric, optional, default 0) Block to apply from \n"
 //            "      \"param-name\": \"param-value\"   (strings, required) The key is the parameter name, the value is parameter value\n"
             "      ,...\n"
@@ -1440,11 +1444,6 @@ void mc_InitRPCHelpMap06()
             "2. entity-type                      (string, required) stream\n"
             "3. \"stream-name\"                    (string, required) Stream name, if not \"\" should be unique.\n"
             "4. open                             (boolean, required) Allow anyone to publish in this stream\n"
-            "  or \n"
-            "4. restrictions                     (object, optional) Stream restrictions\n"
-            "    {\n"
-            "      \"restrict\" : \"restrictions\"   (string, optional) Stream restrictions, comma delimited. Possible values: write,offchain,onchain\n"
-            "    }\n"
             "5  custom-fields                    (object, optional)  a json object with custom fields\n"
             "    {\n"
             "      \"param-name\": \"param-value\"   (strings, required) The key is the parameter name, the value is parameter value\n"
@@ -1457,15 +1456,7 @@ void mc_InitRPCHelpMap06()
             "4. open                             (boolean, required ) Should be false\n"
             "5  custom-fields                    (object, required)  a json object with custom fields\n"
             "    {\n"
-            "      \"protocol-version\": version   (numeric, optional) Protocol version to upgrade to \n"
-            "      \"parameter-name\": value       (numeric, optional) New value for upgradable parameter, one of the following: \n"
-            "                                                        target-block-time,\n"
-            "                                                        maximum-block-size,\n"
-            "                                                        max-std-tx-size,\n"
-            "                                                        max-std-op-returns-count,\n"
-            "                                                        max-std-op-return-size,\n"
-            "                                                        max-std-op-drops-count,\n"
-            "                                                        max-std-element-size\n"
+            "      \"protocol-version\": version   (numeric, required) Protocol version to upgrade to \n"
             "      \"start-block\": block          (numeric, optional, default 0) Block to apply from \n"
 //            "      \"param-name\": \"param-value\"   (strings, required) The key is the parameter name, the value is parameter value\n"
             "      ,...\n"
@@ -1508,8 +1499,51 @@ void mc_InitRPCHelpMap07()
 
             "\nArguments:\n"
             "1. \"from-address\"                           (string, required) Address to send from.\n"
-            "2. addresses                                (object, required) Object with addresses as keys, see help addresses-all for details.\n"
-            "3. data                                     (array, optional) Array of hexadecimal strings or data objects, see help data-all for details.\n"
+            "2. addresses                                (array, required) a json object with addresses as keys and amounts as values\n"
+            "    {\n"
+            "      \"address\": \n"
+            "        x.xxx                               (numeric, required) The key is the address, the value is the native currency amount\n"
+            "          or \n"
+            "        {                                   (object) A json object of assets to send\n"
+            "          \"asset-identifier\" : asset-quantity \n"
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                   (object) A json object describing new asset issue\n"
+            "          \"issue\" : \n"
+            "            {\n"
+            "              \"raw\" : n                     (numeric, required) The asset total amount in raw units \n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                   (object) A json object describing follow-on asset issue\n"
+            "          \"issuemore\" : \n"
+            "            {\n"
+            "              \"asset\" : \"asset-identifier\"  (string, required) Asset identifier - one of the following: issue txid. asset reference, asset name.\n"
+            "              \"raw\" : n                     (numeric, required) The asset total amount in raw units \n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                   (object) A json object describing permission change\n"
+            "          \"permissions\" : \n"
+            "            {\n"
+            "              \"type\" : \"permission(s)\"      (string,required) Permission strings, comma delimited. Possible values:\n"
+            "                                                              " + AllowedPermissions() + " \n"
+            "              \"startblock\"                  (numeric, optional) Block to apply permissions from (inclusive). Default - 0\n"
+            "              \"endblock\"                    (numeric, optional) Block to apply permissions to (exclusive). Default - 4294967295\n"
+            "              \"timestamp\"                   (numeric, optional) This helps resolve conflicts between permissions\n"
+            "                                                                  assigned by the same administrator. Default - current time\n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "      ,...\n"
+            "    }\n"
+            "3. data                                     (array, optional) Array of hexadecimal strings or data objects, see help appendrawdata for details.\n"
             "4. \"action\"                                 (string, optional, default \"\") Additional actions: \"lock\", \"sign\", \"lock,sign\", \"sign,lock\", \"send\". \n"
                 
 
@@ -2051,7 +2085,7 @@ void mc_InitRPCHelpMap09()
             "1. \"address(es)\"                    (string, required)  The multichain addresses to send to (comma delimited)\n"
             "2. \"permission(s)\"                  (string, required)  Permission strings, comma delimited. \n"
             "                                                        Global: " + AllowedPermissions() + " \n"
-            "                                                        or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                        or per-asset: asset-identifier.issue,admin \n"
             "                                                        or per-stream: stream-identifier.write,activate,admin \n"
             "3. native-amount                    (numeric, optional) Native currency amount to send. eg 0.1. Default - 0.0\n"
             "4. startblock                       (numeric, optional) Block to apply permissions from (inclusive). Default - 0\n"
@@ -2080,7 +2114,7 @@ void mc_InitRPCHelpMap09()
             "2. \"to-address(es)\"                 (string, required) The multichain addresses to grant permissions to\n"
             "3. \"permission(s)\"                  (string, required)  Permission strings, comma delimited. \n"
             "                                                        Global: " + AllowedPermissions() + " \n"
-            "                                                        or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                        or per-asset: asset-identifier.issue,admin \n"
             "                                                        or per-stream: stream-identifier.write,activate,admin \n"
             "4. native-amount                    (numeric, optional) Native currency amount to send. eg 0.1. Default - 0.0\n"
             "5. startblock                       (numeric, optional) Block to apply permissions from (inclusive). Default - 0\n"
@@ -2100,15 +2134,22 @@ void mc_InitRPCHelpMap09()
         ));
     
     mapHelpStrings.insert(std::make_pair("grantwithdata",
-            "grantwithdata \"address(es)\" \"permission(s)\" data|publish-new-stream-item ( native-amount startblock endblock )\n"
+            "grantwithdata \"address(es)\" \"permission(s)\" \"data-hex\"|object ( native-amount startblock endblock )\n"
             "\nGrant permission(s) with metadata to a given address. \n"
             "\nArguments:\n"
             "1. \"address(es)\"                    (string, required) The multichain addresses to send to (comma delimited)\n"
             "2. \"permission(s)\"                  (string, required) Permission strings, comma delimited. \n"
             "                                                       Global: " + AllowedPermissions() + " \n"
-            "                                                       or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                       or per-asset: asset-identifier.issue,admin \n"
             "                                                       or per-stream: stream-identifier.write,activate,admin \n"
-            "3. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "3. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "3. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "4. native-amount                    (numeric, optional)  Native currency amount to send. eg 0.1. Default - 0.0\n"
             "5. startblock                       (numeric, optional)  Block to apply permissions from (inclusive). Default - 0\n"
             "6. endblock                         (numeric, optional)  Block to apply permissions to (exclusive). Default - 4294967295\n"
@@ -2126,15 +2167,22 @@ void mc_InitRPCHelpMap09()
 void mc_InitRPCHelpMap10()
 {
     mapHelpStrings.insert(std::make_pair("grantwithmetadata",
-            "grantwithdata \"address(es)\" \"permission(s)\" data|publish-new-stream-item ( native-amount startblock endblock )\n"
+            "grantwithdata \"address(es)\" \"permission(s)\" \"data-hex\"|object ( native-amount startblock endblock )\n"
             "\nGrant permission(s) with metadata to a given address. \n"
             "\nArguments:\n"
             "1. \"address(es)\"                    (string, required) The multichain addresses to send to (comma delimited)\n"
             "2. \"permission(s)\"                  (string, required)  Permission strings, comma delimited. \n"
             "                                                        Global: " + AllowedPermissions() + " \n"
-            "                                                        or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                        or per-asset: asset-identifier.issue,admin \n"
             "                                                        or per-stream: stream-identifier.write,activate,admin \n"
-            "3. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "3. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "3. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "4. native-amount                    (numeric, optional)  Native currency amount to send. eg 0.1. Default - 0.0\n"
             "5. startblock                       (numeric, optional)  Block to apply permissions from (inclusive). Default - 0\n"
             "6. endblock                         (numeric, optional)  Block to apply permissions to (exclusive). Default - 4294967295\n"
@@ -2148,7 +2196,7 @@ void mc_InitRPCHelpMap10()
         ));
     
     mapHelpStrings.insert(std::make_pair("grantwithdatafrom",
-            "grantwithdatafrom \"from-address\" \"to-address(es)\" \"permission(s)\" data|publish-new-stream-item ( native-amount startblock endblock )\n"
+            "grantwithdatafrom \"from-address\" \"to-address(es)\" \"permission(s)\" \"data-hex\"|object ( native-amount startblock endblock )\n"
             "\nGrant permission with metadata using specific address.\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -2156,9 +2204,16 @@ void mc_InitRPCHelpMap10()
             "2. \"address(es)\"                    (string, required) The multichain addresses to send to (comma delimited)\n"
             "3. \"permission(s)\"                  (string, required) Permission strings, comma delimited. \n"
             "                                                       Global: " + AllowedPermissions() + " \n"
-            "                                                       or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                       or per-asset: asset-identifier.issue,admin \n"
             "                                                       or per-stream: stream-identifier.write,activate,admin \n"
-            "4. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "4. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "4. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "5. native-amount                    (numeric, optional)  Native currency amount to send. eg 0.1. Default - 0.0\n"
             "6. startblock                       (numeric, optional)  Block to apply permissions from (inclusive). Default - 0\n"
             "7. endblock                         (numeric, optional)  Block to apply permissions to (exclusive). Default - 4294967295\n"
@@ -2172,7 +2227,7 @@ void mc_InitRPCHelpMap10()
         ));
     
     mapHelpStrings.insert(std::make_pair("grantwithmetadatafrom",
-            "grantwithmetadatafrom \"from-address\" \"to-address(es)\" \"permission(s)\" data|publish-new-stream-item ( native-amount startblock endblock )\n"
+            "grantwithmetadatafrom \"from-address\" \"to-address(es)\" \"permission(s)\" data-hex|object ( native-amount startblock endblock )\n"
             "\nGrant permission with metadata using specific address.\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -2180,9 +2235,16 @@ void mc_InitRPCHelpMap10()
             "2. \"address(es)\"                    (string, required) The multichain addresses to send to (comma delimited)\n"
             "3. \"permission(s)\"                  (string, required) Permission strings, comma delimited. \n"
             "                                                       Global: " + AllowedPermissions() + " \n"
-            "                                                       or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                       or per-asset: asset-identifier.issue,admin \n"
             "                                                       or per-stream: stream-identifier.write,activate,admin \n"
-            "4. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "4. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "4. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "5. native-amount                    (numeric, optional)  Native currency amount to send. eg 0.1. Default - 0.0\n"
             "6. startblock                       (numeric, optional)  Block to apply permissions from (inclusive). Default - 0\n"
             "7. endblock                         (numeric, optional)  Block to apply permissions to (exclusive). Default - 4294967295\n"
@@ -2267,7 +2329,6 @@ void mc_InitRPCHelpMap10()
             "    {\n"
             "      \"name\" : \"asset-name\"         (string, optional) Asset name\n"
             "      \"open\" : true|false           (boolean, optional, default false) True if follow-on issues are allowed\n"
-            "      \"restrict\" : \"restrictions\"   (string, optional) Permission strings, comma delimited. Possible values: send,receive\n"
             "      ,...\n"
             "    }\n"                                
             "3. quantity                         (numeric, required) The asset total amount in display units. eg. 1234.56\n"
@@ -2299,7 +2360,6 @@ void mc_InitRPCHelpMap10()
             "    {\n"
             "      \"name\" : \"asset-name\"         (string, optional) Asset name\n"
             "      \"open\" : true|false           (boolean, optional, default false) True if follow-on issues are allowed\n"
-            "      \"restrict\" : \"restrictions\"   (string, optional) Permission strings, comma delimited. Possible values: send,receive\n"
             "      ,...\n"
             "    }\n"                                
             "4. quantity                         (numeric, required) The asset total amount in display units. eg. 1234.56\n"
@@ -2927,7 +2987,7 @@ void mc_InitRPCHelpMap13()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                
-            "2. lock                             (boolean, optional, default=true) Lock prepared unspent output\n"
+            "2. lock                             (boolean, optiona, default=true) Lock prepared unspent output\n"
             "\nResult:\n"
             "{\n"
             "  \"txid\": \"transactionid\",          (string) Transaction ID of the output which can be spent in createrawexchange or createrawexchange\n"
@@ -2963,37 +3023,13 @@ void mc_InitRPCHelpMap13()
         ));
     
     mapHelpStrings.insert(std::make_pair("publish",
-            "publish \"stream-identifier\" \"key\"|keys \"data-hex\"|data-obj \"options\" \n"
+            "publish \"stream-identifier\" \"key\" \"data-hex\"\n"
             "\nPublishes stream item\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
             "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
             "2. \"key\"                            (string, required) Item key\n"
-            " or\n"    
-            "2. keys                             (array, required) Array of item keys\n"
-            "3. \"data-hex\"                       (string, required) Data hex string\n"
-            " or\n"
-            "3. data-json                        (object, required) JSON data object\n"
-            "    {\n"
-            "      \"json\" : data-json            (object, required) Valid JSON object\n" 
-            "    }\n"                                
-            " or\n"
-            "3. data-text                        (object, required) Text data object\n"
-            "    {\n"
-            "      \"text\" : \"data-text\"          (string, required) Data string\n" 
-            "    }\n"                                
-            " or\n"
-            "3. data-cached                      (object, required) Binary raw data created with appendbinarycache\n"
-            "    {\n"
-            "      \"cache\" : \"identifier\"        (string, required) Binary cache identifier\n" 
-            "    }\n"                                    
-/*    
-            "3. data-chunks                      (object, required) Offchain chunk hashes\n"
-            "    {\n"
-            "      \"chunks\" : chunk-hashes       (array, required) Array of chunk hashes created by storechunk\n" 
-            "    }\n"                                
- */ 
-            "4. \"options\"                        (string, optional) Should be \"offchain\" or omitted\n"
+            "3. \"data-hex\"                       (string, required) Item data hex string\n"
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3002,38 +3038,14 @@ void mc_InitRPCHelpMap13()
         ));
     
     mapHelpStrings.insert(std::make_pair("publishfrom",
-            "publishfrom \"from-address\" \"stream-identifier\" \"key\"|keys \"data-hex\"|data-obj \"options\" \n"
+            "publishfrom \"from-address\" \"stream-identifier\" \"key\" \"data-hex\"\n"
             "\nPublishes stream item from specific address\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
             "1. \"from-address\"                   (string, required) Address used for issuing.\n"
             "2. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
             "3. \"key\"                            (string, required) Item key\n"
-            " or\n"    
-            "3. keys                             (array, required) Array of item keys\n"
-            "4. \"data-hex\"                       (string, required) Data hex string\n"
-            " or\n"
-            "4. data-json                        (object, required) JSON data object\n"
-            "    {\n"
-            "      \"json\" : data-json            (object, required) Valid JSON object\n" 
-            "    }\n"                                
-            " or\n"
-            "4. data-text                        (object, required) Text data object\n"
-            "    {\n"
-            "      \"text\" : \"data-text\"          (string, required) Data string\n" 
-            "    }\n"                                
-            " or\n"
-            "4. data-cached                      (object, required) Binary raw data created with appendbinarycache\n"
-            "    {\n"
-            "      \"cache\" : \"identifier\"        (string, required) Binary cache identifier\n" 
-            "    }\n"                                
-/*    
-            "4. data-chunks                      (object, required) Offchain chunk hashes\n"
-            "    {\n"
-            "      \"chunks\" : chunk-hashes       (array, required) Array of chunk hashes created by storechunk\n" 
-            "    }\n"                                
- */ 
-            "5. \"options\"                        (string, optional) Should be \"offchain\" or omitted\n"
+            "4. \"data-hex\"                       (string, required) Item data hex string\n"
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3054,7 +3066,7 @@ void mc_InitRPCHelpMap13()
             "1. \"address(es)\"                    (string, required) The addresses(es) to revoke permissions from\n"
             "2. \"permission(s)\"                  (string, required) Permission strings, comma delimited. \n"
             "                                                       Global: " + AllowedPermissions() + " \n"
-            "                                                       or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                       or per-asset: asset-identifier.issue,admin \n"
             "                                                       or per-stream: stream-identifier.write,activate,admin \n"
             "3. native-amount                    (numeric, optional) native currency amount to send. eg 0.1. Default - 0\n"
             "4. \"comment\"                        (string, optional) A comment used to store what the transaction is for. \n"
@@ -3079,7 +3091,7 @@ void mc_InitRPCHelpMap13()
             "2. \"to-address(es)\"                 (string, required) The addresses(es) to revoke permissions from. Comma delimited\n"
             "3. \"permission(s)\"                  (string, required) Permission strings, comma delimited. \n"
             "                                                       Global: " + AllowedPermissions() + " \n"
-            "                                                       or per-asset: asset-identifier.issue,admin,activate,send,receive \n"
+            "                                                       or per-asset: asset-identifier.issue,admin \n"
             "                                                       or per-stream: stream-identifier.write,activate,admin \n"
             "4. native-amount                    (numeric, optional) native currency amount to send. eg 0.1. Default - 0\n"
             "5. \"comment\"                        (string, optional) A comment used to store what the transaction is for. \n"
@@ -3324,7 +3336,7 @@ void mc_InitRPCHelpMap14()
         ));
     
     mapHelpStrings.insert(std::make_pair("sendwithdata",
-            "sendwithdata \"address\" amount|asset-quantities data|publish-new-stream-item\n"
+            "sendwithdata \"address\" amount|asset-quantities \"data-hex\"|object\n"
             "\nSend an amount (or several asset amounts) to a given address with appended metadata. \n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -3336,7 +3348,14 @@ void mc_InitRPCHelpMap14()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                                
-            "3. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "3. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "3. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3346,7 +3365,7 @@ void mc_InitRPCHelpMap14()
         ));
     
     mapHelpStrings.insert(std::make_pair("sendwithmetadata",
-            "sendwithmetadata \"address\" amount|asset-quantities data|publish-new-stream-item\n"
+            "sendwithmetadata \"address\" amount|asset-quantities \"data-hex\"|object\n"
             "\nSend an amount (or several asset amounts) to a given address with appended metadata. \n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -3358,7 +3377,14 @@ void mc_InitRPCHelpMap14()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                                
-            "3. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "3. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "3. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3368,7 +3394,7 @@ void mc_InitRPCHelpMap14()
         ));
     
     mapHelpStrings.insert(std::make_pair("sendwithdatafrom",
-            "sendwithdatafrom \"from-address\" \"to-address\" amount|asset-quantities data|publish-new-stream-item\n"
+            "sendwithdatafrom \"from-address\" \"to-address\" amount|asset-quantities \"data-hex\"|object\n"
             "\nSend an amount (or several asset amounts) using specific address.\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -3381,7 +3407,14 @@ void mc_InitRPCHelpMap14()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                                
-            "4. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "4. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "4. publish-new-stream-item          (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3391,7 +3424,7 @@ void mc_InitRPCHelpMap14()
         ));
     
     mapHelpStrings.insert(std::make_pair("sendwithmetadatafrom",
-            "sendwithmetadatafrom \"from-address\" \"to-address\" amount|asset-quantities data|publish-new-stream-item\n"
+            "sendwithmetadatafrom \"from-address\" \"to-address\" amount|asset-quantities \"data-hex\"|object\n"
             "\nSend an amount (or several asset amounts) using specific address.\n"
             + HelpRequiringPassphraseWrapper() +
             "\nArguments:\n"
@@ -3404,7 +3437,14 @@ void mc_InitRPCHelpMap14()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                                
-            "4. data|publish-new-stream-item     (string or object, required) Data, see help data-with for details. \n"
+            "4. \"data-hex\"                       (string, required) Data hex string\n"
+            " or\n"
+            "4. publish-new-stream-item    (object, required) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
             "\"transactionid\"                     (string) The transaction id.\n"
             "\nExamples:\n"
@@ -3484,7 +3524,7 @@ void mc_InitRPCHelpMap15()
          ));
     
     mapHelpStrings.insert(std::make_pair("unsubscribe",
-            "unsubscribe entity-identifier(s) ( purge )\n"
+            "unsubscribe entity-identifier(s)\n"
             "\nUnsubscribes from the stream.\n"
             "\nArguments:\n"
             "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
@@ -3492,7 +3532,6 @@ void mc_InitRPCHelpMap15()
             "1. \"asset-identifier\"               (string, required) Asset identifier - one of the following: asset txid, asset reference, asset name.\n"
             " or\n"
             "1. entity-identifier(s)             (array, optional) A json array of stream or asset identifiers \n"                
-            "2. purge                            (boolean, optional, default=false) Purge all offchain data for the stream\n"
             "\nResult:\n"
             "\nExamples:\n"
             + HelpExampleCli("unsubscribe", "\"test-stream\"")
@@ -3550,7 +3589,6 @@ void mc_InitRPCHelpMap15()
             "                                                       miningturnover,\n"
             "                                                       lockadminminerounds,\n"
             "                                                       maxshowndata, \n"
-            "                                                       maxqueryscanitems, \n"
             "                                                       bantx,\n"
             "                                                       lockblock,\n"
             "                                                       autosubscribe,\n"
@@ -3568,7 +3606,7 @@ void mc_InitRPCHelpMap15()
 void mc_InitRPCHelpMap16()
 {
     mapHelpStrings.insert(std::make_pair("completerawexchange",
-            "completerawexchange hex txid vout ask-assets ( data|publish-new-stream-item ) \n"
+            "completerawexchange hex txid vout ask-assets ( \"data-hex\"|object ) \n"
             "\nCompletes existing exchange transaction, adds fee if needed\n"
             "Returns hex-encoded raw transaction.\n"
             + HelpRequiringPassphraseWrapper() +
@@ -3581,7 +3619,14 @@ void mc_InitRPCHelpMap16()
             "      \"asset-identifier\" : asset-quantity\n"
             "      ,...\n"
             "    }\n"                
-            "5. data|publish-new-stream-item     (string or object, optional) Data, see help data-with for details. \n"
+            "5. \"data-hex\"                       (string, optional) Data hex string\n"
+            " or\n"
+            "5. publish-new-stream-item          (object, optional) A json object with stream item\n"
+            "    {\n"                
+            "      \"for\" : stream-identifier     (string,required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
+            "      \"key\" : key                   (string,optional, default: \"\") Item key\n"
+            "      \"data\" : data-hex             (string,optional, default: \"\") Data hex string\n"
+            "    }\n"                                
             "\nResult:\n"
             "\"transaction\"                       (string) hex string of the transaction\n"
             "\nExamples:\n"
@@ -3634,8 +3679,51 @@ void mc_InitRPCHelpMap16()
             "       }\n"
             "       ,...\n"
             "     ]\n"
-            "3. addresses                              (object, required) Object with addresses as keys, see help addresses-all for details.\n"
-            "4. data                                   (array, optional) Array of hexadecimal strings or data objects, see help data-all for details.\n"
+            "3. addresses                              (object, optional) a json object with addresses as keys and amounts as values\n"
+            "    {\n"
+            "      \"address\": \n"
+            "        x.xxx                             (numeric, required) The key is the address, the value is the native currency amount\n"
+            "          or \n"
+            "        {                                 (object) A json object of assets to send\n"
+            "          \"asset-identifier\" : asset-quantity \n"
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                 (object) A json object describing new asset issue\n"
+            "          \"issue\" : \n"
+            "            {\n"
+            "              \"raw\" : n                   (numeric, required) The asset total amount in raw units \n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                 (object) A json object describing follow-on asset issue\n"
+            "          \"issuemore\" : \n"
+            "            {\n"
+            "              \"asset\" : \"asset-identifier\"(string, required) Asset identifier - one of the following: issue txid. asset reference, asset name.\n"
+            "              \"raw\" : n                   (numeric, required) The asset total amount in raw units \n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "          or \n"
+            "        {                                 (object) A json object describing permission change\n"
+            "          \"permissions\" : \n"
+            "            {\n"
+            "              \"type\" : \"permission(s)\"    (string,required) Permission strings, comma delimited. Possible values:\n"
+            "                                                              " + AllowedPermissions() + " \n"
+            "              \"startblock\" : n            (numeric, optional) Block to apply permissions from (inclusive). Default - 0\n"
+            "              \"endblock\" : n              (numeric, optional) Block to apply permissions to (exclusive). Default - 4294967295\n"
+            "              \"timestamp\" : n             (numeric, optional) This helps resolve conflicts between\n"
+            "                                                                permissions assigned by the same administrator. Default - current time\n"
+            "              ,...\n"
+            "            }\n"                                
+            "          ,...\n"
+            "        }\n"                                
+            "      ,...\n"
+            "    }\n"
+            "4. data                                   (array, optional) Array of hexadecimal strings or data objects, see help appendrawdata for details.\n"
             "5.\"action\"                                (string, optional, default \"\") Additional actions: \"lock\", \"sign\", \"lock,sign\", \"sign,lock\", \"send\". \n"
                 
 
@@ -3709,349 +3797,6 @@ void mc_InitRPCHelpMap16()
             + HelpExampleRpc("liststreamblockitems", "\"test-stream\", 1000, false, 20")
         ));
     
-    mapHelpStrings.insert(std::make_pair("liststreamtxitems",
-            "liststreamtxitems \"stream-identifier\" txids ( verbose )\n"
-            "\nReturns stream items.\n"
-            "\nArguments:\n"
-            "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "2. \"txids\"                          (string, required) Transaction IDs, comma delimited\n"
-            " or\n"
-            "2. txids                            (array, required) Array of transaction IDs\n"
-            "3. verbose                          (boolean, optional, default=false) If true, returns information about item transaction \n"
-            "\nResult:\n"
-            "\"stream-items\"                      (array) Array of stream items.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("liststreamtxitems", "\"mytxid\"") 
-            + HelpExampleCli("liststreamtxitems", "\"mytxid\"  true") 
-            + HelpExampleRpc("liststreamtxitems", "\"mytxid\", false")
-        ));
-    
-    mapHelpStrings.insert(std::make_pair("data-all",
-            "Data parameter(s) appearing in appendrawdata, appendrawtransaction, createrawtransaction, createrawsendfrom \n\n"
-            "\"data-hex\"                            (string, required) Data hex string\n"
-            " or\n"
-            "data-json                             (object, required) JSON data object\n"
-            "    {\n"
-            "      \"json\" : data-json              (object, required) Valid JSON object\n" 
-            "    }\n"                                
-            " or\n"
-            "data-text                             (object, required) Text data object\n"
-            "    {\n"
-            "      \"text\" : \"data-text\"            (string, required) Data string\n" 
-            "    }\n"                                
-            " or\n"
-            "data-cached                           (object, required) Binary raw data created with appendbinarycache\n"
-            "    {\n"
-            "      \"cache\" : \"identifier\"          (string, required) Binary cache identifier\n" 
-            "    }\n"                                
-            " or\n"
-            "issue-details                         (object, required) A json object with issue metadata\n"
-            "    {\n"
-            "      \"create\" : \"asset\"              (string, required) asset\n" 
-            "      \"name\" : \"asset-name\"           (string, optional) Asset name\n"
-            "      \"multiple\" : n                  (numeric, optional, default 1) Number of raw units in one displayed unit\n"
-            "      \"open\" : true|false             (boolean, optional, default false) True if follow-on issues are allowed\n"                
-            "      \"restrict\" : \"restrictions\"     (string, optional) Permission strings, comma delimited. Possible values: send,receive\n"
-            "      \"details\" :                     (object, optional) A json object with custom fields\n"           
-            "        {\n"
-            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
-            "          ,...\n"
-            "        }\n"
-            "    }\n"                                
-            " or\n"
-            "issuemore-details                     (object, required) A json object with issuemore metadata\n"
-            "    {\n"
-            "      \"update\" : \"asset-identifier\"   (string, required) Asset identifier - one of the following: asset txid, asset reference, asset name.\n"
-            "      \"details\" :                     (object, optional) A json object with custom fields\n"           
-            "        {\n"
-            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
-            "          ,...\n"
-            "        }\n"
-            "    }\n"                                
-            " or\n"
-            "create-new-stream                     (object, required) A json object with new stream details\n"
-            "    {\n"                
-            "      \"create\" : \"stream\"             (string, required) stream\n"
-            "      \"name\" : \"stream-name\"          (string, optional) Stream name\n"
-            "      \"open\" : true|false             (boolean, optional, default: false) If true, anyone can publish\n"
-            "      \"restrict\" : \"restrictions\"     (string, optional) Stream restrictions, comma delimited. Possible values: write,offchain,onchain\n"
-            "      \"details\" :                     (object, optional) A json object with custom fields\n"           
-            "        {\n"
-            "          \"param-name\": \"param-value\" (strings, required) The key is the parameter name, the value is parameter value\n"
-            "          ,...\n"
-            "        }\n"
-            "    }\n"                                
-            " or\n"
-            "publish-new-stream-item               (object, required) A json object with stream item\n"
-            "    {\n"                
-            "      \"for\" : \"stream-identifier\"     (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "      \"options\" : \"options\"           (string, optional) Should be \"offchain\" or omitted\n"
-            "      \"key\" : \"key\"                   (string, optional, default: \"\") Item key\n"
-            "        or\n"
-            "      \"keys\" : keys                   (array, optional) Item keys, array of strings\n"
-            "      \"data\" : \"data-hex\"             (string, optional, default: \"\") Data hex string\n"
-            "        or\n"
-            "      \"data\" :                        (object, required) JSON data object\n"
-            "        {\n"
-            "          \"json\" : data-json          (object, required) Valid JSON string\n" 
-            "        }\n"                                
-            "        or\n"
-            "      \"data\" :                        (object, required) Text data object\n"
-            "        {\n"
-            "          \"text\" : \"data-text\"        (string, required) Data string\n" 
-            "        }\n"                                
-            "        or\n"
-            "      \"data\"                          (object, required) Binary raw data created with appendbinarycache\n"
-            "        {\n"
-            "          \"cache\" : \"identifier\"      (string, required) Binary cache identifier\n" 
-            "        }\n"                              
-/*    
-            "      \"data\" :                        (object, required) Offchain chunk hashes\n"
-            "        {\n"
-            "          \"chunks\" : chunk-hashes     (array, required) Array of chunk hashes created by storechunk\n" 
-            "        }\n"                                
- */ 
-            "    }\n"                                
-            " or\n"
-            "create-new-upgrade                    (object, required) A json object with new upgrade details\n"
-            "    {\n"                
-            "      \"create\" : \"upgrade\"            (string, required) upgrade\n"
-            "      \"name\" : \"upgrade-name\"         (string, optional) Upgrade name\n"
-            "      \"startblock\" : n                (numeric, optional, default: 0) Block to apply upgrade from (inclusive).\n"
-            "      \"details\" :                     (object, optional) A json object with custom fields\n"           
-            "        {\n"
-            "          \"protocol-version\": version (numeric, optional) Protocol version to upgrade to \n"
-            "          \"parameter-name\": value     (numeric, optional) New value for upgradable parameter, one of the following: \n"
-            "                                                          target-block-time,\n"
-            "                                                          maximum-block-size,\n"
-            "                                                          max-std-tx-size,\n"
-            "                                                          max-std-op-returns-count,\n"
-            "                                                          max-std-op-return-size,\n"
-            "                                                          max-std-op-drops-count,\n"
-            "                                                          max-std-element-size\n"
-            "        }\n"
-            "    }\n"                                
-            " or\n"
-            "approve-upgrade                       (object, required) A json object with approval details\n"
-            "    {\n"                
-            "      \"approve\" : approve             (boolean, required) Approve or disapprove\n"
-            "      \"for\" : \"upgrade-identifier\"    (string, required)  Upgrade identifier - one of the following: upgrade txid, upgrade name.\n"
-            "    }\n"                                
-        ));
-
-    mapHelpStrings.insert(std::make_pair("data-with",
-            "Data parameter(s) appearing in completerawexchange, grantwithdata, grantwithdatafrom, sendwithdata, sendwithdatafrom\n\n"
-            "\"data-hex\"                            (string, required) Data hex string\n"
-            " or\n"
-            "data-json                             (object, required) JSON data object\n"
-            "    {\n"
-            "      \"json\" : data-json              (object, required) Valid JSON object\n" 
-            "    }\n"                                
-            " or\n"
-            "data-text                             (object, required) Text data object\n"
-            "    {\n"
-            "      \"text\" : \"data-text\"            (string, required) Data string\n" 
-            "    }\n"                                
-            " or\n"
-            "data-cached                           (object, required) Binary raw data created with appendbinarycache\n"
-            "    {\n"
-            "      \"cache\" : \"identifier\"          (string, required) Binary cache identifier\n" 
-            "    }\n"                                    
-            " or\n"
-            "publish-new-stream-item               (object, required) A json object with stream item\n"
-            "    {\n"                
-            "      \"for\" : \"stream-identifier\"     (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "      \"options\" : \"options\"           (string, optional) Should be \"offchain\" or omitted\n"
-            "      \"key\" : \"key\"                   (string, optional, default: \"\") Item key\n"
-            "        or\n"
-            "      \"keys\" : keys                   (array, optional) Item keys, array of strings\n"
-            "      \"data\" : \"data-hex\"             (string, optional, default: \"\") Data hex string\n"
-            "        or\n"
-            "      \"data\" :                        (object, required) JSON data object\n"
-            "        {\n"
-            "          \"json\" : data-json          (object, required) Valid JSON string\n" 
-            "        }\n"                                
-            "        or\n"
-            "      \"data\" :                        (object, required) JSON data object\n"
-            "        {\n"
-            "          \"text\" : \"data-text\"        (string, required) Data string\n" 
-            "        }\n"                                
-            "        or\n"
-            "     \"data\" :                         (object, required) Binary raw data created with appendbinarycache\n"
-            "        {\n"
-            "          \"cache\" : \"identifier\"      (string, required) Binary cache identifier\n" 
-            "        }\n"                                    
-/*    
-            "      \"data\" :                        (object, required) Text chunk hashes\n"
-            "        {\n"
-            "          \"chunks\" : chunk-hashes     (array, required) Array of chunk hashes created by storechunk\n" 
-            "        }\n"                                
- */ 
-            "    }\n"                                
-        ));
-
-     mapHelpStrings.insert(std::make_pair("addresses-all",
-            "Addresses parameter(s) appearing in appendrawtransaction, createrawtransaction, createrawsendfrom,  \n\n"
-
-            "{\n"
-            "  \"address\":                           (string, required) Destination address\n"
-            "   x.xxx                               (numeric, required) The value is the native currency amount\n"
-            "     or \n"
-            "   {                                   (object) A json object of assets to send\n"
-            "      \"asset-identifier\" :             (string, required) Asset identifier - one of the following: issue txid, asset reference, asset name. \"\" for native currency.\n"
-            "       asset-quantity                  (numeric, required) The asset value. \n"
-            "     ,...\n"
-            "   }\n"                                
-            "      or \n"
-            "   {                                   (object) A json object describing new asset issue\n"
-            "     \"issue\" : \n"
-            "       {\n"
-            "          \"raw\" : n                    (numeric, required) The asset total amount in raw units \n"
-            "       }\n"                                
-            "   }\n"                                
-            "      or \n"
-            "   {                                   (object) A json object describing follow-on asset issue\n"
-            "     \"issuemore\" : \n"
-            "       {\n"
-            "          \"asset\" : \"asset-identifier\" (string, required) Asset identifier - one of the following: issue txid. asset reference, asset name.\n"
-            "          \"raw\" : n                    (numeric, required) The asset total amount in raw units \n"
-            "       }\n"                                
-            "   }\n"                                
-            "      or \n"
-            "   {                                   (object) A json object describing permission change\n"
-            "      \"permissions\" : \n"
-            "        {\n"
-            "          \"type\" : \"permission(s)\"     (string, required) Permission strings, comma delimited. Possible values:\n"
-            "                                                          " + AllowedPermissions() + " \n"
-            "          \"startblock\" : n             (numeric, optional) Block to apply permissions from (inclusive). Default - 0\n"
-            "          \"endblock\"  : n              (numeric, optional) Block to apply permissions to (exclusive). Default - 4294967295\n"
-            "          \"timestamp\" : n              (numeric, optional) This helps resolve conflicts between\n"
-            "                                                           permissions assigned by the same administrator. Default - current time\n"
-            "        }\n"                                
-            "   }\n"                    
-            "      or \n"
-            "   {                                   (object) A json object describing inline data\n"
-            "      \"data\" : \n"
-            "        {\n"     
-            "          \"data-hex\"                   (string, required) Data hex string\n"
-            "             or\n"
-            "          data-json                    (object, required) JSON data object\n"
-            "            {\n"
-            "              \"json\" : data-json       (object, required) Valid JSON object\n" 
-            "            }\n"                                
-            "             or\n"
-            "          data-text                    (object, required) Text data object\n"
-            "            {\n"
-            "              \"text\" : \"data-text\"     (string, required) Data string\n" 
-            "            }\n"                                
-            "             or\n"
-            "          data-cached                  (object, required) Binary raw data created with appendbinarycache\n"
-            "            {\n"
-            "              \"cache\" : \"identifier\"   (string, required) Binary cache identifier\n" 
-            "            }\n"                                    
-            "        }\n"                    
-            "   }\n"                    
-     
-            " ,...\n"
-            "}\n"
-        ));
-    
-}
-
-void mc_InitRPCHelpMap17()
-{
-     mapHelpStrings.insert(std::make_pair("getstreamkeysummary",
-            "getstreamkeysummary \"stream-identifier\" \"key\" \"mode\"\n"
-            "\nReturns stream json object items summary for specific key.\n"
-            "\nArguments:\n"
-            "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "2. \"key\"                            (string, required) Stream key\n"
-            "3. \"mode\"                           (string, required) Comma delimited list of the following:\n"
-            "                                                       jsonobjectmerge (required) - merge json objects\n"
-            "                                                       recursive - merge json sub-objects recursively\n"
-            "                                                       noupdate -  preserve first value for each key instead of taking the last\n"
-            "                                                       omitnull - omit keys with null values\n"
-            "                                                       ignoreother - ignore items that cannot be included in summary (otherwise returns an error)\n"
-            "                                                       ignoremissing - ignore missing offchain items (otherwise returns an error)\n"
-            "                                                       firstpublishersany - only summarize items by a publisher of first item with this key\n"
-            "                                                       firstpublishersall - only summarize items by all publishers of first item with this key\n"
-            "\nResult:\n"
-            "summary-object                      (object) Summary object for specific key.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getstreamkeysummary", "\"test-stream\" \"key01\" \"jsonobjectmerge\"") 
-            + HelpExampleCli("getstreamkeysummary", "\"test-stream\" \"key01\" \"jsonobjectmerge,ignore,recursive\"") 
-            + HelpExampleRpc("getstreamkeysummary", "\"test-stream\", \"key01\", \"jsonobjectmerge,ignore,recursive\"")
-        ));
-    
-   
-     mapHelpStrings.insert(std::make_pair("getstreampublishersummary",
-            "getstreampublishersummary \"stream-identifier\" \"address\" \"mode\"\n"
-            "\nReturns stream json object items summary for specific publisher.\n"
-            "\nArguments:\n"
-            "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "2. \"address\"                        (string, required) Publisher address\n"
-            "3. \"mode\"                           (string, required) Comma delimited list of the following:\n"
-            "                                                       jsonobjectmerge (required) - merge json objects\n"
-            "                                                       recursive - merge json sub-objects recursively\n"
-            "                                                       noupdate -  preserve first value for each key instead of taking the last\n"
-            "                                                       omitnull - omit keys with null values\n"
-            "                                                       ignoreother - ignore items that cannot be included in summary (otherwise returns an error)\n"
-            "                                                       ignoremissing - ignore missing offchain items (otherwise returns an error)\n"
-            "\nResult:\n"
-            "summary-object                      (object) Summary object for specific publisher.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("liststreampublisheritems", "\"test-stream\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" \"jsonobjectmerge\"") 
-            + HelpExampleCli("liststreampublisheritems", "\"test-stream\" \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\" \"jsonobjectmerge,ignore,recursive\"") 
-            + HelpExampleRpc("liststreampublisheritems", "\"test-stream\", \"1M72Sfpbz1BPpXFHz9m3CdqATR44Jvaydd\", \"jsonobjectmerge,ignore,recursive\"")
-        ));
-    
-     mapHelpStrings.insert(std::make_pair("storechunk",
-            "storechunk \"data-hex\" \n"
-            "\nStores chunk of data in local wallet. Returns hash of the data, which can be used later when publishing offchain stream items.\n"
-            "\nArguments:\n"
-            "1. \"data-hex\"                       (string, required) The hex string of the data chunk\n"
-            "\nResult:\n"
-            "\"hex\"                               (string) The chunk hash in hex\n"
-            "\nExamples:\n"
-            + HelpExampleCli("storechunk", "\"f4c3dd510dd55761015c9d96bff7793b0d501dd6f01a959fd7\"") 
-            + HelpExampleRpc("storechunk", "\"f4c3dd510dd55761015c9d96bff7793b0d501dd6f01a959fd7\"")
-        ));
-    
-     mapHelpStrings.insert(std::make_pair("createbinarycache",
-            "createbinarycache \n"
-            "\nReturns random string, which can be used as binary cache item identifier\n"
-            "\nArguments:\n"
-            "\nResult:\n"
-            "\"identifier\"                               (string) Binary cache item identifier\n"
-            "\nExamples:\n"
-            + HelpExampleCli("createbinarycache","") 
-            + HelpExampleRpc("createbinarycache","")
-        ));
-    
-     mapHelpStrings.insert(std::make_pair("appendbinarycache",
-            "appendbinarycache \"identifier\" \"data-hex\" \n"
-            "\nAppends data to binary cache.\n"
-            "\nArguments:\n"
-            "1. \"identifier\"                     (string, required) Binary cache item identifier\n"
-            "2. \"data-hex\"                       (string, required) The hex string to be added to binary cache item\n"
-            "\nResult:\n"
-            "size                                (numeric) Size of the binary cache item\n"
-            "\nExamples:\n"
-            + HelpExampleCli("appendbinarycache", "\"TjnVWwHYEg4\" \"f4c3dd510dd55761015c9d96bff7793b0d501dd6f01a959fd7\"") 
-            + HelpExampleRpc("appendbinarycache", "\"TjnVWwHYEg4\",\"f4c3dd510dd55761015c9d96bff7793b0d501dd6f01a959fd7\"")
-        ));
-    
-     mapHelpStrings.insert(std::make_pair("deletebinarycache",
-            "deletebinarycache \"identifier\"  \n"
-            "\nClear binary cache item\n"
-            "\nArguments:\n"
-            "1. \"identifier\"                     (string, required) Binary cache item identifier, \"*\" - to clear all items\n"
-            "\nResult:\n"
-            "\nExamples:\n"
-            + HelpExampleCli("deletebinarycache", "\"TjnVWwHYEg4\"") 
-            + HelpExampleRpc("deletebinarycache", "\"TjnVWwHYEg4\"")
-        ));
-    
     mapHelpStrings.insert(std::make_pair("walletpassphrase",
             "walletpassphrase \"passphrase\" timeout\n"
             "\nStores the wallet decryption key in memory for 'timeout' seconds.\n"
@@ -4099,57 +3844,11 @@ void mc_InitRPCHelpMap17()
             + HelpExampleRpc("walletlock", "")
         ));
 
-     
-    mapHelpStrings.insert(std::make_pair("getchunkqueueinfo",
-            "getchunkqueueinfo\n"
-            "\nReturns data about each current chunk queue status.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getchunkqueueinfo", "")
-            + HelpExampleRpc("getchunkqueueinfo", "")
-        ));
-    
-}
 
-void mc_InitRPCHelpMap18()
-{
-    mapHelpStrings.insert(std::make_pair("getchunkqueuetotals",
-            "getchunkqueuetotals\n"
-            "\nReturns chunks delivery statistics.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("getchunkqueuetotals", "")
-            + HelpExampleRpc("getchunkqueuetotals", "")
-        ));
-    
-    
-     mapHelpStrings.insert(std::make_pair("liststreamqueryitems",
-            "liststreamqueryitems \"stream-identifier\" query ( verbose )\n"
-            "\nReturns stream items for specific query.\n"
-            "\nArguments:\n"
-            "1. \"stream-identifier\"              (string, required) Stream identifier - one of the following: stream txid, stream reference, stream name.\n"
-            "2. query                            (object, required) Query\n"
-            "    {\n"                
-            "      \"key\" : \"key\"                   (string, optional, default: \"\") Item key\n"
-            "        or\n"
-            "      \"keys\" : keys                   (array, optional) Item keys, array of strings\n"
-            "        and/or\n"
-            "      \"publisher\" : \"publisher\"       (string, optional, default: \"\") Publisher\n"
-            "        or\n"
-            "      \"publishers\" : publishers       (array, optional) Publishers, array of strings\n"
-            "    }\n"                                
-            "3. verbose                          (boolean, optional, default=false) If true, returns information about item transaction \n"
-            "\nResult:\n"
-            "\"stream-items\"                      (array) List of stream items for specific query.\n"
-            "\nExamples:\n"
-            + HelpExampleCli("liststreamqueryitems", "\"test-stream\" \"{\\\"keys\\\":[\\\"key01\\\",\"key02\"]}\"") 
-            + HelpExampleCli("liststreamqueryitems", "\"test-stream\" \"{\\\"keys\\\":[\\\"key01\\\",\"key02\"],\\\"publisher\\\":\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"}\" true ") 
-            + HelpExampleRpc("liststreamqueryitems", "\"test-stream\", \"{\\\"keys\\\":[\\\"key01\\\",\"key02\"],\\\"publisher\\\":\\\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XZ\\\"}\", false")
-        ));
-    
-   mapHelpStrings.insert(std::make_pair("AAAAAAA",
+    mapHelpStrings.insert(std::make_pair("AAAAAAA",
             ""
         ));
        
-    
 }
 
 void mc_InitRPCLogParamCountMap()
@@ -4242,18 +3941,9 @@ void mc_InitRPCHelpMap()
     mc_InitRPCHelpMap14();
     mc_InitRPCHelpMap15();
     mc_InitRPCHelpMap16();
-    mc_InitRPCHelpMap17();
-    mc_InitRPCHelpMap18();
     
     mc_InitRPCLogParamCountMap();
     mc_InitRPCAllowedWhenWaitingForUpgradeSet();    
     mc_InitRPCAllowedWhenOffline();    
 }
 
-Value purehelpitem(const Array& params, bool fHelp)
-{
-    if (fHelp)
-        throw runtime_error("Help message not found\n");
-    
-    return Value::null; 
-}
\ No newline at end of file
diff --git a/src/rpc/rpclist.cpp b/src/rpc/rpclist.cpp
index 294e74d..99a8ac7 100644
--- a/src/rpc/rpclist.cpp
+++ b/src/rpc/rpclist.cpp
@@ -70,8 +70,6 @@ static const CRPCCommand vRPCCommands[] =
     { "network",            "getnettotals",           &getnettotals,           true,      true,       false },
     { "network",            "getpeerinfo",            &getpeerinfo,            true,      false,      false },
     { "network",            "ping",                   &ping,                   true,      false,      false },
-    { "network",            "getchunkqueueinfo",      &getchunkqueueinfo,      true,      true,       true  },
-    { "network",            "getchunkqueuetotals",    &getchunkqueuetotals,         true,      true,       true  },
 
     /* Block chain and UTXO */
     { "blockchain",         "getblockchaininfo",      &getblockchaininfo,      true,      false,      false },
@@ -123,7 +121,6 @@ static const CRPCCommand vRPCCommands[] =
     { "rawtransactions",    "appendrawchange",        &appendrawchange,        false,     false,      true },
     { "hidden",             "appendrawmetadata",      &appendrawmetadata,      false,     false,      true },
     { "rawtransactions",    "appendrawdata",          &appendrawmetadata,      false,     false,      true },
-    { "hidden",             "debug",                  &debug,               false,     true,       true },
 /* MCHN END */    
 
     /* Utility functions */
@@ -133,18 +130,11 @@ static const CRPCCommand vRPCCommands[] =
     { "util",               "verifymessage",          &verifymessage,          true,      false,      false },
     { "util",               "estimatefee",            &estimatefee,            true,      true,       false },
     { "util",               "estimatepriority",       &estimatepriority,       true,      true,       false },
-    
-    { "util",               "createbinarycache",      &createbinarycache,      true,      false,       false },
-    { "util",               "appendbinarycache",      &appendbinarycache,      true,      false,       false },
-    { "util",               "deletebinarycache",      &deletebinarycache,       true,      false,       false },
 
     /* Not shown in help */
     { "hidden",             "invalidateblock",        &invalidateblock,        true,      true,       false },
     { "hidden",             "reconsiderblock",        &reconsiderblock,        true,      true,       false },
     { "hidden",             "setmocktime",            &setmocktime,            true,      false,      false },
-    { "hidden",             "data-all",               &purehelpitem,           true,      true,       true },
-    { "hidden",             "data-with",               &purehelpitem,           true,      true,       true },
-    { "hidden",             "addresses-all",          &purehelpitem,           true,      true,       true },
 
 #ifdef ENABLE_WALLET
     /* Wallet */
@@ -238,18 +228,13 @@ static const CRPCCommand vRPCCommands[] =
     { "wallet",             "listassettransactions",  &listassettransactions,         false,     false,      true },
     { "wallet",             "getassettransaction",    &getassettransaction,         false,     false,      true },
     { "wallet",             "getstreamitem",          &getstreamitem,         false,     false,      true },
-    { "wallet",             "liststreamtxitems",      &liststreamtxitems,         false,     false,      true },
     { "wallet",             "liststreamitems",        &liststreamitems,         false,     false,      true },
-    { "wallet",             "liststreamqueryitems",   &liststreamqueryitems,      false,     false,      true },
     { "wallet",             "liststreamkeyitems",     &liststreamkeyitems,      false,     false,      true },
     { "wallet",             "liststreampublisheritems",&liststreampublisheritems,false,     false,      true },
     { "wallet",             "liststreamkeys",         &liststreamkeys,        false,     false,      true },
     { "wallet",             "liststreampublishers",   &liststreampublishers,  false,     false,      true },
     { "wallet",             "gettxoutdata",           &gettxoutdata,           false,     false,      true },
     { "wallet",             "liststreamblockitems",   &liststreamblockitems,    false,      false,      false },
-    { "wallet",             "getstreamkeysummary",    &getstreamkeysummary,        false,     false,      true },
-    { "wallet",             "getstreampublishersummary",   &getstreampublishersummary,        false,     false,      true },
-    { "hidden",             "storechunk",             &storechunk,                false,     false,      true },
     
 /* MCHN END */    
     { "wallet",             "setaccount",             &setaccount,             true,      false,      true },
diff --git a/src/rpc/rpcmisc.cpp b/src/rpc/rpcmisc.cpp
index 358cd15..22cde14 100644
--- a/src/rpc/rpcmisc.cpp
+++ b/src/rpc/rpcmisc.cpp
@@ -67,8 +67,7 @@ Value getinfo(const Array& params, bool fHelp)
 /* MCHN START */    
 //    obj.push_back(Pair("version", CLIENT_VERSION));
 //    obj.push_back(Pair("protocolversion", PROTOCOL_VERSION));
-    
-    obj.push_back(Pair("version", mc_BuildDescription(mc_gState->GetNumericVersion())));
+    obj.push_back(Pair("version", mc_gState->GetVersion()));
     obj.push_back(Pair("nodeversion", mc_gState->GetNumericVersion()));
     obj.push_back(Pair("protocolversion", mc_gState->m_NetworkParams->ProtocolVersion()));
     obj.push_back(Pair("chainname", string(mc_gState->m_NetworkParams->Name())));
@@ -82,8 +81,7 @@ Value getinfo(const Array& params, bool fHelp)
     obj.push_back(Pair("burnaddress", BurnAddress(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))));                
     obj.push_back(Pair("incomingpaused", (mc_gState->m_NodePausedState & MC_NPS_INCOMING) ? true : false));                
     obj.push_back(Pair("miningpaused", (mc_gState->m_NodePausedState & MC_NPS_MINING) ? true : false));                
-    obj.push_back(Pair("offchainpaused", (mc_gState->m_NodePausedState & MC_NPS_OFFCHAIN) ? true : false));                
-
+    
 /* MCHN END */    
 #ifdef ENABLE_WALLET
     if (pwalletMain) {
@@ -225,8 +223,6 @@ Value getruntimeparams(const json_spirit::Array& params, bool fHelp)
     obj.push_back(Pair("lockblock",GetArg("-lockblock","")));                        
     obj.push_back(Pair("hideknownopdrops",GetBoolArg("-hideknownopdrops",false)));                    
     obj.push_back(Pair("maxshowndata",GetArg("-maxshowndata",MAX_OP_RETURN_SHOWN)));                    
-    obj.push_back(Pair("maxqueryscanitems",GetArg("-maxqueryscanitems",MAX_STREAM_QUERY_ITEMS)));                    
-    obj.push_back(Pair("v1apicompatible",GetBoolArg("-v1apicompatible",false)));                    
     obj.push_back(Pair("miningrequirespeers",Params().MiningRequiresPeers()));                    
     obj.push_back(Pair("mineemptyrounds",Params().MineEmptyRounds()));                    
     obj.push_back(Pair("miningturnover",Params().MiningTurnover()));                    
@@ -361,7 +357,6 @@ Value setruntimeparam(const json_spirit::Array& params, bool fHelp)
     }
     if( (param_name == "lockadminminerounds") ||
         (param_name == "maxshowndata") ||
-        (param_name == "maxqueryscanitems") ||
         (param_name == "dropmessagestest") )
     {
         if( (params[1].type() == int_type) || (params[1].type() == str_type) )
@@ -390,27 +385,6 @@ Value setruntimeparam(const json_spirit::Array& params, bool fHelp)
         }
         fFound=true;
     }
-    if( (param_name == "compatibility") )
-    {
-        if( (params[1].type() == int_type) || (params[1].type() == str_type) )
-        {
-            int nValue;
-            if(params[1].type() == int_type)
-            {
-                nValue=params[1].get_int();
-            }
-            else
-            {
-                nValue=atoi(params[1].get_str().c_str());
-            }
-            mc_gState->m_Compatibility=(uint32_t)nValue;
-        }        
-        else
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter value type");                                            
-        }
-        fFound=true;
-    }
     if(param_name == "bantx")
     {
         if(params[1].type() == str_type)
@@ -527,6 +501,7 @@ Value getblockchainparams(const json_spirit::Array& params, bool fHelp)
     if (fHelp || params.size() > 2)                                            // MCHN
         throw runtime_error("Help message not found\n");
 
+    
     bool fDisplay = true;
     if (params.size() > 0)
         fDisplay = params[0].get_bool();
@@ -579,7 +554,6 @@ Value getblockchainparams(const json_spirit::Array& params, bool fHelp)
             Value param_value;
             unsigned char* ptr;
             int size;
-            bool hidden=false;
             string param_string="";;
 
             ptr=(unsigned char*)mc_gState->m_NetworkParams->GetParam((mc_gState->m_NetworkParams->m_lpParams+i)->m_Name,&size);
@@ -659,13 +633,6 @@ Value getblockchainparams(const json_spirit::Array& params, bool fHelp)
                         else
                         {
                             param_value=mc_GetLE(ptr,4);                                                                
-                            if((mc_gState->m_NetworkParams->m_lpParams+i)->m_Type & MC_PRM_HIDDEN)
-                            {
-                                if(mc_GetLE(ptr,4) == (mc_gState->m_NetworkParams->m_lpParams+i)->m_DefaultIntegerValue)
-                                {
-                                    hidden=true;
-                                }
-                            }
                         }
                         break;
                     case MC_PRM_INT64:
@@ -680,54 +647,15 @@ Value getblockchainparams(const json_spirit::Array& params, bool fHelp)
             {
                 param_value=Value::null;
             }
-            if(nHeight)
+            if(strcmp("protocolversion",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
             {
-                if(strcmp("protocolversion",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
+                if(nHeight)
                 {
                     param_value=mc_gState->m_NetworkParams->m_ProtocolVersion;
                 }
-                if(strcmp("maximumblocksize",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_BLOCK_SIZE;
-                }
-                if(strcmp("targetblocktime",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MCP_TARGET_BLOCK_TIME;
-                }
-                if(strcmp("maxstdtxsize",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_STANDARD_TX_SIZE;
-                }
-                if(strcmp("maxstdopreturnscount",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MCP_MAX_STD_OP_RETURN_COUNT;
-                }
-                if(strcmp("maxstdopreturnsize",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_OP_RETURN_RELAY;
-                }
-                if(strcmp("maxstdopdropscount",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MCP_STD_OP_DROP_COUNT;
-                }
-                if(strcmp("maxstdelementsize",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_SCRIPT_ELEMENT_SIZE;
-                }
-                if(strcmp("maximumchunksize",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_CHUNK_SIZE;
-                }
-                if(strcmp("maximumchunkcount",(mc_gState->m_NetworkParams->m_lpParams+i)->m_Name) == 0)
-                {
-                    param_value=(int)MAX_CHUNK_COUNT;
-                }
             }
 
-            if(!hidden)
-            {
-                obj.push_back(Pair(param_name,param_value));        
-            }
+            obj.push_back(Pair(param_name,param_value));        
         }
     }
     
@@ -1078,6 +1006,7 @@ Value createmultisig(const Array& params, bool fHelp)
 /* MCHN START */    
     if(mc_gState->m_NetworkParams->IsProtocolMultichain())
     {
+//        if(MCP_ALLOW_ARBITRARY_OUTPUTS == 0)
         if((MCP_ALLOW_ARBITRARY_OUTPUTS == 0) || (mc_gState->m_Features->FixedDestinationExtraction() == 0) )
         {
             if(MCP_ALLOW_P2SH_OUTPUTS == 0)
diff --git a/src/rpc/rpcnet.cpp b/src/rpc/rpcnet.cpp
index 2147712..6dcbd76 100644
--- a/src/rpc/rpcnet.cpp
+++ b/src/rpc/rpcnet.cpp
@@ -25,7 +25,6 @@
 
 using namespace json_spirit;
 using namespace std;
-void PushMultiChainRelay(CNode* pto, uint32_t msg_type,vector<CAddress>& path,vector<CAddress>& path_to_follow,vector<unsigned char>& payload);
 
 Value getconnectioncount(const Array& params, bool fHelp)
 {
@@ -175,19 +174,6 @@ Value addnode(const Array& params, bool fHelp)
         if (it == vAddedNodes.end())
             throw JSONRPCError(RPC_CLIENT_NODE_NOT_ADDED, "Error: Node has not been added.");
         vAddedNodes.erase(it);
-        if(GetBoolArg("-addnodeonly",false))
-        {
-            LOCK(cs_vNodes);
-            CAddress addrNode=CAddress(CService(strNode.c_str(),Params().GetDefaultPort(),0));
-            BOOST_FOREACH(CNode* pnode, vNodes)
-            {
-                if (pnode->addr == addrNode)
-                {
-                    pnode->fDisconnect=true;
-                }
-            }
-        }
-        
     }
 
     return Value::null;
@@ -268,13 +254,6 @@ Value getaddednodeinfo(const Array& params, bool fHelp)
                     fFound = true;
                     fConnected = true;
                     node.push_back(Pair("connected", pnode->fInbound ? "inbound" : "outbound"));
-                    
-                    vector<CAddress>path;
-                    vector<CAddress>path_to_follow;
-                    vector<unsigned char> payload;
-                    
-//                    PushMultiChainRelay(pnode, MC_RMT_GLOBAL_PING,path,path_to_follow,payload);
-
                     break;
                 }
             if (!fFound)
diff --git a/src/rpc/rpcpermissions.cpp b/src/rpc/rpcpermissions.cpp
index 8b9dcc2..2fdfdb7 100644
--- a/src/rpc/rpcpermissions.cpp
+++ b/src/rpc/rpcpermissions.cpp
@@ -10,7 +10,11 @@
 
 string AllowedPermissions()
 {
-    string ret="connect,send,receive,issue,mine,admin,activate,create";
+    string ret="connect,send,receive,issue,mine,admin,activate";
+    if(mc_gState->m_Features->Streams())
+    {
+        ret += ",create";
+    }
     
     return ret;
 }
@@ -113,8 +117,7 @@ Value grantoperation(const Array& params)
         LogPrintf("mchn: Granting %s permission(s) to address %s (%ld-%ld), Entity TxID: %s, Name: %s\n",permission_type,params[1].get_str(),from,to,
                 ((uint256*)entity.GetTxID())->ToString().c_str(),entity.GetName());
         
-//        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),entity.GetEntityType());
-        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),&entity);
+        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),entity.GetEntityType());
         
         if(type == 0)
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid permission");
@@ -123,8 +126,7 @@ Value grantoperation(const Array& params)
     }
     else
     {
-        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),&entity);
-//        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),MC_ENT_TYPE_NONE);
+        type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),MC_ENT_TYPE_NONE);
         
         if(type == 0)
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid permission");
@@ -152,7 +154,7 @@ Value grantoperation(const Array& params)
     CScript scriptOpReturn=CScript();
     if (params.size() > 3)
     {
-        scriptOpReturn=ParseRawMetadata(params[3],MC_DATA_API_PARAM_TYPE_SIMPLE,NULL,&found_entity);
+        scriptOpReturn=ParseRawMetadata(params[3],0x0002,NULL,&found_entity);
     }
     
     if(fromaddresses.size() == 1)
@@ -469,8 +471,7 @@ Value listpermissions(const Array& params, bool fHelp)
         lpEntity=entity.GetTxID();
     }
     
-//    type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),entity.GetEntityType());
-    type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),&entity);
+    type=mc_gState->m_Permissions->GetPermissionType(permission_type.c_str(),entity.GetEntityType());
     if(type == 0)
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid permission");
     
diff --git a/src/rpc/rpcrawdata.cpp b/src/rpc/rpcrawdata.cpp
deleted file mode 100644
index 87ced8f..0000000
--- a/src/rpc/rpcrawdata.cpp
+++ /dev/null
@@ -1,1631 +0,0 @@
-// Copyright (c) 2009-2010 Satoshi Nakamoto
-// Copyright (c) 2014-2016 The Bitcoin Core developers
-// Original code was distributed under the MIT software license.
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "rpc/rpcutils.h"
-
-#include "utils/util.h"
-#include "json/json_spirit_ubjson.h"
-
-#include <boost/assign/list_of.hpp>
-
-using namespace std;
-using namespace json_spirit;
-
-uint32_t ParseRawDataParamType(Value *param,mc_EntityDetails *given_entity,mc_EntityDetails *entity,uint32_t *data_format,int *errorCode,string *strError)
-{
-    uint32_t param_type=MC_DATA_API_PARAM_TYPE_NONE;   
-    uint32_t this_param_type;  
-    bool missing_data=true;
-    *data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    entity->Zero();
-    
-    if(param->type() == obj_type)
-    {
-        BOOST_FOREACH(const Pair& d, param->get_obj()) 
-        {
-            this_param_type=MC_DATA_API_PARAM_TYPE_NONE;   
-            if(d.name_ == "inputcache")
-            {
-                this_param_type=MC_DATA_API_PARAM_TYPE_CIS;
-            }            
-            if(d.name_ == "create")
-            {
-                if(d.value_.type() != null_type && !d.value_.get_str().empty())
-                {
-                    if(d.value_.get_str() == "stream")
-                    {
-                        this_param_type=MC_DATA_API_PARAM_TYPE_CREATE_STREAM;
-                    }
-                    if(d.value_.get_str() == "asset")
-                    {
-                        this_param_type=MC_DATA_API_PARAM_TYPE_ISSUE;
-                    }
-                    if(d.value_.get_str() == "upgrade")
-                    {
-                        this_param_type=MC_DATA_API_PARAM_TYPE_CREATE_UPGRADE;
-                    }
-                }
-                if(this_param_type == MC_DATA_API_PARAM_TYPE_NONE)
-                {
-                    *strError=string("Invalid new entity type");                            
-                    goto exitlbl;                        
-                }
-            }
-            if(d.name_ == "update")
-            {
-                if(d.value_.type() != null_type && !d.value_.get_str().empty())
-                {
-                    ParseEntityIdentifier(d.value_,entity, MC_ENT_TYPE_ASSET);       
-                }
-                if(entity->GetEntityType() != MC_ENT_TYPE_ASSET)
-                {
-                    *strError=string("Asset with this identifier not found");                                                                        
-                    goto exitlbl;                        
-                }                
-                this_param_type=MC_DATA_API_PARAM_TYPE_FOLLOWON;                
-            }
-            if(d.name_ == "for")
-            {
-                if(d.value_.type() != null_type && !d.value_.get_str().empty())
-                {
-                    ParseEntityIdentifier(d.value_,entity, MC_ENT_TYPE_ANY);       
-                }                
-                if(entity->GetEntityType() == MC_ENT_TYPE_STREAM)
-                {
-                    this_param_type=MC_DATA_API_PARAM_TYPE_PUBLISH;                
-                }
-                if(entity->GetEntityType() == MC_ENT_TYPE_UPGRADE)
-                {
-                    this_param_type=MC_DATA_API_PARAM_TYPE_APPROVAL;                
-                }
-                if(this_param_type == MC_DATA_API_PARAM_TYPE_NONE)
-                {
-                    *strError=string("Entity with this identifier not found");                            
-                    goto exitlbl;                        
-                }
-            }
-            if( (d.name_ == "text") || (d.name_ == "json")  || (d.name_ == "cache") )
-            {
-                if( mc_gState->m_Features->FormattedData() == 0 )
-                {
-                    *errorCode=RPC_NOT_SUPPORTED;
-                    *strError=string("Formatted data is not supported by this protocol version");       
-                    goto exitlbl;
-                }
-                if(!missing_data)
-                {
-                    *strError=string("data field can appear only once in the object");                                                                                        
-                    goto exitlbl;                    
-                }
-                missing_data=false;
-            }
-            if(this_param_type != MC_DATA_API_PARAM_TYPE_NONE)
-            {
-                if(param_type != MC_DATA_API_PARAM_TYPE_NONE)
-                {                
-                    *strError=string("Only one of the following keywords can appear in the object: create, update, for, json, text");                                                                                        
-                    goto exitlbl;
-                }
-            }
-            if(this_param_type != MC_DATA_API_PARAM_TYPE_NONE)
-            {
-                param_type=this_param_type;
-            }
-        }    
-        if(param_type == MC_DATA_API_PARAM_TYPE_NONE)
-        {                
-//            if(*data_format != MC_SCR_DATA_FORMAT_UNKNOWN)
-            if(!missing_data)
-            {
-                param_type=MC_DATA_API_PARAM_TYPE_FORMATTED;                                    
-            }
-        }
-
-/*        
-        if(param_type == MC_DATA_API_PARAM_TYPE_NONE)
-        {                
-            if(given_entity && given_entity->GetEntityType())
-            {
-                memcpy(entity,given_entity,sizeof(mc_EntityDetails));
-                param_type=MC_DATA_API_PARAM_TYPE_FOLLOWON;                
-            }
-            else
-            {
-                param_type=MC_DATA_API_PARAM_TYPE_ISSUE; 
-            }            
-        }
-*/
-/*        
-        if(param_type == MC_DATA_API_PARAM_TYPE_FOLLOWON)
-        {
-            if(entity->AllowedFollowOns() == 0)
-            {
-                *errorCode=RPC_NOT_ALLOWED;
-                *strError=string("Issuing more units not allowed for this asset");       
-                goto exitlbl;                
-            }
-        }
- */ 
-    }
-    else
-    {
-        if(param->type() == str_type)
-        {
-            if(param->get_str().size())
-            {
-                param_type=MC_DATA_API_PARAM_TYPE_RAW;
-            }
-            else
-            {
-                param_type=MC_DATA_API_PARAM_TYPE_EMPTY_RAW;                
-            }                    
-        }
-        else
-        {
-            *strError="Invalid parameter type, should be object or string";
-            goto exitlbl;
-        }        
-    }
-    
-exitlbl:
-    return param_type;
-}
-
-CScript RawDataScriptRawHex(Value *param,int *errorCode,string *strError)
-{
-    bool fIsHex;
-    CScript scriptOpReturn=CScript();
-    vector<unsigned char> dataData(ParseHex(param->get_str().c_str(),fIsHex));    
-    if(!fIsHex)
-    {
-        *strError="data should be hexadecimal string";
-        if(mc_gState->m_Features->FormattedData())
-        {
-            *strError+=" or recognized object";
-        }
-    }
-    scriptOpReturn << OP_RETURN << dataData;
-    return scriptOpReturn;
-}
-
-vector<unsigned char> ParseRawFormattedData(const Value *value,uint32_t *data_format,mc_Script *lpDetailsScript,uint32_t in_options,uint32_t* out_options,int *errorCode,string *strError)
-{
-    if(out_options)
-    {
-        *out_options=MC_RFD_OPTION_NONE;
-    }
-    vector<unsigned char> vValue;
-    if(value->type() == str_type)
-    {
-        bool fIsHex;
-        vValue=ParseHex(value->get_str().c_str(),fIsHex);    
-        if(!fIsHex)
-        {
-            *strError=string("data should be hexadecimal string");                            
-            if(mc_gState->m_Features->FormattedData())
-            {
-                *strError+=" or recognized object";
-            }
-        }        
-        *data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    }
-    else
-    {
-        if( (in_options & MC_RFD_OPTION_INLINE) || 
-            (mc_gState->m_Features->FormattedData() != 0) || 
-            (mc_gState->m_Features->OffChainData() != 0) )
-        {
-            if(value->type() == obj_type) 
-            {
-                if(value->get_obj().size() != 1)
-                {
-                    *strError=string("data should be object with single element");                                                        
-                }
-                else
-                {
-                    BOOST_FOREACH(const Pair& d, value->get_obj()) 
-                    {
-                        if(d.name_ == "text")
-                        {
-                            if(d.value_.type() == str_type)
-                            {
-                                vValue=vector<unsigned char> (d.value_.get_str().begin(),d.value_.get_str().end());    
-                            }
-                            else
-                            {
-                                *strError=string("value in data object should be string");                            
-                            }
-                            *data_format=MC_SCR_DATA_FORMAT_UTF8;                    
-                        }
-                        if(d.name_ == "json")
-                        {
-                            size_t bytes;
-                            int err;
-                            const unsigned char *script;
-                            lpDetailsScript->Clear();
-                            lpDetailsScript->AddElement();
-                            if((err = ubjson_write(d.value_,lpDetailsScript,MAX_FORMATTED_DATA_DEPTH)) != MC_ERR_NOERROR)
-                            {
-                                *strError=string("Couldn't transfer JSON object to internal UBJSON format");    
-                            }
-                            script = lpDetailsScript->GetData(0,&bytes);
-                            vValue=vector<unsigned char> (script,script+bytes);                                            
-                            *data_format=MC_SCR_DATA_FORMAT_UBJSON;                    
-                        }
-                        if(d.name_ == "cache")
-                        {
-                            if(d.value_.type() == str_type)
-                            {
-                                vValue=vector<unsigned char> (d.value_.get_str().begin(),d.value_.get_str().end());  
-                                vValue.push_back(0);
-                                if(in_options & MC_RFD_OPTION_OFFCHAIN)
-                                {
-                                    if(out_options)
-                                    {
-                                        *out_options |= MC_RFD_OPTION_CACHE;
-                                    }    
-                                }
-                                else
-                                {
-                                    int fHan=mc_BinaryCacheFile((char*)&vValue[0],0);
-                                    if(fHan <= 0)
-                                    {
-                                        *strError="Binary cache item with this identifier not found";
-                                    }
-                                    int64_t total_size=0;
-                                    if(strError->size() == 0)
-                                    {
-                                        total_size=lseek64(fHan,0,SEEK_END);
-                                        if(lseek64(fHan,0,SEEK_SET) != 0)
-                                        {
-                                            *strError="Cannot read binary cache item";
-                                            *errorCode=RPC_INTERNAL_ERROR;
-                                            close(fHan);
-                                        }
-                                    }
-                                    if(strError->size() == 0)
-                                    {
-                                        if(total_size > MAX_OP_RETURN_RELAY)
-                                        {
-                                            *strError="Binary cache item too big";
-                                            *errorCode=RPC_NOT_SUPPORTED;
-                                            close(fHan);                                        
-                                        }
-                                    }
-                                    if(strError->size() == 0)
-                                    {
-                                        if(total_size)
-                                        {
-                                            mc_gState->m_TmpBuffers->m_RpcChunkScript1->Clear();
-                                            mc_gState->m_TmpBuffers->m_RpcChunkScript1->Resize(total_size,1);
-                                            unsigned char* ptr=mc_gState->m_TmpBuffers->m_RpcChunkScript1->m_lpData;
-                                            if(read(fHan,ptr,total_size) != total_size)
-                                            {
-                                                *errorCode=RPC_INTERNAL_ERROR;
-                                                *strError="Cannot read binary cache item";
-                                            }
-                                            close(fHan);
-                                            vValue=vector<unsigned char> (ptr,ptr+total_size);                                              
-                                        }
-                                        else
-                                        {
-                                            vValue.clear();
-                                        }
-                                    }
-                                }
-                            }
-                            else
-                            {
-                                *strError=string("cache identifier in data object should be string");                            
-                            }
-                            *data_format=MC_SCR_DATA_FORMAT_UNKNOWN;                                                
-                        }
-                        else
-                        {    
-                            if(d.name_ == "chunks")
-                            {
-                                if(mc_gState->m_Features->OffChainData())
-                                {
-                                    if(d.value_.type() == array_type)
-                                    {
-                                        Array arr=d.value_.get_array();
-                                        for(int i=0;i<(int)arr.size();i++)
-                                        {
-                                            if(strError->size() == 0)
-                                            {
-                                                if(arr[i].type() == str_type)
-                                                {
-                                                    vector<unsigned char> vHash;
-                                                    bool fIsHex;
-                                                    vHash=ParseHex(arr[i].get_str().c_str(),fIsHex);    
-                                                    if(!fIsHex)
-                                                    {
-                                                        *strError=string("Chunk hash should be hexadecimal string");                            
-                                                    }
-                                                    else
-                                                    {
-                                                        if(vHash.size() != MC_CDB_CHUNK_HASH_SIZE)
-                                                        {
-                                                            *strError=strprintf("Chunk hash should be %d bytes long",MC_CDB_CHUNK_HASH_SIZE);                                                                                    
-                                                        }
-                                                        else
-                                                        {                                                        
-                                                            uint256 hash;
-                                                            hash.SetHex(arr[i].get_str());
-
-                                                            vValue.insert(vValue.end(),(unsigned char*)&hash,(unsigned char*)&hash+MC_CDB_CHUNK_HASH_SIZE);
-                                                        }
-                                                    }                                                
-                                                }                                            
-                                            }
-                                        }
-                                    }
-                                    else
-                                    {
-                                        *strError=string("value in data object should be array");                            
-                                    }
-
-                                    if(out_options)
-                                    {
-                                        *out_options |= MC_RFD_OPTION_OFFCHAIN;
-                                    }    
-                                    *data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-                                }
-                                else
-                                {
-                                    *errorCode=RPC_NOT_SUPPORTED;
-                                    *strError="Unsupported item data type: " + d.name_;
-                                }
-                            }
-                            else
-                            {
-                                if(*data_format == MC_SCR_DATA_FORMAT_UNKNOWN)
-                                {
-                                    throw JSONRPCError(RPC_NOT_SUPPORTED, "Unsupported item data type: " + d.name_);                                    
-                                }                    
-                            }
-                        }
-                    }                
-                }
-            }   
-            else
-            {
-                *strError=string("data should be hexadecimal string or recognized object");                                        
-            }
-        }
-        else
-        {
-            *strError=string("data should be hexadecimal string");                                                    
-            if(mc_gState->m_Features->FormattedData() == 0)
-            {
-                *strError+=" for this protocol version";
-            }
-        }
-    }
-    
-    return vValue;
-}
-
-void ParseRawDetails(const Value *value,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    if(value->type() == obj_type)
-    {
-        size_t bytes;
-        int err;
-        const unsigned char *script;
-        lpDetailsScript->Clear();
-        lpDetailsScript->AddElement();
-        if((err = ubjson_write(*value,lpDetailsScript,MAX_FORMATTED_DATA_DEPTH)) != MC_ERR_NOERROR)
-        {
-            *strError=string("Couldn't transfer details JSON object to internal UBJSON format");    
-        }
-        else
-        {
-            script = lpDetailsScript->GetData(0,&bytes);
-            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_JSON_DETAILS,script,bytes);            
-        }
-
-/*        
-        BOOST_FOREACH(const Pair& p, value->get_obj()) 
-        {              
-            if(p.value_.type() == str_type)
-            {
-                lpDetails->SetParamValue(p.name_.c_str(),p.name_.size(),(unsigned char*)p.value_.get_str().c_str(),p.value_.get_str().size());                
-            }
-            else
-            {
-                *strError=string("Invalid details value, should be string");                                                                            
-            }      
-        }
-*/ 
-    }                
-    else
-    {
-        *strError=string("Invalid details");                                                            
-    }    
-}
-
-CScript RawDataScriptFormatted(Value *param,uint32_t *data_format,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    vector<unsigned char> vValue;
-    size_t bytes;
-    const unsigned char *script;
-    bool field_parsed;
-    bool missing_data=true;
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if( (d.name_ == "text") || (d.name_ == "json")  || (d.name_ == "cache") )      
-        {
-            if(!missing_data)
-            {
-                *strError=string("data object should have single key - json or text");                                                                                                        
-            }
-            vValue=ParseRawFormattedData(param,data_format,lpDetailsScript,MC_RFD_OPTION_NONE,NULL,errorCode,strError);
-            field_parsed=true;
-            missing_data=false;
-        }
-//        if(d.name_ == "format")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());;                                
-        }
-    }    
-    
-    if(missing_data)
-    {
-        *strError=string("Missing json or text field");            
-    }
-
-    if(strError->size() == 0)
-    {
-        lpDetailsScript->Clear();
-        lpDetailsScript->SetDataFormat(*data_format);
-        script = lpDetailsScript->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-
-        scriptOpReturn << OP_RETURN << vValue;                        
-    }
-    
-    return scriptOpReturn;
-}
-
-CScript RawDataScriptIssue(Value *param,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    bool field_parsed;
-    size_t bytes;
-    int err;
-    const unsigned char *script;
-    string entity_name;
-    int multiple=1;
-    int is_open=0;
-    uint32_t permissions=0;
-    bool missing_name=true;
-    bool missing_multiple=true;
-    bool missing_open=true;
-    bool missing_details=true;
-    
-    lpDetails->Clear();
-    lpDetails->AddElement();                   
-    
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "name")
-        {
-            if(!missing_name)
-            {
-                *strError=string("name field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() != null_type && !d.value_.get_str().empty())
-            {
-                entity_name=d.value_.get_str();
-                                
-                if(entity_name == "*")
-                {
-                    *strError=string("Invalid asset name"); 
-                }
-                
-                if(entity_name.size())
-                {
-                    if(entity_name.size() > MC_ENT_MAX_NAME_SIZE)
-                    {
-                        *strError=string("Invalid asset name - too long"); 
-                    }
-                    lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());
-                }
-            }
-            else
-            {
-                *strError=string("Invalid name");                            
-            }
-            missing_name=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "multiple")
-        {
-            if(!missing_multiple)
-            {
-                *strError=string("multiple field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() == int_type)
-            {
-                multiple=d.value_.get_int();
-                if(multiple <= 0)
-                {
-                    *strError=string("Invalid multiple - should be positive");                                                                                                        
-                }
-                else
-                {
-                    lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
-                }
-            }
-            else
-            {
-                *strError=string("Invalid multiple");                            
-            }
-            missing_multiple=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "open")
-        {
-            if(!missing_open)
-            {
-                *strError=string("open field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() == bool_type)
-            {
-                is_open=d.value_.get_bool();
-            }    
-            else
-            {
-                *strError=string("Invalid open");                                            
-            }
-            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_FOLLOW_ONS,(unsigned char*)&is_open,1);                
-            missing_open=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "restrict")
-        {
-            if(mc_gState->m_Features->PerAssetPermissions() == 0)
-            {
-                throw JSONRPCError(RPC_NOT_SUPPORTED, "Per-asset permissions not supported for this protocol version");   
-            }
-            if(permissions == 0)
-            {
-                if(d.value_.type() == str_type)
-                {
-                    permissions=mc_gState->m_Permissions->GetPermissionType(d.value_.get_str().c_str(),MC_PTP_SEND | MC_PTP_RECEIVE);
-                    if(permissions == 0)
-                    {
-                        *strError=string("Invalid restrict");                                                                
-                    }
-                }
-                else
-                {
-                    *strError=string("Invalid restrict");                                                                
-                }
-            }
-            else
-            {
-                *strError=string("restrict field can appear only once in the object");                                                                                                                        
-            }
-            if(permissions)
-            {
-                lpDetails->SetSpecialParamValue(MC_ENT_SPRM_PERMISSIONS,(unsigned char*)&permissions,1);                                
-            }
-            field_parsed=true;
-        }
-        
-        if(d.name_ == "details")
-        {
-            if(!missing_details)
-            {
-                *strError=string("details field can appear only once in the object");                                                                                                        
-            }
-            ParseRawDetails(&(d.value_),lpDetails,lpDetailsScript,errorCode,strError);
-            missing_details=false;
-            field_parsed=true;
-        }            
-        if(d.name_ == "create")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());
-        }
-    }    
-    
-    if(strError->size() == 0)
-    {
-        lpDetailsScript->Clear();
-        script=lpDetails->GetData(0,&bytes);
-        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,0,script,bytes);
-        if(err)
-        {
-            *strError=string("Invalid custom fields, too long");                                                            
-        }
-        else
-        {
-            script = lpDetailsScript->GetData(0,&bytes);
-            scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
-        }
-    }
-    
-    return scriptOpReturn;
-}
-
-CScript RawDataScriptFollowOn(Value *param,mc_EntityDetails *entity,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    size_t bytes;
-    int err;
-    const unsigned char *script;
-    bool field_parsed;
-    bool missing_details=true;
-    
-    lpDetails->Clear();
-    lpDetails->AddElement();                   
-    
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "details")
-        {
-            if(!missing_details)
-            {
-                *strError=string("details field can appear only once in the object");                                                                                                        
-            }
-            ParseRawDetails(&(d.value_),lpDetails,lpDetailsScript,errorCode,strError);
-            missing_details=false;
-            field_parsed=true;
-        }            
-        if(d.name_ == "update")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());;                                
-        }
-    }    
-    
-    lpDetailsScript->Clear();
-    lpDetailsScript->SetEntity(entity->GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-    script = lpDetailsScript->GetData(0,&bytes);
-    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
-
-    lpDetailsScript->Clear();
-    script=lpDetails->GetData(0,&bytes);
-    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,1,script,bytes);
-    if(err)
-    {
-        *strError=string("Invalid custom fields, too long");                                                            
-    }
-    else
-    {
-        script = lpDetailsScript->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
-    }
-    
-    return scriptOpReturn;
-}
-
-bool RawDataParseRestrictParameter(const Value& param,uint32_t *restrict,uint32_t *permissions,string *strError)
-{
-    *restrict=0;
-    *permissions=0;
- 
-    uint32_t match;
-    char* ptr;
-    char* start;
-    char* ptrEnd;
-    char c;
-    
-    if(param.type() != str_type)
-    {
-        *strError="Invalid restrict field, should be string";
-        return false;
-    }
-    
-    ptr=(char*)param.get_str().c_str();
-    ptrEnd=ptr+strlen(ptr);
-    start=ptr;
-    
-    while(ptr<=ptrEnd)
-    {
-        c=*ptr;
-        if( (c == ',') || (c ==0x00))
-        {
-            if(ptr > start)
-            {
-                match=0;
-                if(( (ptr-start) ==  5) && (memcmp(start,"write",    ptr-start) == 0) ){match = 1; *permissions |= MC_PTP_WRITE ;}
-                if(( (ptr-start) ==  7) && (memcmp(start,"onchain",  ptr-start) == 0) ){match = 1; *restrict |= MC_ENT_ENTITY_RESTRICTION_ONCHAIN;}
-                if(( (ptr-start) ==  8) && (memcmp(start,"offchain", ptr-start) == 0) ){match = 1; *restrict |= MC_ENT_ENTITY_RESTRICTION_OFFCHAIN;}
-                
-                if(match == 0)
-                {
-                    *strError="Unsupported restriction";
-                    return false;
-                }
-                start=ptr+1;
-            }
-        }
-        ptr++;
-    }
-    
-    return true;    
-}
-
-CScript RawDataScriptCreateStream(Value *param,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    bool field_parsed;
-    size_t bytes;
-    int err;
-    const unsigned char *script;
-    string entity_name;
-    int is_open=0;
-    uint32_t restrict;
-    uint32_t permissions=MC_PTP_WRITE;
-    
-    bool missing_name=true;
-    bool missing_open=true;
-    bool missing_details=true;
-    
-    lpDetails->Clear();
-    lpDetails->AddElement();                   
-       
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "name")
-        {
-            if(!missing_name)
-            {
-                *strError=string("open field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() != null_type && !d.value_.get_str().empty())
-            {
-                entity_name=d.value_.get_str();
-                if(entity_name.size())
-                {
-                    if(entity_name.size() > MC_ENT_MAX_NAME_SIZE)
-                    {
-                        *strError=string("Invalid stream name - too long"); 
-                    }
-                    lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());
-                }
-            }
-            else
-            {
-                *strError=string("Invalid name");                            
-            }
-            missing_name=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "open")
-        {
-            if(!missing_open)
-            {
-                *strError=string("open/restrict field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() == bool_type)
-            {
-                is_open=d.value_.get_bool();
-            }    
-            else
-            {
-                *strError=string("Invalid open");                                            
-            }
-            if(mc_gState->m_Features->OffChainData() == 0)
-            {
-                lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ANYONE_CAN_WRITE,(unsigned char*)&is_open,1); 
-            }
-            else
-            {
-                permissions=is_open ? MC_PTP_NONE : MC_PTP_WRITE;
-            }
-            missing_open=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "restrict")
-        {
-            if(mc_gState->m_Features->OffChainData() == 0)
-            {
-                *strError=string("Per-stream restrictions not supported for this protocol version");               
-                *errorCode=RPC_NOT_SUPPORTED;
-            }
-            else
-            {                
-                if(!missing_open)
-                {
-                    *strError=string("open/restrict field can appear only once in the object");                                                                                                        
-                }
-                if(RawDataParseRestrictParameter(d.value_,&restrict,&permissions,strError))
-                {
-                    if(restrict & MC_ENT_ENTITY_RESTRICTION_OFFCHAIN)
-                    {
-                        if(restrict & MC_ENT_ENTITY_RESTRICTION_ONCHAIN)
-                        {
-                            *strError=string("Stream cannot be restricted from both onchain and offchain items");               
-                            *errorCode=RPC_NOT_SUPPORTED;                            
-                        }                        
-                    }
-                    if(restrict)
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_RESTRICTIONS,(unsigned char*)&restrict,1);                         
-                    }
-                }
-                missing_open=false;
-                field_parsed=true;
-            }
-        }
-        if(d.name_ == "details")
-        {
-            if(!missing_details)
-            {
-                *strError=string("details field can appear only once in the object");                                                                                                        
-            }
-            ParseRawDetails(&(d.value_),lpDetails,lpDetailsScript,errorCode,strError);
-            missing_details=false;
-            field_parsed=true;
-        }            
-        if(d.name_ == "create")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());
-        }
-    }    
-    
-    if(mc_gState->m_Features->OffChainData())
-    {
-        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_PERMISSIONS,(unsigned char*)&permissions,1);                                
-    }
-    
-    if(strError->size() == 0)
-    {
-        lpDetailsScript->Clear();
-        script=lpDetails->GetData(0,&bytes);
-        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
-        if(err)
-        {
-            *strError=string("Invalid custom fields, too long");                                                            
-        }
-        else
-        {
-            script = lpDetailsScript->GetData(0,&bytes);
-            scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
-        }
-    }
-    
-    return scriptOpReturn;
-}
-
-bool AddParamNameValueToScript(const string  param_name,const Value param_value,mc_Script *lpDetailsScript,int version,int *errorCode,string *strError)
-{
-    
-    int64_t value;
-    string name=param_name;   
-    name.erase(std::remove(name.begin(), name.end(), '-'), name.end());
-    const mc_OneMultichainParam *param=mc_gState->m_NetworkParams->FindParam(name.c_str());
-            
-    if(param == NULL)
-    {
-        *errorCode=RPC_INVALID_PARAMETER;
-        *strError=string("Invalid parameter name"); 
-        return false;                    
-    }        
-    
-    int size;
-    unsigned char zero=0;
-    switch(param->m_Type & MC_PRM_DATA_TYPE_MASK)
-    {
-        case MC_PRM_BOOLEAN:
-            if(param_value.type() == bool_type)
-            {
-                value=param_value.get_bool() ? 1 : 0;
-            }
-            else
-            {
-                *errorCode=RPC_INVALID_PARAMETER;
-                *strError=string("Invalid parameter type, should be boolean");     
-                return false;            
-            }                
-            break;
-        case MC_PRM_INT32:
-        case MC_PRM_INT64:
-        case MC_PRM_UINT32:
-            if(param->m_Type & MC_PRM_DECIMAL)            
-            {
-                if(param_value.type() == real_type)
-                {
-                    value=mc_gState->m_NetworkParams->DecimalToInt64(param_value.get_real());
-                }                
-                else
-                {
-                    *errorCode=RPC_INVALID_PARAMETER;
-                    *strError=string("Invalid parameter type, should be numeric");     
-                    return false;                            
-                }
-            }
-            else
-            {
-                if(param_value.type() == int_type)
-                {
-                    value=param_value.get_int64();
-                }
-                else
-                {
-                    *errorCode=RPC_INVALID_PARAMETER;
-                    *strError=string("Invalid parameter type, should be integer");     
-                    return false;                            
-                }
-            }
-            break;    
-        default:
-            *errorCode=RPC_NOT_SUPPORTED;
-            *strError=string("One of parameters cannot be upgraded by this protocol version"); 
-            return false;                            
-    }
-        
-    size=mc_gState->m_NetworkParams->CanBeUpgradedByVersion(name.c_str(),version,0);
-    
-    if(size < 0)
-    {
-        *errorCode=RPC_INVALID_PARAMETER;
-        *strError=string("Invalid parameter name"); 
-        return false;        
-    }
-    
-    if(size == 0)
-    {
-        *errorCode=RPC_NOT_SUPPORTED;
-        *strError=string("One of parameters cannot be upgraded by this protocol version"); 
-        return false;                
-    }
-    
-    lpDetailsScript->SetData((unsigned char*)name.c_str(),name.size());
-    lpDetailsScript->SetData((unsigned char*)&zero,1);
-    lpDetailsScript->SetData((unsigned char*)&size,MC_PRM_PARAM_SIZE_BYTES);
-    lpDetailsScript->SetData((unsigned char*)&value,size);
-    
-    return true;
-}
-
-
-CScript RawDataScriptCreateUpgrade(Value *param,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    bool field_parsed;
-    size_t bytes;
-    const unsigned char *script;
-    string entity_name;
-    int protocol_version;
-    uint32_t startblock;
-
-    bool missing_name=true;
-    bool missing_startblock=true;
-    bool missing_details=true;
-    
-    lpDetails->Clear();
-    lpDetails->AddElement();                   
-
-    lpDetailsScript->Clear();
-    lpDetailsScript->AddElement();                   
-    
-    protocol_version=-1;
-    
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "name")
-        {
-            if(!missing_name)
-            {
-                *strError=string("open field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() != null_type && !d.value_.get_str().empty())
-            {
-                entity_name=d.value_.get_str();
-                if(entity_name.size())
-                {
-                    if(entity_name.size() > MC_ENT_MAX_NAME_SIZE)
-                    {
-                        *strError=string("Invalid upgrade name - too long"); 
-                    }
-                    lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());
-                }
-            }
-            else
-            {
-                *strError=string("Invalid name");                            
-            }
-            missing_name=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "startblock")
-        {
-            if(!missing_startblock)
-            {
-                *strError=string("open field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() == int_type)
-            {
-                if( (d.value_.get_int64() >= 0) && (d.value_.get_int64() <= 0xFFFFFFFF) )
-                {
-                    startblock=(uint32_t)(d.value_.get_int64());
-                    if(startblock > 0)
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_START_BLOCK,(unsigned char*)&startblock,4);        
-                    }                    
-                }
-                else
-                {
-                    *strError=string("Invalid startblock");                                                    
-                }
-            }
-            else
-            {
-                *strError=string("Invalid startblock");                            
-            }
-            missing_startblock=false;
-            field_parsed=true;
-        }
-        if(d.name_ == "details")
-        {
-            if(!missing_details)
-            {                    
-                *strError=string("details field can appear only once in the object");                                                                                                                        
-            }
-            if(d.value_.type() == obj_type)
-            {
-                protocol_version=-1;
-                BOOST_FOREACH(const Pair& p, d.value_.get_obj()) 
-                {              
-                    if(p.name_ == "protocol-version")
-                    {
-                        if( (p.value_.type() == int_type) && (p.value_.get_int() > 0) )
-                        {
-                            if(protocol_version < 0)
-                            {
-                                protocol_version=p.value_.get_int();
-                            }
-                        }                            
-                        else
-                        {
-                            *strError=string("Invalid protocol-version");                                                                                                            
-                        }
-                    }
-                    else
-                    {
-                        if(mc_gState->m_Features->ParameterUpgrades())
-                        {                        
-                            AddParamNameValueToScript(p.name_,p.value_,lpDetailsScript,0,errorCode,strError);
-                        }
-                        else
-                        {
-                            *strError=string("Invalid details");     
-                        }
-                    }
-                }
-                
-                script = lpDetailsScript->GetData(0,&bytes);
-                if(strError->size() == 0)
-                {                    
-                    if( (protocol_version <= 0) && (bytes == 0) )
-                    {
-                        *strError=string("Missing protocol-version");                                                                                                            
-                    }
-                }
-                                
-                if(strError->size() == 0)
-                {
-                    if(protocol_version > 0)
-                    {                    
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,(unsigned char*)&protocol_version,4);                                
-                    }
-                    if(bytes)
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_CHAIN_PARAMS,script,bytes);                                                        
-                    }
-                }
-            }             
-            missing_details=false;
-            field_parsed=true;
-        }            
-        if(d.name_ == "create")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());
-        }
-    }    
-    
-    if(strError->size() == 0)
-    {
-        if(missing_details)
-        {                    
-            *strError=string("Missing details");                                                                                            
-        }
-    }
-    
-    if(strError->size() == 0)
-    {
-        int err;
-        script=lpDetails->GetData(0,&bytes);
-        lpDetailsScript->Clear();
-        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_UPGRADE,0,script,bytes);
-        if(err)
-        {
-            *strError=string("Invalid custom fields, too long");                                                            
-        }
-        else
-        {
-            script = lpDetailsScript->GetData(0,&bytes);
-            scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
-        }        
-    }
-    
-    return scriptOpReturn;
-}
-
-
-CScript RawDataScriptPublish(Value *param,mc_EntityDetails *entity,uint32_t *data_format,mc_Script *lpDetailsScript,vector<uint256>* vChunkHashes,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    vector<unsigned char> vValue;
-    vector<unsigned char> vKey;
-    Array vKeys; 
-    size_t bytes;
-    const unsigned char *script;
-    bool field_parsed;
-    bool missing_data=true;
-    bool missing_key=true;
-    uint32_t in_options,out_options;
-    in_options=MC_RFD_OPTION_NONE;
-    out_options=MC_RFD_OPTION_NONE;
-    vKeys.clear();
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        if(d.name_ == "options")
-        {
-            if( mc_gState->m_Features->OffChainData() == 0 )
-            {
-                *errorCode=RPC_NOT_SUPPORTED;
-                *strError=string("Format options are not supported by this protocol version");       
-                goto exitlbl;
-            }
-            if(d.value_.type() != null_type && (d.value_.type()==str_type))
-            {
-                if(d.value_.get_str() == "offchain")
-                {
-                    in_options |= MC_RFD_OPTION_OFFCHAIN;
-                }
-                else
-                {
-                    if(d.value_.get_str().size())
-                    {
-                        *strError=string("Stream item options must be offchain or empty");                                                
-                    }
-                }
-            }
-            else
-            {
-                *strError=string("Stream item options must be offchain or empty");                            
-            }
-            field_parsed=true;
-        }                
-    }
-    
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "key")
-        {
-            if(!missing_key)
-            {
-                *strError=string("only one of the key fields can appear in the object");                                                                                                        
-            }
-            if(d.value_.type() != null_type && (d.value_.type()==str_type))
-            {
-                vKeys.push_back(d.value_);
-            }
-            else
-            {
-                *strError=string("Invalid key");                            
-            }
-            field_parsed=true;
-            missing_key=false;
-        }
-        if(d.name_ == "keys")
-        {
-            if( mc_gState->m_Features->MultipleStreamKeys() == 0 )
-            {
-                *errorCode=RPC_NOT_SUPPORTED;
-                *strError=string("Multiple keys are not supported by this protocol version");       
-                goto exitlbl;
-            }
-            if(!missing_key)
-            {
-                *strError=string("only one of the key fields can appear in the object");                                                                                                        
-            }
-            if(d.value_.type() == array_type)
-            {
-                vKeys=d.value_.get_array();
-                if(vKeys.size() == 0)
-                {
-                    *strError=string("Invalid keys - should be non-empty array");                                                
-                }
-            }            
-            else
-            {
-                *strError=string("Invalid keys - should be array");                            
-            }
-            field_parsed=true;
-            missing_key=false;
-        }
-        if(d.name_ == "data")        
-        {
-            if(!missing_data)
-            {
-                *strError=string("data field can appear only once in the object");                                                                                                        
-            }
-            vValue=ParseRawFormattedData(&(d.value_),data_format,lpDetailsScript,in_options,&out_options,errorCode,strError);
-            field_parsed=true;
-            missing_data=false;
-        }
-        if(d.name_ == "options")
-        {
-            field_parsed=true;
-        }        
-        if(d.name_ == "for")field_parsed=true;
-//        if(d.name_ == "format")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());;                                
-        }
-    }    
-    
-    if(missing_data)
-    {
-        *strError=string("Missing data field");            
-    }
-    if(missing_key)
-    {
-        *strError=string("Missing key field");        
-        if(mc_gState->m_Features->MultipleStreamKeys())
-        {
-            *strError=string("Missing keys field");                    
-        }
-    }
-
-    if(strError->size() == 0)
-    {
-        lpDetailsScript->Clear();
-        lpDetailsScript->SetEntity(entity->GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-        script = lpDetailsScript->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
-        
-        for(int i=0;i<(int)vKeys.size();i++)
-        {
-            lpDetailsScript->Clear();
-            if(vKeys[i].type() != null_type && (vKeys[i].type()==str_type))
-            {
-                vKey=vector<unsigned char>(vKeys[i].get_str().begin(), vKeys[i].get_str().end());    
-                if(vKey.size() > MC_ENT_MAX_ITEM_KEY_SIZE)
-                {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Item key is too long");                                                                                                    
-                    goto exitlbl;
-                }        
-            }
-            else
-            {
-                *strError=string("key should be string");                                            
-                goto exitlbl;
-            }
-        
-            if(lpDetailsScript->SetItemKey(&vKey[0],vKey.size()) == MC_ERR_NOERROR)
-            {
-                script = lpDetailsScript->GetData(0,&bytes);
-                scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
-            }
-        }
-
-        if(in_options & MC_RFD_OPTION_OFFCHAIN)
-        {
-            AppendOffChainFormatData(*data_format,out_options,lpDetailsScript,vValue,vChunkHashes,errorCode,strError);
-            if(strError->size())
-            {
-                goto exitlbl;                                
-            }
-            script = lpDetailsScript->GetData(0,&bytes);
-            scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-            scriptOpReturn << OP_RETURN;                                        
-        }
-        else
-        {
-            if(out_options & MC_RFD_OPTION_OFFCHAIN)
-            {
-                *strError=string("chunks data type is not allowed with missing options field");                                            
-                goto exitlbl;                
-            }
-            if(*data_format != MC_SCR_DATA_FORMAT_UNKNOWN)
-            {
-                lpDetailsScript->Clear();
-                lpDetailsScript->SetDataFormat(*data_format);
-                script = lpDetailsScript->GetData(0,&bytes);
-                scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-            }
-
-            if(vValue.size())
-            {
-                scriptOpReturn << OP_RETURN << vValue;                            
-            }
-            else
-            {
-                scriptOpReturn << OP_RETURN;                                        
-            }
-        }
-    }
-    
-exitlbl:
-            
-    return scriptOpReturn;
-}
-
-CScript RawDataScriptApprove(Value *param,mc_EntityDetails *entity,mc_Script *lpDetailsScript,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    vector<unsigned char> vValue;
-    vector<unsigned char> vKey;
-    size_t bytes;
-    const unsigned char *script;
-    bool field_parsed;
-    int is_approve=true;
-    bool missing_approve=true;
-    
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "approve")
-        {
-            if(!missing_approve)
-            {
-                *strError=string("approve field can appear only once in the object");                                                                                                        
-            }
-            if(d.value_.type() == bool_type)
-            {
-                is_approve=d.value_.get_bool();
-            }    
-            else
-            {
-                *strError=string("Invalid approve");                                            
-            }
-            field_parsed=true;
-            missing_approve=false;
-        }
-        if(d.name_ == "for")field_parsed=true;
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());;                                
-        }
-    }    
-    
-    if(missing_approve)
-    {
-        *strError=string("Missing approve field");            
-    }
-
-    if(strError->size() == 0)
-    {
-        lpDetailsScript->Clear();
-        lpDetailsScript->SetEntity(entity->GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-        script = lpDetailsScript->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-
-        lpDetailsScript->Clear();
-        lpDetailsScript->SetApproval(is_approve, mc_TimeNowAsUInt());
-        script = lpDetailsScript->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-
-        scriptOpReturn << OP_RETURN;                    
-    }
-    
-    return scriptOpReturn;
-}
-
-
-CScript RawDataScriptInputCache(Value *param,mc_Script *lpDetails,int *errorCode,string *strError)
-{
-    CScript scriptOpReturn=CScript();
-    size_t bytes;
-    const unsigned char *script;
-    bool field_parsed;
-    BOOST_FOREACH(const Pair& d, param->get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "inputcache")
-        {
-            if(d.value_.type() != array_type)
-            {
-                *strError=string("Array should be specified for inputcache");                                                
-            }
-            else
-            {
-                int cs_offset,cs_vin,cs_size;
-                string cs_script="";
-                Array csa=d.value_.get_array();
-                lpDetails->Clear();
-                lpDetails->SetCachedScript(0,&cs_offset,-1,NULL,-1);
-                for(int csi=0;csi<(int)csa.size();csi++)
-                {
-                    if(strError->size() == 0)
-                    {
-                        if(csa[csi].type() != obj_type)
-                        {
-                            *strError=string("Elements of inputcache should be objects");                                                
-                        }
-                        cs_vin=-1;
-                        cs_size=-1;
-                        BOOST_FOREACH(const Pair& csf, csa[csi].get_obj())                                 
-                        {              
-                            bool cs_parsed=false;
-                            if(csf.name_ == "vin")
-                            {
-                                cs_parsed=true;
-                                if(csf.value_.type() != int_type)
-                                {
-                                    *strError=string("vin should be integer");                                                                                            
-                                }
-                                else
-                                {
-                                    cs_vin=csf.value_.get_int();
-                                } 
-                            }
-                            if(csf.name_ == "scriptPubKey")
-                            {
-                                cs_parsed=true;
-                                if(csf.value_.type() != str_type)
-                                {
-                                    *strError=string("scriptPubKey should be string");                                                                                            
-                                }
-                                else
-                                {
-                                    cs_script=csf.value_.get_str();
-                                    cs_size=cs_script.size()/2;
-                                } 
-                            }
-                            if(!cs_parsed)
-                            {
-                                *strError=string("Invalid field: ") + csf.name_;                                                                                    
-                            }
-                        }
-                        if(strError->size() == 0)
-                        {
-                            if(cs_vin<0)
-                            {
-                                *strError=string("Missing vin field");                                                                                                                            
-                            }
-                        }
-                        if(strError->size() == 0)
-                        {
-                            if(cs_size<0)
-                            {
-                                *strError=string("Missing scriptPubKey field");                                                                                                                            
-                            }
-                        }                                
-                        if(strError->size() == 0)
-                        {
-                            bool fIsHex;
-                            vector<unsigned char> dataData(ParseHex(cs_script.c_str(),fIsHex));    
-                            if(!fIsHex)
-                            {
-                                *strError=string("scriptPubKey should be hexadecimal string");                                                                                                                            
-                            }                                    
-                            else
-                            {
-                                lpDetails->SetCachedScript(cs_offset,&cs_offset,cs_vin,&dataData[0],cs_size);                                        
-                            }
-                        }
-                    }
-                }
-            }
-            field_parsed=true;
-        }
-        
-        if(!field_parsed)
-        {
-            *strError=strprintf("Invalid field: %s",d.name_.c_str());;                                
-        }        
-    }    
-    
-    if(strError->size() == 0)
-    {
-        script=lpDetails->GetData(0,&bytes);
-        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;        
-    }
-    
-    return scriptOpReturn;
-}
-
-CScript ParseRawMetadata(Value param,uint32_t allowed_objects,mc_EntityDetails *given_entity,mc_EntityDetails *found_entity)
-{
-    vector<uint256> vChunkHashes;
-    string strError="";
-    int errorCode=RPC_INVALID_PARAMETER;
-    uint32_t data_format;
-    mc_EntityDetails entity;
-    CScript scriptOpReturn=CScript();
-    mc_Script *lpDetailsScript=mc_gState->m_TmpBuffers->m_RpcScript1;
-    lpDetailsScript->Clear();
-    mc_Script *lpDetails=mc_gState->m_TmpBuffers->m_RpcScript2;
-    lpDetails->Clear();
-    uint32_t param_type=ParseRawDataParamType(&param,given_entity,&entity,&data_format,&errorCode,&strError);
-
-    if(strError.size())
-    {
-        goto exitlbl;
-    }
-    
-    if(param_type == MC_DATA_API_PARAM_TYPE_NONE)
-    {                
-        strError=string("Unrecognized parameter format");       
-        goto exitlbl;                
-    }
-    
-    if( (param_type & allowed_objects) == 0 )
-    {
-        if(param_type != MC_DATA_API_PARAM_TYPE_EMPTY_RAW)
-        {
-            strError=string("Keyword not allowed in this API");       
-        }
-        goto exitlbl;        
-    }
-    
-    if(found_entity)
-    {
-        memcpy(found_entity,&entity,sizeof(mc_EntityDetails));
-    }                        
-    
-    switch(param_type)
-    {
-        case MC_DATA_API_PARAM_TYPE_EMPTY_RAW:
-        case MC_DATA_API_PARAM_TYPE_RAW:
-            scriptOpReturn=RawDataScriptRawHex(&param,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_FORMATTED:
-            scriptOpReturn=RawDataScriptFormatted(&param,&data_format,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_ISSUE:
-            scriptOpReturn=RawDataScriptIssue(&param,lpDetails,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_FOLLOWON:
-            scriptOpReturn=RawDataScriptFollowOn(&param,&entity,lpDetails,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_CREATE_STREAM:
-            scriptOpReturn=RawDataScriptCreateStream(&param,lpDetails,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_PUBLISH:
-            scriptOpReturn=RawDataScriptPublish(&param,&entity,&data_format,lpDetailsScript,&vChunkHashes,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_CREATE_UPGRADE:
-            scriptOpReturn=RawDataScriptCreateUpgrade(&param,lpDetails,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_APPROVAL:
-            scriptOpReturn=RawDataScriptApprove(&param,&entity,lpDetailsScript,&errorCode,&strError);
-            break;
-        case MC_DATA_API_PARAM_TYPE_CIS:
-            scriptOpReturn=RawDataScriptInputCache(&param,lpDetailsScript,&errorCode,&strError);
-            break;
-    }
-    
-exitlbl:
-    
-    if(strError.size())
-    {
-        throw JSONRPCError(errorCode, strError);            
-    }
-
-    return scriptOpReturn;
-}
diff --git a/src/rpc/rpcrawtransaction.cpp b/src/rpc/rpcrawtransaction.cpp
index 6952545..006f6ef 100644
--- a/src/rpc/rpcrawtransaction.cpp
+++ b/src/rpc/rpcrawtransaction.cpp
@@ -41,6 +41,7 @@ using namespace std;
 
 bool OutputCanSend(COutput out);
 uint32_t mc_CheckSigScriptForMutableTx(const unsigned char *src,int size);
+Value mc_ExtractDetailsJSONObject(const unsigned char *script,uint32_t total);
 
 /* MCHN END */
 
@@ -117,20 +118,13 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
     unsigned char details_script[MC_ENT_MAX_SCRIPT_SIZE];
     unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
     char asset_name[MC_ENT_MAX_NAME_SIZE+1];
-    int multiple=1;
+    int multiple;
     int details_script_size=0;
     int err;
     bool detals_script_found=false;
     uint32_t new_entity_type;
     new_entity_type=MC_ENT_TYPE_NONE;
     set<uint256> streams_already_seen;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status;
-    Array aFormatMetaData;
-    Array aFullFormatMetaData;
     
     Array vout;
     for (unsigned int i = 0; i < tx.vout.size(); i++) {
@@ -144,9 +138,6 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
         
 /* MCHN START */    
 // TODO too many duplicate code with ListWalletTransactions and may be AccepMultiChainTransaction
-        
-        aFormatMetaData.clear();
-        
         const CScript& script1 = tx.vout[i].scriptPubKey;        
         CScript::const_iterator pc1 = script1.begin();
         
@@ -161,54 +152,68 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
         
         if(lpScript->IsOpReturnScript())
         {
-//            lpScript->ExtractAndDeleteDataFormat(&format);
-            lpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-            
-            lpScript->SetElement(0);
-            err=lpScript->GetNewEntityType(&new_entity_type,&asset_update,details_script,&details_script_size);                
-            if((err == 0) && (new_entity_type == MC_ENT_TYPE_ASSET))
+//            int e=mc_gState->m_TmpScript->GetNumElements()-1;
+            int e=lpScript->GetNumElements()-1;
             {
-                if(asset_update == 0)
+                if(mc_gState->m_Features->OpDropDetailsScripts())
                 {
-                    detals_script_found=true;
-                    is_issuefirst=true;
-                    *asset_name=0x00;
-                    multiple=1;
-                    value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_NAME,&value_size);
-                    if(value_offset<(uint32_t)details_script_size)
+                    lpScript->SetElement(0);
+                    err=lpScript->GetNewEntityType(&new_entity_type,&asset_update,details_script,&details_script_size);                
+                    if((err == 0) && (new_entity_type == MC_ENT_TYPE_ASSET))
                     {
-                        if(value_size > MC_ENT_MAX_NAME_SIZE)
+                        if(asset_update == 0)
                         {
-                            value_size=MC_ENT_MAX_NAME_SIZE; 
+                            detals_script_found=true;
+                            is_issuefirst=true;
+                            *asset_name=0x00;
+                            multiple=1;
+                            value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_NAME,&value_size);
+                            if(value_offset<(uint32_t)details_script_size)
+                            {
+                                if(value_size > MC_ENT_MAX_NAME_SIZE)
+                                {
+                                    value_size=MC_ENT_MAX_NAME_SIZE; 
+                                }
+                                memcpy(asset_name,details_script+value_offset,value_size);
+                                asset_name[value_size]=0x00;
+                            }
+                            value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size);
+                            if(value_offset<(uint32_t)details_script_size)
+                            {
+                                multiple=mc_GetLE(details_script+value_offset,value_size);
+                            }                            
                         }
-                        memcpy(asset_name,details_script+value_offset,value_size);
-                        asset_name[value_size]=0x00;
-                    }
-                    value_offset=mc_FindSpecialParamInDetailsScript(details_script,details_script_size,MC_ENT_SPRM_ASSET_MULTIPLE,&value_size);
-                    if(value_offset<(uint32_t)details_script_size)
-                    {
-                        multiple=mc_GetLE(details_script+value_offset,value_size);
                     }                            
+                    else
+                    {
+                        err=lpScript->GetEntity(short_txid);                
+                        if(err == 0)
+                        {
+                            lpScript->SetElement(1);
+                            err=lpScript->GetNewEntityType(&new_entity_type,&asset_update,details_script,&details_script_size);                
+                            if((err == 0) && (new_entity_type == MC_ENT_TYPE_ASSET))
+                            {
+                                if(asset_update)
+                                {
+                                    detals_script_found=true;
+                                    is_issuemore=true;
+                                }
+                            }                                                        
+                        }                        
+                    }
                 }
-            }                            
-            else
-            {
-                err=lpScript->GetEntity(short_txid);                
-                if(err == 0)
+                else
                 {
-                    lpScript->SetElement(1);
-                    err=lpScript->GetNewEntityType(&new_entity_type,&asset_update,details_script,&details_script_size);                
-                    if((err == 0) && (new_entity_type == MC_ENT_TYPE_ASSET))
+                    lpScript->SetElement(e);
+                    err=lpScript->GetAssetDetails(asset_name,&multiple,details_script,&details_script_size);
+                    if(err == 0)
                     {
-                        if(asset_update)
-                        {
-                            detals_script_found=true;
-                            is_issuemore=true;
-                        }
-                    }                                                        
-                }                        
+                        detals_script_found=true;
+                    }                
+                }
             }
             
+            size_t elem_size;
             const unsigned char *elem;
             int cs_err,cs_offset,cs_new_offset,cs_size,cs_vin;
             unsigned char *cs_script;
@@ -217,28 +222,18 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
             {
                 if(lpScript->GetNumElements()==1)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-//                    vdata.push_back(OpReturnEntry(elem,elem_size,tx.GetHash(),i));
-                    aFormatMetaData.push_back(OpReturnFormatEntry(elem,out_size,tx.GetHash(),i,format,NULL,retrieve_status | MC_OST_CONTROL_NO_DATA));
-                    if(mc_gState->m_Compatibility & MC_VCM_1_0)
-                    {
-                        aFullFormatMetaData.push_back(aFormatMetaData[0]);
-                    }
+                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                    vdata.push_back(OpReturnEntry(elem,elem_size,tx.GetHash(),i));
                 }                        
             }
             else
             {
-                if(mc_gState->m_Compatibility & MC_VCM_1_0)
+                elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                if(elem_size)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-                    if(out_size)
-                    {
-//                        vdata.push_back(OpReturnEntry(elem,elem_size,tx.GetHash(),i));
-                        aFullFormatMetaData.push_back(OpReturnFormatEntry(elem,out_size,tx.GetHash(),i,format,NULL,retrieve_status | MC_OST_CONTROL_NO_DATA));
-                    }
+                    vdata.push_back(OpReturnEntry(elem,elem_size,tx.GetHash(),i));
                 }
+                
                 lpScript->SetElement(0);
                 if(lpScript->GetNewEntityType(&new_entity_type))
                 {
@@ -337,36 +332,18 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
                 }
             }
             
-            if( (assets.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-            {
-                out.push_back(Pair("assets", assets));
-            }
+            out.push_back(Pair("assets", assets));
         }        
         Array permissions=PermissionEntries(txout,lpScript,false);
-        if( (permissions.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-        {
-            out.push_back(Pair("permissions", permissions));
-        }
-        Array peroutputdata=PerOutputDataEntries(txout,lpScript,tx.GetHash(),i);
-        if(peroutputdata.size())
-        {
-            out.push_back(Pair("data", peroutputdata));
-        }
+        out.push_back(Pair("permissions", permissions));
         
         Array items;
-        Value data_item_entry=DataItemEntry(tx,i,streams_already_seen, 0x0103);
+        Value data_item_entry=DataItemEntry(tx,i,streams_already_seen, 0x03);
         if(!data_item_entry.is_null())
         {
             items.push_back(data_item_entry);
         }
-        if( (items.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-        {
-            out.push_back(Pair("items", items));
-        }
-        if(aFormatMetaData.size())
-        {
-            out.push_back(Pair("data", aFormatMetaData));            
-        }
+        out.push_back(Pair("items", items));
 /* MCHN END */    
         vout.push_back(out);
     }
@@ -474,11 +451,9 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)
         entry.push_back(Pair("create", StreamEntry((unsigned char*)&txid,0x05)));
     }
     
-    if(mc_gState->m_Compatibility & MC_VCM_1_0)
-    {
-        entry.push_back(Pair("data", aFullFormatMetaData));
-    }
-
+    entry.push_back(Pair("data", vdata));
+    
+    
     if (hashBlock != 0) {
         entry.push_back(Pair("blockhash", hashBlock.GetHex()));
         BlockMap::iterator mi = mapBlockIndex.find(hashBlock);
@@ -705,21 +680,11 @@ Value listunspent(const Array& params, bool fHelp)
         }
         Array permissions=PermissionEntries(txout,lpScript,false);
         entry.push_back(Pair("permissions", permissions));
-        
-        Array peroutputdata=PerOutputDataEntries(txout,lpScript,hash,out.i);
-        if(peroutputdata.size())
-        {
-            entry.push_back(Pair("data", peroutputdata));
-        }
-        
 //        entry.push_back(Pair("spendable", out.fSpendable));
 /* MCHN END */                
         results.push_back(entry);
     }
 
-/* MCHN START */        
-
-/* MCHN END */        
     return results;
 }
 #endif
@@ -838,13 +803,19 @@ Value appendrawchange(const Array& params, bool fHelp)
         }
     }    
     
-    int assets_per_opdrop;
-
-    assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
-
-    if(amounts->GetCount() > assets_per_opdrop)
+    if(mc_gState->m_Features->VerifySizeOfOpDropElements())
     {
-        throw JSONRPCError(RPC_NOT_ALLOWED, strprintf("Too many assets, maximal number for this chain - %d",assets_per_opdrop));                        
+        int assets_per_opdrop=(MCP_STD_OP_DROP_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+        
+        if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+        {
+            assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+        }
+
+        if(amounts->GetCount() > assets_per_opdrop)
+        {
+            throw JSONRPCError(RPC_NOT_ALLOWED, strprintf("Too many assets, maximal number for this chain - %d",assets_per_opdrop));                        
+        }
     }
     
     CScript scriptChange=GetScriptForDestination(address.Get());
@@ -1001,13 +972,16 @@ void AddCacheInputScriptIfNeeded(CMutableTransaction& rawTx,Array inputs, bool f
             {
                 throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter, cache must be boolean");                
             }
-            if(cache_this.get_bool())
+            if(mc_gState->m_Features->CachedInputScript())
             {
-                if(scriptPubKeyString.is_null())
+                if(cache_this.get_bool())
                 {
-                    fMissingScript=true;
-                }       
-                cache_value=1;
+                    if(scriptPubKeyString.is_null())
+                    {
+                        fMissingScript=true;
+                    }       
+                    cache_value=1;
+                }
             }
         }
         cache_array.push_back(cache_value);            
@@ -1251,9 +1225,12 @@ Value appendrawtransaction(const Array& params, bool fHelp)
 
     if( required & (MC_PTP_ADMIN | MC_PTP_MINE) )
     {
-        if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+        if(mc_gState->m_Features->CachedInputScript())
         {
-            fCachedInputScriptRequired=true;
+            if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+            {
+                fCachedInputScriptRequired=true;
+            }
         }
     }
     
@@ -1285,7 +1262,7 @@ Value appendrawtransaction(const Array& params, bool fHelp)
     {
         BOOST_FOREACH(const Value& data, params[3].get_array()) 
         {
-            CScript scriptOpReturn=ParseRawMetadata(data,MC_DATA_API_PARAM_TYPE_ALL,&entity,NULL);
+            CScript scriptOpReturn=ParseRawMetadata(data,0xFFFF,&entity,NULL);
             CTxOut out(0, scriptOpReturn);
             rawTx.vout.push_back(out);            
         }
@@ -1415,9 +1392,12 @@ Value createrawtransaction(const Array& params, bool fHelp)
 
     if( required & (MC_PTP_ADMIN | MC_PTP_MINE) )
     {
-        if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+        if(mc_gState->m_Features->CachedInputScript())
         {
-            fCachedInputScriptRequired=true;
+            if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+            {
+                fCachedInputScriptRequired=true;
+            }
         }
     }
     
@@ -1449,7 +1429,7 @@ Value createrawtransaction(const Array& params, bool fHelp)
     {
         BOOST_FOREACH(const Value& data, params[2].get_array()) 
         {
-            CScript scriptOpReturn=ParseRawMetadata(data,MC_DATA_API_PARAM_TYPE_ALL,&entity,NULL);
+            CScript scriptOpReturn=ParseRawMetadata(data,0xFFFF,&entity,NULL);
             CTxOut out(0, scriptOpReturn);
             rawTx.vout.push_back(out);            
         }
@@ -1553,7 +1533,7 @@ Value appendrawmetadata(const json_spirit::Array& params, bool fHelp)
         }
     }
     
-    CScript scriptOpReturn=ParseRawMetadata(params[1],MC_DATA_API_PARAM_TYPE_ALL,&entity,NULL);
+    CScript scriptOpReturn=ParseRawMetadata(params[1],0xFFFF,&entity,NULL);
     
     CTxOut txout(0, scriptOpReturn);
     tx.vout.push_back(txout);
@@ -1957,12 +1937,6 @@ Value sendrawtransaction(const Array& params, bool fHelp)
     bool fHaveMempool = mempool.exists(hashTx);
     bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;
     bool fMissingInputs;
-    
-    if(mc_gState->m_WalletMode & MC_WMD_ADDRESS_TXS)
-    {
-        pwalletTxsMain->m_ChunkDB->FlushSourceChunks(GetArg("-flushsourcechunks",true) ? (MC_CDB_FLUSH_MODE_FILE | MC_CDB_FLUSH_MODE_DATASYNC) : MC_CDB_FLUSH_MODE_NONE);
-    }
-    
     if (!fHaveMempool && !fHaveChain) {
         // push to local node and sync with wallets
         CValidationState state;
diff --git a/src/rpc/rpcserver.cpp b/src/rpc/rpcserver.cpp
index 42870ee..62c7931 100644
--- a/src/rpc/rpcserver.cpp
+++ b/src/rpc/rpcserver.cpp
@@ -349,7 +349,7 @@ Value stop(const Array& params, bool fHelp)
 
 string AllowedPausedServices()
 {
-    string ret="incoming,mining,offchain";
+    string ret="incoming,mining";
     
     return ret;
 }
@@ -379,8 +379,6 @@ uint32_t GetPausedServices(const char *str)
                 if(memcmp(start,"incoming",    ptr-start) == 0)type = MC_NPS_INCOMING;
                 if(memcmp(start,"mining",      ptr-start) == 0)type = MC_NPS_MINING;
                 if(memcmp(start,"reaccepting", ptr-start) == 0)type = MC_NPS_REACCEPT;
-                if(memcmp(start,"offchain",    ptr-start) == 0)type = MC_NPS_OFFCHAIN;
-                if(memcmp(start,"chunks",      ptr-start) == 0)type = MC_NPS_CHUNKS;
                 
                 if(type == 0)
                 {
@@ -666,12 +664,14 @@ void mc_InitRPCListIfLimited()
     }
 }
 
-void StartRPCThreads()
+void StartRPCThreads(string& strError)
 {
     mc_InitRPCList(vStaticRPCCommands,vStaticRPCWalletReadCommands);
     mc_InitRPCListIfLimited();
     tableRPC.initialize();
 
+    strError="";
+    
     rpc_allow_subnets.clear();
     rpc_allow_subnets.push_back(CSubNet("127.0.0.0/8")); // always allow IPv4 local subnet
     rpc_allow_subnets.push_back(CSubNet("::1")); // always allow IPv6 localhost
@@ -734,12 +734,20 @@ void StartRPCThreads()
         filesystem::path pathCertFile(GetArg("-rpcsslcertificatechainfile", "server.cert"));
         if (!pathCertFile.is_complete()) pathCertFile = filesystem::path(GetDataDir()) / pathCertFile;
         if (filesystem::exists(pathCertFile)) rpc_ssl_context->use_certificate_chain_file(pathCertFile.string());
-        else LogPrintf("ThreadRPCServer ERROR: missing server certificate file %s\n", pathCertFile.string());
+        else
+        {
+            LogPrintf("ThreadRPCServer ERROR: missing server certificate file %s\n", pathCertFile.string());
+            strError += strprintf("Missing server certificate file %s\n", pathCertFile.string().c_str());
+        }
 
         filesystem::path pathPKFile(GetArg("-rpcsslprivatekeyfile", "server.pem"));
         if (!pathPKFile.is_complete()) pathPKFile = filesystem::path(GetDataDir()) / pathPKFile;
         if (filesystem::exists(pathPKFile)) rpc_ssl_context->use_private_key_file(pathPKFile.string(), ssl::context::pem);
-        else LogPrintf("ThreadRPCServer ERROR: missing server private key file %s\n", pathPKFile.string());
+        else
+        {
+            LogPrintf("ThreadRPCServer ERROR: missing server private key file %s\n", pathPKFile.string());
+            strError += strprintf("Missing server private key file %s\n", pathPKFile.string().c_str());
+        }
 
         string strCiphers = GetArg("-rpcsslciphers", "TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!3DES:@STRENGTH");
         SSL_CTX_set_cipher_list(rpc_ssl_context->impl(), strCiphers.c_str());
@@ -828,6 +836,11 @@ void StartRPCThreads()
         rpc_worker_group->create_thread(boost::bind(&asio::io_service::run, rpc_io_service));
     
     fRPCRunning = true;
+    
+    if(strError.size())
+    {
+        strError += "Node may be unable to process API requests.\n";
+    }
 }
 
 void StartDummyRPCThread()
@@ -1162,8 +1175,7 @@ json_spirit::Value CRPCTable::execute(const std::string &strMethod, const json_s
         throw JSONRPCError(RPC_METHOD_NOT_FOUND, "Method not found (disabled)");
 #endif
 
-//    if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
-    if( (mc_gState->m_ProtocolVersionToUpgrade > 0) && (mc_gState->IsSupported(mc_gState->m_ProtocolVersionToUpgrade) == 0) )
+    if(mc_gState->m_ProtocolVersionToUpgrade > mc_gState->m_NetworkParams->ProtocolVersion())
     {
         if( setAllowedWhenWaitingForUpgrade.count(strMethod) == 0 )
         {
diff --git a/src/rpc/rpcserver.h b/src/rpc/rpcserver.h
index e03f08a..45fe6ca 100644
--- a/src/rpc/rpcserver.h
+++ b/src/rpc/rpcserver.h
@@ -34,7 +34,7 @@ public:
 };
 
 /** Start RPC threads */
-void StartRPCThreads();
+void StartRPCThreads(std::string& strError);
 /**
  * Alternative to StartRPCThreads for the GUI, when no server is
  * used. The RPC thread in this case is only used to handle timeouts.
@@ -192,14 +192,8 @@ extern json_spirit::Value getaccount(const json_spirit::Array& params, bool fHel
 extern json_spirit::Value getaddressesbyaccount(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value sendtoaddress(const json_spirit::Array& params, bool fHelp);
 /* MCHN START */    
-extern json_spirit::Value debug(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value getchunkqueueinfo(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value getchunkqueuetotals(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value createkeypairs(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value getaddresses(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value createbinarycache(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value appendbinarycache(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value deletebinarycache(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value combineunspent(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value grantcmd(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value revokecmd(const json_spirit::Array& params, bool fHelp);
@@ -257,21 +251,15 @@ extern json_spirit::Value unsubscribe(const json_spirit::Array& params, bool fHe
 extern json_spirit::Value listassettransactions(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value getassettransaction(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value getstreamitem(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value liststreamtxitems(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreamitems(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreamkeyitems(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value liststreamqueryitems(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreampublisheritems(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreamkeys(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreampublishers(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value gettxoutdata(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value listblocks(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value liststreamblockitems(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value getstreamkeysummary(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value getstreampublishersummary(const json_spirit::Array& params, bool fHelp);
-extern json_spirit::Value storechunk(const json_spirit::Array& params, bool fHelp);
 
-extern json_spirit::Value purehelpitem(const json_spirit::Array& params, bool fHelp);
 /* MCHN END */    
 extern json_spirit::Value signmessage(const json_spirit::Array& params, bool fHelp);
 extern json_spirit::Value verifymessage(const json_spirit::Array& params, bool fHelp);
diff --git a/src/rpc/rpcstreams.cpp b/src/rpc/rpcstreams.cpp
index 9d1fbbc..a51dc8c 100644
--- a/src/rpc/rpcstreams.cpp
+++ b/src/rpc/rpcstreams.cpp
@@ -6,19 +6,6 @@
 
 
 #include "rpc/rpcwallet.h"
-#include "json/json_spirit_ubjson.h"
-#include "json/json_spirit_reader_template.h"
-#include "json/json_spirit_writer_template.h"
-
-#define MC_QPR_MAX_UNCHECKED_TX_LIST_SIZE    1048576
-#define MC_QPR_MAX_MERGED_TX_LIST_SIZE          1024
-#define MC_QPR_MAX_DIRTY_TX_LIST_SIZE           5000
-#define MC_QPR_MAX_CLEAN_TX_LIST_SIZE           5000
-#define MC_QPR_MAX_SECONDARY_TX_LIST_SIZE    1048576
-#define MC_QPR_TX_CHECK_COST                     100
-#define MC_QPR_MAX_TX_PER_BLOCK                    4
-
-
 
 Value createupgradefromcmd(const Array& params, bool fHelp);
 
@@ -178,7 +165,15 @@ Value liststreams(const Array& params, bool fHelp)
     
     int root_stream_name_size;
     mc_gState->m_NetworkParams->GetParam("rootstreamname",&root_stream_name_size);        
-    mc_AdjustStartAndCount(&count,&start,streams->GetCount());        
+    if( (root_stream_name_size <= 1) && (inputStrings.size() == 0) && (mc_gState->m_Features->FixedIn10008() == 0) )            // Patch, to be removed in 10008
+    {
+        mc_AdjustStartAndCount(&count,&start,streams->GetCount()-1);        
+        start++;            
+    }
+    else
+    {
+        mc_AdjustStartAndCount(&count,&start,streams->GetCount());        
+    }
     
     
     Array partial_results;
@@ -240,6 +235,10 @@ Value liststreams(const Array& params, bool fHelp)
     {
         return_partial=true;
     }
+    if( (root_stream_name_size <= 1) && (inputStrings.size() == 0)  && (mc_gState->m_Features->FixedIn10008() == 0) )            // Patch, to be removed in 10008
+    {
+        return_partial=true;        
+    }
     mc_gState->m_Assets->FreeEntityList(streams);
     if(return_partial)
     {
@@ -258,6 +257,11 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
     if (fHelp || params.size() < 4)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
+    
     if (strcmp(params[1].get_str().c_str(),"stream"))
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid entity type, should be stream");
 
@@ -281,9 +285,15 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
         stream_name=params[2].get_str();
     }
     
-    if(stream_name == "*")
+    if(params[3].type() != bool_type)
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid open flag, should be boolean");
+    
+    if(mc_gState->m_Features->Streams())
     {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid stream name: *");                                                                                            
+        if(stream_name == "*")
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid stream name: *");                                                                                            
+        }
     }
 
     unsigned char buf_a[MC_AST_ASSET_REF_SIZE];    
@@ -313,69 +323,10 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
     
     lpDetails->Clear();
     lpDetails->AddElement();
-    
-    if(mc_gState->m_Features->OffChainData())
-    {
-        string strError;
-        uint32_t permissions=0;
-        uint32_t restrict=0;
-        if(params[3].type() != bool_type)
-        {
-            if(params[3].type() == obj_type)
-            {
-                BOOST_FOREACH(const Pair& d, params[3].get_obj()) 
-                {
-                    if(d.name_ == "restrict")
-                    {
-                        if(RawDataParseRestrictParameter(d.value_,&restrict,&permissions,&strError))
-                        {
-                            if(restrict & MC_ENT_ENTITY_RESTRICTION_OFFCHAIN)
-                            {
-                                if(restrict & MC_ENT_ENTITY_RESTRICTION_ONCHAIN)
-                                {
-                                    throw JSONRPCError(RPC_NOT_SUPPORTED, "Stream cannot be restricted from both onchain and offchain items");               
-                                }                        
-                            }                            
-                        }
-                        else
-                        {
-                            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);                                                                           
-                        }
-                    }
-                    else
-                    {
-                        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid field, should be restrict");               
-                    }
-                }
-            }
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid open flag, should be boolean or object");               
-            }
-        }
-        else
-        {            
-            permissions = params[3].get_bool() ? MC_PTP_NONE : MC_PTP_WRITE;
-        }
-        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_PERMISSIONS,(unsigned char*)&permissions,1);                                
-        if(restrict)
-        {
-            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_RESTRICTIONS,(unsigned char*)&restrict,1);                         
-        }
-        
-    }
-    else
+    if(params[3].get_bool())
     {
-        if(params[3].type() != bool_type)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid open flag, should be boolean or object");
-        }
-
-        if(params[3].get_bool())
-        {
-            unsigned char b=1;        
-            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ANYONE_CAN_WRITE,&b,1);        
-        }
+        unsigned char b=1;        
+        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ANYONE_CAN_WRITE,&b,1);        
     }
     if(stream_name.size())
     {        
@@ -383,7 +334,7 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
     }
     
     
-/*
+
     if (params.size() > 4)
     {
         if(params[4].type() == obj_type)
@@ -399,45 +350,64 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
             throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields, expecting object");                                        
         }
     }
-*/
-    
-    vector<CTxDestination> addresses;       
-    vector<CTxDestination> fromaddresses;
-    CScript scriptOpReturn=CScript();
-    
-    int errorCode=RPC_INVALID_PARAMETER;
-    string strError;    
-    lpDetailsScript->Clear();
-    if (params.size() > 4)
-    {
-        ParseRawDetails(&(params[4]),lpDetails,lpDetailsScript,&errorCode,&strError);        
-        if(strError.size())
-        {
-            goto exitlbl;
-        }
-    }
-    lpDetailsScript->Clear();
     
     int err;
     size_t bytes;
     const unsigned char *script;
     script=lpDetails->GetData(0,&bytes);
     
-
     size_t elem_size;
     const unsigned char *elem;
+    CScript scriptOpReturn=CScript();
     
-    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
-    if(err)
+    if(mc_gState->m_Features->OpDropDetailsScripts())
     {
-        strError= "Invalid custom fields or stream name, too long";
-        goto exitlbl;
-//            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or stream name, too long");                                                        
+        err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
+        if(err)
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or stream name, too long");                                                        
+        }
+        
+        elem = lpDetailsScript->GetData(0,&elem_size);
+        scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;        
     }
+    else
+    {
+        lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM);
+
+        err=lpDetailsScript->SetGeneralDetails(script,bytes);
+        if(err)
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or stream name, too long");                                                    
+        }
 
-    elem = lpDetailsScript->GetData(0,&elem_size);
-    scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;        
+        for(int e=0;e<lpDetailsScript->GetNumElements();e++)
+        {
+            elem = lpDetailsScript->GetData(e,&elem_size);
+            if(e == (lpDetailsScript->GetNumElements() - 1) )
+            {
+                if(elem_size > 0)
+                {
+                    scriptOpReturn << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+                }
+                else
+                {
+                    scriptOpReturn << OP_RETURN;
+                }
+            }
+            else
+            {
+                if(elem_size > 0)
+                {
+                    scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
+                }                
+            }
+        }    
+    }
     
+    vector<CTxDestination> addresses;    
+    
+    vector<CTxDestination> fromaddresses;        
     
     if(params[0].get_str() != "*")
     {
@@ -445,17 +415,12 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
 
         if(fromaddresses.size() != 1)
         {
-            strError= "Single from-address should be specified";
-            goto exitlbl;
-//            throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
         }
 
         if( (IsMine(*pwalletMain, fromaddresses[0]) & ISMINE_SPENDABLE) != ISMINE_SPENDABLE )
         {
-            strError= "Private key for from-address is not found in this wallet";
-            errorCode=RPC_WALLET_ADDRESS_NOT_FOUND;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
+            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
         }
         
         set<CTxDestination> thisFromAddresses;
@@ -468,10 +433,7 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
         CPubKey pkey;
         if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_CREATE,&thisFromAddresses))
         {
-            strError= "from-address doesn't have create permission";
-            errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-            goto exitlbl;
-//            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have create permission");                
+            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have create permission");                
         }   
     }
     else
@@ -479,28 +441,16 @@ Value createstreamfromcmd(const Array& params, bool fHelp)
         CPubKey pkey;
         if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_CREATE))
         {
-            strError= "This wallet doesn't have keys with create permission";
-            errorCode=RPC_INSUFFICIENT_PERMISSIONS;
-            goto exitlbl;
             throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "This wallet doesn't have keys with create permission");                
         }        
     }
     
     
     EnsureWalletIsUnlocked();
-    {
-        LOCK (pwalletMain->cs_wallet_send);
-
-        SendMoneyToSeveralAddresses(addresses, 0, wtx, lpScript, scriptOpReturn,fromaddresses);
-    }
+    LOCK (pwalletMain->cs_wallet_send);
     
-exitlbl:
+    SendMoneyToSeveralAddresses(addresses, 0, wtx, lpScript, scriptOpReturn,fromaddresses);
 
-    if(strError.size())
-    {
-        throw JSONRPCError(errorCode, strError);            
-    }
-                
     return wtx.GetHash().GetHex();    
 }
 
@@ -509,6 +459,10 @@ Value createfromcmd(const Array& params, bool fHelp)
     if (fHelp || params.size() < 4)
         throw runtime_error("Help message not found\n");
     
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if (strcmp(params[1].get_str().c_str(),"stream") == 0)
     {
         return createstreamfromcmd(params,fHelp);    
@@ -526,6 +480,11 @@ Value createcmd(const Array& params, bool fHelp)
 {
     if (fHelp || params.size() < 3)
         throw runtime_error("Help message not found\n");
+
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     
     Array ext_params;
     ext_params.push_back("*");
@@ -539,9 +498,14 @@ Value createcmd(const Array& params, bool fHelp)
 
 Value publish(const Array& params, bool fHelp)
 {
-    if (fHelp || params.size() < 3 || params.size() > 4)
+    if (fHelp || params.size() != 3)
         throw runtime_error("Help message not found\n");
-        
+    
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
+    
     Array ext_params;
     ext_params.push_back("*");
     BOOST_FOREACH(const Value& value, params)
@@ -554,12 +518,21 @@ Value publish(const Array& params, bool fHelp)
 
 Value publishfrom(const Array& params, bool fHelp)
 {
-    if (fHelp || params.size() < 4 || params.size() > 5)
+    if (fHelp || params.size() != 4)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
+       
+    if(params[2].get_str() == "*")
+    {
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid item-key-string: *");                
+    }
+    
     mc_Script *lpScript=mc_gState->m_TmpBuffers->m_RpcScript3;
     lpScript->Clear();
-    
     mc_EntityDetails stream_entity;
     parseStreamIdentifier(params[1],&stream_entity);           
                
@@ -567,11 +540,6 @@ Value publishfrom(const Array& params, bool fHelp)
     // Wallet comments
     CWalletTx wtx;
             
-    uint32_t in_options,out_options;
-    
-    in_options=MC_RFD_OPTION_NONE;
-    out_options=MC_RFD_OPTION_NONE;
-    
     vector<CTxDestination> addresses;    
     
     vector<CTxDestination> fromaddresses;        
@@ -592,176 +560,60 @@ Value publishfrom(const Array& params, bool fHelp)
 
     FindAddressesWithPublishPermission(fromaddresses,&stream_entity);
         
-    Array keys;
-    
-    if(params[2].type() == str_type)
-    {
-        keys.push_back(params[2]);
-    }
-    else
-    {
-        if(params[2].type() == array_type)
-        {
-            keys=params[2].get_array();
-        }
-        else
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Item keys should be either string or array");                                                                                                                
-        }
-    }
-    
-    if(keys.size() == 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Item keys array cannot be empty");                                                                                                                
-    }
-    
-    for(int k=0;k<(int)keys.size();k++)
-    {
-        if(keys[k].type() != str_type)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Item key should be string");                                                                                                                
-        }        
-        if(keys[k].get_str().size() > MC_ENT_MAX_ITEM_KEY_SIZE)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Item key is too long");                                                                                                    
-        }        
-        if(keys[k].get_str() == "*")
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid item-key-string: *");                
-        }
-    }
-
-    if(params.size() > 4 )
-    {
-        if(params[4].type() != str_type)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Stream item options must be offchain or empty");                                                                                                                            
-        }
-        if( mc_gState->m_Features->OffChainData() == 0 )
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Format options are not supported by this protocol version");                                                                                                                            
-        }        
-        if(params[4].get_str().size())
-        {
-            if(params[4].get_str() == "offchain")
-            {
-                in_options |= MC_RFD_OPTION_OFFCHAIN;
-            }
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Stream item options must be offchain or empty");                                                                                                                            
-            }
-        }
-    }
-
-    if( mc_gState->m_Features->OffChainData() )
-    {
-        if(in_options & MC_RFD_OPTION_OFFCHAIN)
-        {
-            if(stream_entity.Restrictions() & MC_ENT_ENTITY_RESTRICTION_OFFCHAIN)
-            {
-                throw JSONRPCError(RPC_NOT_ALLOWED, "Publishing offchain items is not allowed to this stream");     
-            }
-        }
-        else
-        {
-            if(stream_entity.Restrictions() & MC_ENT_ENTITY_RESTRICTION_ONCHAIN)
-            {
-                throw JSONRPCError(RPC_NOT_ALLOWED, "Publishing onchain items is not allowed to this stream");     
-            }            
-        }
-    }
-    
-    if(keys.size() > 1)
+    if(params[2].get_str().size() > MC_ENT_MAX_ITEM_KEY_SIZE)
     {
-        if( mc_gState->m_Features->MultipleStreamKeys() == 0 )
-        {
-            throw JSONRPCError(RPC_NOT_SUPPORTED, "Multiple keys are not supported by this protocol version");                            
-        }
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Item key is too long");                                                                                                    
     }
     
     mc_Script *lpDetailsScript=mc_gState->m_TmpBuffers->m_RpcScript1;
     lpDetailsScript->Clear();
-    
-    uint32_t data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-    
-    vector<unsigned char> dataData;
-    lpDetailsScript->Clear();
-
-    string strError;
-    int errorCode=RPC_INVALID_PARAMETER;
-    vector<uint256> vChunkHashes;
-    
-    dataData=ParseRawFormattedData(&(params[3]),&data_format,lpDetailsScript,in_options,&out_options,&errorCode,&strError);
+        
 
-    if(strError.size())
+    bool fIsHex;
+    vector<unsigned char> dataData(ParseHex(params[3].get_str().c_str(),fIsHex));    
+    if(!fIsHex)
     {
-        throw JSONRPCError(errorCode, strError);                                                                                                                
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Item data should be hexadecimal string");                                                                                                    
     }
     
-    size_t elem_size;
-    const unsigned char *elem;
-    CScript scriptOpReturn=CScript();
-    
     lpDetailsScript->Clear();
     lpDetailsScript->SetEntity(stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-    for(int k=0;k<(int)keys.size();k++)
-    {
-        lpDetailsScript->SetItemKey((unsigned char*)keys[k].get_str().c_str(),keys[k].get_str().size());
-    }
+    lpDetailsScript->SetItemKey((unsigned char*)params[2].get_str().c_str(),params[2].get_str().size());
 
-    if( (in_options & MC_RFD_OPTION_OFFCHAIN) == 0)
+    lpDetailsScript->AddElement();
+    if(dataData.size())
     {
-        if( data_format != MC_SCR_DATA_FORMAT_UNKNOWN )
-        {
-            lpDetailsScript->SetDataFormat(data_format);
-        }        
+        lpDetailsScript->SetData(&dataData[0],dataData.size());
     }
+
+    size_t elem_size;
+    const unsigned char *elem;
+    CScript scriptOpReturn=CScript();
     
     for(int e=0;e<lpDetailsScript->GetNumElements();e++)
     {
         elem = lpDetailsScript->GetData(e,&elem_size);
-        if(elem_size > 0)
-        {
-            scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
-        }                
-    }    
-    
-    lpDetailsScript->Clear();
-    if(in_options & MC_RFD_OPTION_OFFCHAIN)        
-    {
-        AppendOffChainFormatData(data_format,out_options,lpDetailsScript,dataData,&vChunkHashes,&errorCode,&strError);
-        if(strError.size())
-        {
-            throw JSONRPCError(errorCode, strError);                                                                                                                
-        }
-        elem = lpDetailsScript->GetData(0,&elem_size);
-        scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;                    
-        scriptOpReturn << OP_RETURN;                                                
-    }
-    else
-    {
-        if(out_options & MC_RFD_OPTION_OFFCHAIN)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "chunks data type is not allowed with missing options field");                
-        }
-        lpDetailsScript->AddElement();
-        if(dataData.size())
-        {
-            lpDetailsScript->SetData(&dataData[0],dataData.size());
-        }
-        elem = lpDetailsScript->GetData(0,&elem_size);
-        if(elem_size > 0)
+        if(e == (lpDetailsScript->GetNumElements() - 1) )
         {
-            scriptOpReturn << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+            if(elem_size > 0)
+            {
+                scriptOpReturn << OP_RETURN << vector<unsigned char>(elem, elem + elem_size);
+            }
+            else
+            {
+                scriptOpReturn << OP_RETURN;
+            }
         }
         else
         {
-            scriptOpReturn << OP_RETURN;
+            if(elem_size > 0)
+            {
+                scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP;
+            }                
         }
-    }
+    }    
+    
     
-
     lpScript->Clear();
          
     EnsureWalletIsUnlocked();
@@ -777,6 +629,10 @@ Value subscribe(const Array& params, bool fHelp)
     if (fHelp || params.size() < 1 || params.size() > 2)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. To get this functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -862,12 +718,16 @@ Value unsubscribe(const Array& params, bool fHelp)
     if (fHelp || params.size() < 1 || params.size() > 2)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. To get this functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
     }   
        
-    bool purge=false;
+
     vector<mc_EntityDetails> inputEntities;
     vector<string> inputStrings;
     if(params[0].type() == str_type)
@@ -879,18 +739,6 @@ Value unsubscribe(const Array& params, bool fHelp)
         inputStrings=ParseStringList(params[0]);
     }
     
-    if(params.size() > 1)
-    {
-        if(params[1].type() == bool_type)
-        {
-            purge=params[1].get_bool();
-        }
-        else
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid value for 'purge' field, should be boolean");                                                                
-        }        
-    }
-    
     for(int is=0;is<(int)inputStrings.size();is++)
     {
         mc_EntityDetails entity_to_subscribe;
@@ -899,13 +747,8 @@ Value unsubscribe(const Array& params, bool fHelp)
         inputEntities.push_back(entity_to_subscribe);
     }
         
-    int32_t buf_mode=MC_BUF_MODE_DEFAULT;
-    if(inputStrings.size() > 1)
-    {
-        buf_mode=MC_BUF_MODE_MAP;
-    }
     mc_Buffer *streams=mc_gState->m_TmpBuffers->m_RpcBuffer1;
-    streams->Initialize(sizeof(mc_TxEntity),sizeof(mc_TxEntity),buf_mode);
+    streams->Initialize(sizeof(mc_TxEntity),sizeof(mc_TxEntity),MC_BUF_MODE_DEFAULT);
     
     
     bool fNewFound=false;
@@ -948,7 +791,7 @@ Value unsubscribe(const Array& params, bool fHelp)
 
     if(fNewFound)
     {
-        if(pwalletTxsMain->Unsubscribe(streams,purge))
+        if(pwalletTxsMain->Unsubscribe(streams))
         {
             throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't unsubscribe from stream");                                    
         }
@@ -957,11 +800,15 @@ Value unsubscribe(const Array& params, bool fHelp)
     return Value::null;
 }
 
-Value liststreamtxitems(const Array& params, bool fHelp)
+Value getstreamitem(const Array& params, bool fHelp)
 {
     if (fHelp || params.size() < 2 || params.size() > 3)
         throw runtime_error("Help message not found\n");
    
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -981,6 +828,9 @@ Value liststreamtxitems(const Array& params, bool fHelp)
         throw JSONRPCError(RPC_NOT_SUBSCRIBED, "Not subscribed to this stream");                                
     }
     
+    
+    uint256 hash = ParseHashV(params[1], "parameter 2");
+    
     bool verbose=false;
     
     if (params.size() > 2)    
@@ -988,91 +838,27 @@ Value liststreamtxitems(const Array& params, bool fHelp)
         verbose=paramtobool(params[2]);
     }
     
-    Array output_array;
-    
-    vector<string> inputStrings;
+    const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
     
-    inputStrings=ParseStringList(params[1]);
+    Object entry=StreamItemEntry(wtx,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose);    
     
-    for(int j=0;j<(int)inputStrings.size();j++)
+    if(entry.size() == 0)
     {
-        uint256 hash = ParseHashV(inputStrings[j], "txid");
-        
-        const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-
-        int first_output=0;
-        int stream_output;
-        while(first_output < (int)wtx.vout.size())
-        {
-            Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,NULL,&stream_output);   
-
-            if(stream_output < (int)wtx.vout.size())
-            {
-                output_array.push_back(entry);
-            }
-            first_output=stream_output+1;
-        }
-    }   
-    
-//    uint256 hash = ParseHashV(params[1], "parameter 2");
-    
-    
+        throw JSONRPCError(RPC_TX_NOT_FOUND, "This transaction was not found in this stream");                
+    }
     
-    return output_array;    
+    return entry;
 }
 
-Value getstreamitem(const Array& params, bool fHelp)
+Value liststreamitems(const Array& params, bool fHelp)
 {
-    if (fHelp || params.size() < 2 || params.size() > 3)
+    if (fHelp || params.size() < 1 || params.size() > 5)
         throw runtime_error("Help message not found\n");
-   
-    Array items=liststreamtxitems(params,fHelp).get_array();
-    
-    if(items.size() == 0)
-    {
-        throw JSONRPCError(RPC_TX_NOT_FOUND, "This transaction was not found in this stream");                        
-    }
-    if(items.size() > 1)
-    {
-        throw JSONRPCError(RPC_NOT_ALLOWED, "This transaction has more than one output for this stream, please use liststreamtxitems");                                
-    }
 
-    return items[0];    
-}
-
-int mc_GetHashAndFirstOutput(mc_TxEntityRow *lpEntTx,uint256 *hash)
-{
-    int first_output=0;
-    int count;
-    mc_TxEntityRow erow;
-
-    memcpy(hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);        
-    if(lpEntTx->m_Flags & MC_TFL_IS_EXTENSION)
+    if(mc_gState->m_Features->Streams() == 0)
     {
-        erow.Zero();
-        memcpy(&erow.m_Entity,&lpEntTx->m_Entity,sizeof(mc_TxEntity));
-        erow.m_Generation=lpEntTx->m_Generation;
-        erow.m_Pos=lpEntTx->m_Pos;
-        first_output=(int)mc_GetLE(lpEntTx->m_TxId+MC_TEE_OFFSET_IN_TXID,sizeof(uint32_t));
-        count=(int)mc_GetLE(lpEntTx->m_TxId+MC_TEE_OFFSET_IN_TXID+sizeof(uint32_t),sizeof(uint32_t));
-        if((int)erow.m_Pos > count)
-        {
-            erow.m_Pos-=count;
-            if(pwalletTxsMain->GetRow(&erow) == 0)
-            {
-                memcpy(hash,erow.m_TxId,MC_TDB_TXID_SIZE);                
-            }
-        }
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
     }
-    
-    return first_output;
-}
-
-Value liststreamitems(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() < 1 || params.size() > 5)
-        throw runtime_error("Help message not found\n");
-
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -1128,16 +914,16 @@ Value liststreamitems(const Array& params, bool fHelp)
     mc_AdjustStartAndCount(&count,&start,entStat.m_LastPos);
     
     Array retArray;
-    pwalletTxsMain->GetList(&entStat.m_Entity,start+1,count,entity_rows);
-
+    CheckWalletError(pwalletTxsMain->GetList(&entStat.m_Entity,start+1,count,entity_rows));
+    
     for(int i=0;i<entity_rows->GetCount();i++)
     {
         mc_TxEntityRow *lpEntTx;
         lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
         uint256 hash;
-        int first_output=mc_GetHashAndFirstOutput(lpEntTx,&hash);
+        memcpy(&hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);
         const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-        Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,NULL,NULL);
+        Object entry=StreamItemEntry(wtx,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose);
         if(entry.size())
         {
             retArray.push_back(entry);                                
@@ -1158,18 +944,15 @@ void getTxsForBlockRange(vector <uint256>& txids,mc_TxEntity *entity,int height_
         count=last_item-first_item+1;
         if(count > 0)
         {
-            pwalletTxsMain->GetList(entity,first_item,count,entity_rows);
+            CheckWalletError(pwalletTxsMain->GetList(entity,first_item,count,entity_rows));
             
             mc_TxEntityRow *lpEntTx;
             uint256 hash;
             for(i=0;i<count;i++)
             {
                 lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
-                if( (lpEntTx->m_Flags & MC_TFL_IS_EXTENSION) == 0 )
-                {
-                    memcpy(&hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);
-                    txids.push_back(hash);
-                }
+                memcpy(&hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);
+                txids.push_back(hash);
             }
         }        
     }
@@ -1180,6 +963,10 @@ Value liststreamblockitems(const Array& params, bool fHelp)
     if (fHelp || params.size() < 2 || params.size() > 5)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -1253,16 +1040,10 @@ Value liststreamblockitems(const Array& params, bool fHelp)
     for(int i=start;i<start+count;i++)
     {
         const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(txids[i],NULL,NULL);
-        int first_output=0;
-        int stream_output;
-        while(first_output < (int)wtx.vout.size())
+        Object entry=StreamItemEntry(wtx,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose);
+        if(entry.size())
         {
-            Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,NULL,&stream_output);
-            if(entry.size())
-            {
-                retArray.push_back(entry);                                
-            }
-            first_output=stream_output+1;
+            retArray.push_back(entry);                                
         }
     }
     
@@ -1319,324 +1100,15 @@ void getSubKeyEntityFromPublisher(string str,mc_TxEntityStat entStat,mc_TxEntity
     entity->m_EntityType=entStat.m_Entity.m_EntityType | MC_TET_SUBKEY;    
 }
 
-Value getstreamsummary(const Array& params, bool fPublisher)
-{
-    if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
-    {
-        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
-    }   
-
-    mc_TxEntityStat entStat;
-    mc_TxEntity entity;
-    
-    mc_EntityDetails stream_entity;
-    parseStreamIdentifier(params[0],&stream_entity);           
-
-    entStat.Zero();
-    memcpy(&entStat,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-    entStat.m_Entity.m_EntityType=MC_TET_STREAM_KEY;
-    if(fPublisher)
-    {
-        entStat.m_Entity.m_EntityType=MC_TET_STREAM_PUBLISHER;        
-    }
-    entStat.m_Entity.m_EntityType |= MC_TET_CHAINPOS;
-    if(!pwalletTxsMain->FindEntity(&entStat))
-    {
-        throw JSONRPCError(RPC_NOT_SUBSCRIBED, "Not subscribed to this stream");                                
-    }
-
-    bool fFirstPublisher=false;
-    bool fFirstPublisherAll=false;
-    string key_string=params[1].get_str();    
-    vector <mc_QueryCondition> conditions;
-
-    if(fPublisher)
-    {
-        getSubKeyEntityFromPublisher(params[1].get_str(),entStat,&entity);    
-        conditions.push_back(mc_QueryCondition(MC_QCT_PUBLISHER,params[1].get_str()));
-    }
-    else
-    {
-        getSubKeyEntityFromKey(params[1].get_str(),entStat,&entity);
-        conditions.push_back(mc_QueryCondition(MC_QCT_KEY,params[1].get_str()));
-    }
-    
-    set<string> setFirstPublishers;
-    
-    vector<string> inputStrings;
-    inputStrings=ParseStringList(params[2]);
-    uint32_t mode=0;
-    for(int j=0;j<(int)inputStrings.size();j++)
-    {
-        bool found=false;
-        if(inputStrings[j]=="jsonobjectmerge")
-        {
-            mode |= MC_VMM_MERGE_OBJECTS;
-            found=true;
-        }
-        if(inputStrings[j]=="recursive")
-        {
-            mode |= MC_VMM_RECURSIVE;
-            found=true;
-        }
-        if( (inputStrings[j]=="ignore") || (inputStrings[j]=="ignoreother") )
-        {
-            mode |= MC_VMM_IGNORE_OTHER;
-            found=true;
-        }
-        if(inputStrings[j]=="ignoremissing")
-        {
-            mode |= MC_VMM_IGNORE_MISSING;
-            found=true;
-        }
-        if(inputStrings[j]=="noupdate")
-        {
-            mode |= MC_VMM_TAKE_FIRST;
-            mode |= MC_VMM_TAKE_FIRST_FOR_FIELD;
-            found=true;
-        }
-        if(inputStrings[j]=="omitnull")
-        {
-            mode |= MC_VMM_OMIT_NULL;
-            found=true;
-        }
-        if(!fPublisher)
-        {
-            if(inputStrings[j]=="firstpublishersany")
-            {
-                if(fFirstPublisher)
-                {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, "firstpublishers* option can appear only once in them mode");                                                                        
-                }
-                fFirstPublisher=true;
-                fFirstPublisherAll=false;                
-                found=true;
-            }            
-            if(inputStrings[j]=="firstpublishersall")
-            {
-                if(fFirstPublisher)
-                {
-                    throw JSONRPCError(RPC_INVALID_PARAMETER, "firstpublishers* option can appear only once in them mode");                                                                        
-                }
-                fFirstPublisher=true;
-                fFirstPublisherAll=true;                
-                found=true;
-            }            
-        }
-        if(!found)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Unrecognized mode: " + inputStrings[j]);                                            
-        }
-    }
-    
-    if( (mode & MC_VMM_MERGE_OBJECTS) == 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "missing jsonobjectmerge");                                                    
-    }
-    
-    mc_Buffer *entity_rows=mc_gState->m_TmpBuffers->m_RpcEntityRows;
-    entity_rows->Clear();
-        
-    Object empty_object;
-    Object obj;
-    int i,n,c,m,err,pcount;
-    bool available;
-    err=MC_ERR_NOERROR;
-    n=pwalletTxsMain->GetListSize(&entity,entStat.m_Generation,NULL);
-    i=0;
-    m=10;
-    
-    Value result;
-    
-    while(i<n)
-    {
-        if((i % m) == 0)
-        {
-            c=m;
-            if(i+c > n)
-            {
-                c=n-i;
-            }
-            pwalletTxsMain->GetList(&entity,entStat.m_Generation,i+1,c,entity_rows);
-        }
-        mc_TxEntityRow *lpEntTx;
-        lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i % m);
-        uint256 hash;
-        int first_output=mc_GetHashAndFirstOutput(lpEntTx,&hash);
-        const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-        Object entry;
-        entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,false,&conditions,NULL);
-/*        
-        if(fPublisher)
-        {
-            entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,false,NULL,&key_ptr,NULL);
-        }
-        else
-        {
-            entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,false,&key_ptr,NULL,NULL);            
-        }
-*/        
-        if(fFirstPublisher)
-        {
-            pcount=0;
-            BOOST_FOREACH(const Pair& a, entry) 
-            {
-                if(a.name_ == "publishers")
-                {
-                    Array arr=a.value_.get_array();
-                    if(i == 0)
-                    {
-                        setFirstPublishers.clear();
-                        for(unsigned int j=0;j<arr.size();j++) 
-                        {
-                            setFirstPublishers.insert(arr[j].get_str());
-                            pcount++;      
-                        }
-                    }
-                    else
-                    {                       
-                        for(unsigned int j=0;j<arr.size();j++) 
-                        {
-                            const set<string>::const_iterator it=setFirstPublishers.find(arr[j].get_str());   
-                            if(it != setFirstPublishers.end())
-                            {
-                                pcount++;      
-                            }
-                        }
-                    }                
-                }            
-            }
-            if( ( fFirstPublisherAll && (pcount != (int)setFirstPublishers.size())) || 
-                (!fFirstPublisherAll && (pcount == 0)) )                     
-            {
-                entry.clear();
-            }
-        }
-        
-        available=true;
-        BOOST_FOREACH(const Pair& a, entry) 
-        {
-            if(a.name_ == "offchain")
-            {
-                available=!a.value_.get_bool();
-            }
-        }
-        
-        if(!available)
-        {
-            BOOST_FOREACH(const Pair& a, entry) 
-            {
-                if(a.name_ == "available")
-                {
-                    available=a.value_.get_bool();
-                }
-            }
-        }
-                        
-        
-        BOOST_FOREACH(const Pair& a, entry) 
-        {
-            if(a.name_ == "data")
-            {
-                if(available)
-                {
-                    if(i == 0)
-                    {
-                        result=a.value_;
-                    }
-                    else
-                    {
-                        result=mc_MergeValues(&result,&(a.value_),mode,0,&err);
-                    }
-                }
-                else
-                {
-                    available=true;
-                    BOOST_FOREACH(const Pair& b, a.value_.get_obj()) 
-                    {
-                        if(b.name_ == "format")
-                        {
-                            available=false;
-                            if(b.value_.get_str() != "json")
-                            {
-                                if(mode & MC_VMM_IGNORE_OTHER)
-                                {
-                                    available=true;
-                                }
-                                else
-                                {
-                                    err=MC_ERR_INVALID_PARAMETER_VALUE;                                            
-                                    goto exitlbl;
-                                }
-                            }
-
-                        }
-                    }
-                    if( (mode & MC_VMM_IGNORE_MISSING) == 0)
-                    {
-                        if(!available)
-                        {
-                            throw JSONRPCError(RPC_NOT_ALLOWED, "Some items to be merged are missing (try using \'ignoremissing\')" );                                                                            
-                        }
-                    }                    
-                }
-            }
-        }    
-        if(err)
-        {
-            goto exitlbl;
-        }
-        i++;
-    }
-    
-    if(mc_IsJsonObjectForMerge(&result,0))
-    {
-        Value json=result.get_obj()[0].value_;
-        Value empty_value=empty_object;
-        json=mc_MergeValues(&json,&empty_value,mode | MC_VMM_TAKE_FIRST,1,&err);     
-        obj.push_back(Pair("json", json));        
-    }            
-    else
-    {
-        if( (mode & MC_VMM_IGNORE_OTHER) == 0)
-        {
-            err=MC_ERR_INVALID_PARAMETER_VALUE;
-        }
-        obj.push_back(Pair("json", empty_object));        
-    }
-    result=obj;
-    
-exitlbl:    
-
-    if(err)
-    {
-        throw JSONRPCError(RPC_NOT_ALLOWED, "Some items to be merged are in the wrong format (try using \'ignoreother\')" );                                                    
-    }
-
-    return result;
-}
-
-Value getstreamkeysummary(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() != 3)
-        throw runtime_error("Help message not found\n");
-    
-    return getstreamsummary(params,false);
-}
-
-Value getstreampublishersummary(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() != 3)
-        throw runtime_error("Help message not found\n");
-    
-    return getstreamsummary(params,true);
-}
-
 Value liststreamkeyitems(const Array& params, bool fHelp)
 {
     if (fHelp || params.size() < 2 || params.size() > 6)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -1703,29 +1175,25 @@ Value liststreamkeyitems(const Array& params, bool fHelp)
         throw JSONRPCError(RPC_NOT_SUBSCRIBED, "Not subscribed to this stream");                                
     }
 
-    string key_string=params[1].get_str();
     getSubKeyEntityFromKey(params[1].get_str(),entStat,&entity);
     
-    vector <mc_QueryCondition> conditions;
-
-    conditions.push_back(mc_QueryCondition(MC_QCT_KEY,params[1].get_str()));
-   
+    
     mc_Buffer *entity_rows=mc_gState->m_TmpBuffers->m_RpcEntityRows;
     entity_rows->Clear();
     
     mc_AdjustStartAndCount(&count,&start,pwalletTxsMain->GetListSize(&entity,entStat.m_Generation,NULL));
     
     Array retArray;
-    pwalletTxsMain->GetList(&entity,entStat.m_Generation,start+1,count,entity_rows);
+    CheckWalletError(pwalletTxsMain->GetList(&entity,entStat.m_Generation,start+1,count,entity_rows));
     
     for(int i=0;i<entity_rows->GetCount();i++)
     {
         mc_TxEntityRow *lpEntTx;
         lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
         uint256 hash;
-        int first_output=mc_GetHashAndFirstOutput(lpEntTx,&hash);
+        memcpy(&hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);
         const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-        Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,&conditions,NULL);
+        Object entry=StreamItemEntry(wtx,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose);
         if(entry.size())
         {
             retArray.push_back(entry);                                
@@ -1741,6 +1209,10 @@ Value liststreampublisheritems(const Array& params, bool fHelp)
     if (fHelp || params.size() < 2 || params.size() > 6)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -1808,29 +1280,24 @@ Value liststreampublisheritems(const Array& params, bool fHelp)
         throw JSONRPCError(RPC_NOT_SUBSCRIBED, "Not subscribed to this stream");                                
     }
 
-    string key_string=params[1].get_str();
     getSubKeyEntityFromPublisher(params[1].get_str(),entStat,&entity);
     
-    vector <mc_QueryCondition> conditions;
-
-    conditions.push_back(mc_QueryCondition(MC_QCT_PUBLISHER,params[1].get_str()));
-    
     mc_Buffer *entity_rows=mc_gState->m_TmpBuffers->m_RpcEntityRows;
     entity_rows->Clear();
     
     mc_AdjustStartAndCount(&count,&start,pwalletTxsMain->GetListSize(&entity,entStat.m_Generation,NULL));
     
     Array retArray;
-    pwalletTxsMain->GetList(&entity,entStat.m_Generation,start+1,count,entity_rows);
+    CheckWalletError(pwalletTxsMain->GetList(&entity,entStat.m_Generation,start+1,count,entity_rows));
     
     for(int i=0;i<entity_rows->GetCount();i++)
     {
         mc_TxEntityRow *lpEntTx;
         lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
         uint256 hash;
-        int first_output=mc_GetHashAndFirstOutput(lpEntTx,&hash);
+        memcpy(&hash,lpEntTx->m_TxId,MC_TDB_TXID_SIZE);
         const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-        Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,&conditions,NULL);
+        Object entry=StreamItemEntry(wtx,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose);
         if(entry.size())
         {
             retArray.push_back(entry);                                
@@ -1864,7 +1331,7 @@ Value liststreammap_operation(mc_TxEntity *parent_entity,vector<mc_TxEntity>& in
     {
         mc_AdjustStartAndCount(&count,&start,pwalletTxsMain->GetListSize(parent_entity,NULL));
         entity_rows->Clear();
-        pwalletTxsMain->GetList(parent_entity,start+1,count,entity_rows);
+        CheckWalletError(pwalletTxsMain->GetList(parent_entity,start+1,count,entity_rows));
         enitity_count=entity_rows->GetCount();
     }
     else
@@ -1908,17 +1375,13 @@ Value liststreammap_operation(mc_TxEntity *parent_entity,vector<mc_TxEntity>& in
         {
             shift=1;
         }
-        vector <mc_QueryCondition> conditions;
-
         if((parent_entity->m_EntityType & MC_TET_TYPE_MASK) == MC_TET_STREAM_PUBLISHER)
         {
-            all_entry.push_back(Pair("publisher", key_string));        
-            conditions.push_back(mc_QueryCondition(MC_QCT_PUBLISHER,key_string));
+            all_entry.push_back(Pair("publisher", key_string));                                                                                                                
         }
         else
         {
-            all_entry.push_back(Pair("key", key_string));         
-            conditions.push_back(mc_QueryCondition(MC_QCT_KEY,key_string));
+            all_entry.push_back(Pair("key", key_string));                                                                                            
         }
         all_entry.push_back(Pair("items", total));                                                                        
         all_entry.push_back(Pair("confirmed", confirmed));                                                                        
@@ -1937,13 +1400,12 @@ Value liststreammap_operation(mc_TxEntity *parent_entity,vector<mc_TxEntity>& in
                     if(pwalletTxsMain->GetRow(&erow) == 0)
                     {
                         uint256 hash;
-                        int first_output=mc_GetHashAndFirstOutput(&erow,&hash);                       
-//                        memcpy(&hash,erow.m_TxId,MC_TDB_TXID_SIZE);
+                        memcpy(&hash,erow.m_TxId,MC_TDB_TXID_SIZE);
                         const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
 
                         Value item_value;
 
-                        item_value=StreamItemEntry(wtx,first_output,parent_entity->m_EntityID,true,&conditions,NULL);
+                        item_value=StreamItemEntry(wtx,parent_entity->m_EntityID,true);
                         if(row == 1)
                         {
                             all_entry.push_back(Pair("first", item_value));                                                                        
@@ -2072,6 +1534,10 @@ Value liststreamkeys(const Array& params, bool fHelp)
     if (fHelp || params.size() < 1 || params.size() > 6)
         throw runtime_error("Help message not found\n");
     
+    if(mc_gState->m_Features->Streams() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
     if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
     {
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
@@ -2089,402 +1555,11 @@ Value liststreampublishers(const Array& params, bool fHelp)
         throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
     }   
     
-    return liststreamkeys_or_publishers(params,true);
-}
-
-int GetAndQueryDirtyList(vector<mc_QueryCondition>& conditions, mc_EntityDetails *stream_entity,bool fLocalOrdering,mc_Buffer *entity_rows)
-{
-    int i,row,out_row;
-    int conditions_count=(int)conditions.size();
-    int conditions_used=0;
-    int max_size=0;
-    int clean_count,dirty_count,last_state;
-    vector<mc_TxEntity> vConditionEntities;
-    vector<int> vConditionListSizes;
-    vector<int> vConditionMerged;
-    mc_TxEntityStat entStat;
-    bool merge_lists=true;
-    
-    vConditionEntities.resize(conditions_count+1);
-    vConditionListSizes.resize(conditions_count+1);
-    vConditionMerged.resize(conditions_count+1);
-    
-    entStat.Zero();
-    memcpy(&entStat,stream_entity->GetTxID()+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-    entStat.m_Entity.m_EntityType=MC_TET_STREAM;
-    if(fLocalOrdering)
-    {
-        entStat.m_Entity.m_EntityType |= MC_TET_TIMERECEIVED;
-    }
-    else
-    {
-        entStat.m_Entity.m_EntityType |= MC_TET_CHAINPOS;
-    }
-    if(!pwalletTxsMain->FindEntity(&entStat))
-    {
-        throw JSONRPCError(RPC_NOT_SUBSCRIBED, "Not subscribed to this stream");                                
-    }
-    
-    for(i=0;i<=conditions_count;i++)
-    {
-        vConditionEntities[i].Zero();
-        vConditionListSizes[i]=-1;
-        vConditionMerged[i]=0;
-        
-        entStat.m_Entity.m_EntityType &= MC_TET_ORDERMASK;
-        if(i<conditions_count)
-        {
-            switch(conditions[i].m_Type)
-            {
-                case MC_QCT_KEY:
-                    entStat.m_Entity.m_EntityType |= MC_TET_STREAM_KEY;
-                    getSubKeyEntityFromKey(conditions[i].m_Value,entStat,&vConditionEntities[i]);                
-                    break;
-                case MC_QCT_PUBLISHER:
-                    entStat.m_Entity.m_EntityType |= MC_TET_STREAM_PUBLISHER;
-                    getSubKeyEntityFromPublisher(conditions[i].m_Value,entStat,&vConditionEntities[i]);                
-                    break;
-            }
-        }
-        else
-        {
-            entStat.m_Entity.m_EntityType |= MC_TET_STREAM;
-            memcpy(&vConditionEntities[i],&entStat.m_Entity,sizeof(mc_TxEntity));
-        }
-        if(vConditionEntities[i].m_EntityType)
-        {
-            vConditionListSizes[i]=pwalletTxsMain->GetListSize(&vConditionEntities[i],entStat.m_Generation,NULL);     
-            if(vConditionListSizes[i]>max_size)
-            {
-                max_size=vConditionListSizes[i];
-            }
-        }
-    }
-    
-    clean_count=0;
-    dirty_count=0;
-    
-    while(merge_lists)
-    {
-        int min_size=max_size+1;
-        int min_condition=conditions_count;
-        for(i=0;i<=conditions_count;i++)
-        {
-            if(vConditionMerged[i] == 0)
-            {
-                if(vConditionListSizes[i]<=min_size)
-                {
-                    min_size=vConditionListSizes[i];
-                    min_condition=i;
-                }
-            }
-        }
-        
-        if(min_condition<conditions_count)
-        {
-            merge_lists=true;
-            if(conditions_used == 0)
-            {
-                if(min_size > MC_QPR_MAX_UNCHECKED_TX_LIST_SIZE)
-                {
-                    throw JSONRPCError(RPC_NOT_SUPPORTED, "This query may take too much time");                                                    
-                }          
-                pwalletTxsMain->GetList(&vConditionEntities[min_condition],entStat.m_Generation,1,min_size,entity_rows);         
-                conditions_used++;
-                clean_count=0;
-                dirty_count=0;
-                for(row=0;row<entity_rows->GetCount();row++)
-                {
-                    mc_TxEntityRow *lpEntTx;
-                    lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(row);
-                    lpEntTx->m_TempPos=0;
-                    if( (lpEntTx->m_Flags & MC_TFL_IS_EXTENSION) == 0 )
-                    {
-                        clean_count++;
-                    }
-                    if(!fLocalOrdering)
-                    {
-                        if(lpEntTx->m_Block == -1)
-                        {
-                            lpEntTx->m_Block=chainActive.Height()+1;
-                        }
-                    }
-                }
-            }
-            else
-            {
-                merge_lists=false;
-            }
-        }
-        else
-        {
-            merge_lists=false;            
-        }
-    }
-
-    last_state=2;
-    clean_count=0;
-    dirty_count=0;
-    out_row=0;
-    for(row=0;row<entity_rows->GetCount();row++)
-    {
-        mc_TxEntityRow *lpEntTx;
-        lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(row);
-        if(lpEntTx->m_Flags & MC_TFL_IS_EXTENSION)
-        {
-            lpEntTx->m_TempPos=last_state;
-            if(lpEntTx->m_TempPos == 2)
-            {
-                dirty_count++;                
-            }
-        }
-        else
-        {
-            switch(lpEntTx->m_TempPos)
-            {
-                case 1:
-                    break;
-                case 2:
-                    dirty_count++;
-                    break;
-                default:
-                    if(conditions_used < conditions_count)
-                    {
-                        lpEntTx->m_TempPos=2;
-                        dirty_count++;
-                    }
-                    else
-                    {
-                        clean_count++;
-                    }
-                    break;                    
-            }
-            last_state=lpEntTx->m_TempPos;
-        }
-        if(lpEntTx->m_TempPos != 1)
-        {
-            if(out_row < row)
-            {
-                memcpy(entity_rows->GetRow(out_row),lpEntTx,entity_rows->m_Size);
-            }
-            out_row++;
-        }
-    }
-    
-    entity_rows->SetCount(out_row);
-    
-    return dirty_count;
-}
-
-void FillContitionsList(vector<mc_QueryCondition>& conditions, Value param)
-{
-    bool key_found=false;
-    bool publisher_found=false;
-    bool field_parsed;
-    
-    if(param.type() != obj_type)
+    if(mc_gState->m_Features->Streams() == 0)
     {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid query, should be object ");                                                            
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
     }
-    
-    BOOST_FOREACH(const Pair& d, param.get_obj()) 
-    {
-        field_parsed=false;
-        if(d.name_ == "key")
-        {
-            if(key_found)
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Only one of the key fields can appear in the object");                                                            
-            }
-            if(d.value_.type()==str_type)
-            {
-                conditions.push_back(mc_QueryCondition(MC_QCT_KEY,d.value_.get_str()));
-            }
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid key, should be string");                                                            
-            }
-            field_parsed=true;
-            key_found=true;
-        }
-        
-        if(d.name_ == "keys")
-        {
-            if( mc_gState->m_Features->MultipleStreamKeys() == 0 )
-            {
-                throw JSONRPCError(RPC_NOT_SUPPORTED, "Multiple keys are not supported by this protocol version");                                                            
-            }
-            if(key_found)
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Only one of the key fields can appear in the object");                                                            
-            }
-            if(d.value_.type() == array_type)
-            {
-                for(int i=0;i<(int)d.value_.get_array().size();i++)
-                {
-                    if(d.value_.get_array()[i].type()==str_type)
-                    {
-                        conditions.push_back(mc_QueryCondition(MC_QCT_KEY,d.value_.get_array()[i].get_str()));
-                    }
-                    else
-                    {
-                        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid key, should be string");                                                            
-                    }
-                }                
-            }            
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid keys, should be array");                                                            
-            }
-            field_parsed=true;
-            key_found=true;
-        }
-
-        if(d.name_ == "publisher")
-        {
-            if(publisher_found)
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Only one of the publisher fields can appear in the object");                                                            
-            }
-            if(d.value_.type()==str_type)
-            {
-                conditions.push_back(mc_QueryCondition(MC_QCT_PUBLISHER,d.value_.get_str()));
-            }
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid publisher, should be string");                                                            
-            }
-            field_parsed=true;
-            publisher_found=true;
-        }
-
-        if(d.name_ == "publishers")
-        {
-            if(publisher_found)
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Only one of the publisher fields can appear in the object");                                                            
-            }
-            if(d.value_.type() == array_type)
-            {
-                for(int i=0;i<(int)d.value_.get_array().size();i++)
-                {
-                    if(d.value_.get_array()[i].type()==str_type)
-                    {
-                        conditions.push_back(mc_QueryCondition(MC_QCT_PUBLISHER,d.value_.get_array()[i].get_str()));
-                    }
-                    else
-                    {
-                        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid publisher, should be string");                                                            
-                    }
-                }                
-            }            
-            else
-            {
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid publishers, should be array");                                                            
-            }
-            field_parsed=true;
-            publisher_found=true;
-        }
-        
-        if(!field_parsed)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf("Invalid field: %s",d.name_.c_str()));                                                            
-        }
-
-    }        
+           
+    return liststreamkeys_or_publishers(params,true);
 }
 
-Value liststreamqueryitems(const Array& params, bool fHelp)
-{
-    if (fHelp || params.size() < 2 || params.size() > 3)
-        throw runtime_error("Help message not found\n");
-
-    if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
-    {
-        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. For full streams functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
-    }   
-
-    vector <mc_QueryCondition> conditions;
-    vector <mc_QueryCondition>* lpConditions;
-    
-    mc_EntityDetails stream_entity;
-    parseStreamIdentifier(params[0],&stream_entity);           
-
-    bool verbose=false;
-    int dirty_count,max_count;
-    
-    if (params.size() > 2)    
-    {
-        verbose=paramtobool(params[2]);
-    }
-    
-    FillContitionsList(conditions,params[1]);    
-
-    if(conditions.size() == 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid query, cannot be empty");                                                            
-    }
-    
-    mc_Buffer *entity_rows=mc_gState->m_TmpBuffers->m_RpcEntityRows;
-    entity_rows->Clear();
-    
-    dirty_count=GetAndQueryDirtyList(conditions,&stream_entity,false,entity_rows);
-    max_count=GetArg("-maxqueryscanitems",MAX_STREAM_QUERY_ITEMS);
-    if(dirty_count > max_count)
-    {
-        throw JSONRPCError(RPC_NOT_SUPPORTED, 
-                strprintf("This query requires decoding %d items, which is above the maxqueryscanitems limit of %d.",
-                dirty_count,max_count));     
-    }          
-    
-    if(entity_rows->GetCount() > max_count)
-    {
-        throw JSONRPCError(RPC_NOT_SUPPORTED, "Resulting list is too large");                                                            
-    }
-    
-    Array retArray;
-    int last_output;
-    uint256 last_hash=0;
-    for(int i=0;i<entity_rows->GetCount();i++)
-    {
-        mc_TxEntityRow *lpEntTx;
-        lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
-        lpConditions=NULL;
-        if(lpEntTx->m_TempPos != 1)
-        {
-            if(lpEntTx->m_TempPos == 2)
-            {
-                lpConditions=&conditions;
-            }
-            uint256 hash;
-            int first_output=mc_GetHashAndFirstOutput(lpEntTx,&hash);
-            if(last_hash == hash)
-            {
-                if(first_output <= last_output)
-                {
-                    first_output=-1;
-                }
-            }
-            else
-            {
-                last_output=-1;
-            }
-            last_hash=hash;
-            if(first_output >= 0)
-            {
-                const CWalletTx& wtx=pwalletTxsMain->GetWalletTx(hash,NULL,NULL);
-                Object entry=StreamItemEntry(wtx,first_output,stream_entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,verbose,lpConditions,&last_output);
-                if(entry.size())
-                {
-                    retArray.push_back(entry);                                
-                }                    
-                else
-                {
-                    last_output=-1;
-                }
-            }
-        }
-    }
-    
-    return retArray;
-}
diff --git a/src/rpc/rpcupgrades.cpp b/src/rpc/rpcupgrades.cpp
index 69a317e..158a46e 100644
--- a/src/rpc/rpcupgrades.cpp
+++ b/src/rpc/rpcupgrades.cpp
@@ -6,14 +6,18 @@
 
 
 #include "rpc/rpcwallet.h"
-bool AddParamNameValueToScript(const string  param_name,const Value param_value,mc_Script *lpDetailsScript,int version,int *errorCode,string *strError);
-int CreateUpgradeLists(int current_height,vector<mc_UpgradedParameter> *vParams,vector<mc_UpgradeStatus> *vUpgrades);
+#include "version/version.h"
 
 Value createupgradefromcmd(const Array& params, bool fHelp)
 {
     if (fHelp || params.size() < 5)
         throw runtime_error("Help message not found\n");
 
+    if(mc_gState->m_Features->Upgrades() == 0)
+    {
+        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported for this protocol version");        
+    }
+
     if (strcmp(params[1].get_str().c_str(),"upgrade"))
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid entity type, should be stream");
 
@@ -28,9 +32,7 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
     
     int ret,type;
     string upgrade_name="";
-    string strError="";
-    int errorCode=RPC_INVALID_PARAMETER;
-    
+
     if (params[2].type() != str_type)
         throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid upgrade name, should be string");
             
@@ -39,9 +41,12 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
         upgrade_name=params[2].get_str();
     }
         
-    if(upgrade_name == "*")
+    if(mc_gState->m_Features->Streams())
     {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid upgrade name: *");                                                                                            
+        if(upgrade_name == "*")
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid upgrade name: *");                                                                                            
+        }
     }
 
     unsigned char buf_a[MC_AST_ASSET_REF_SIZE];    
@@ -67,65 +72,6 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
         }        
     }
 
-    vector<CTxDestination> addresses;    
-    
-    vector<CTxDestination> fromaddresses;        
-    
-    if(params[0].get_str() != "*")
-    {
-        fromaddresses=ParseAddresses(params[0].get_str(),false,false);
-
-        if(fromaddresses.size() != 1)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
-        }
-
-        if( (IsMine(*pwalletMain, fromaddresses[0]) & ISMINE_SPENDABLE) != ISMINE_SPENDABLE )
-        {
-            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
-        }
-        
-        set<CTxDestination> thisFromAddresses;
-
-        BOOST_FOREACH(const CTxDestination& fromaddress, fromaddresses)
-        {
-            thisFromAddresses.insert(fromaddress);
-        }
-
-        CPubKey pkey;
-        if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_CREATE | MC_PTP_ADMIN,&thisFromAddresses))
-        {
-            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have create or admin permission");                
-        }   
-    }
-    else
-    {
-        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)
-        {
-            const CBitcoinAddress& address = item.first;
-            CKeyID keyID;
-
-            if(address.GetKeyID(keyID))
-            {
-                if( IsMine(*pwalletMain, keyID) & ISMINE_SPENDABLE )
-                {
-                    if(mc_gState->m_Permissions->CanCreate(NULL,(unsigned char*)(&keyID)))
-                    {
-                        if(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)(&keyID)))
-                        {
-                            fromaddresses.push_back(keyID);
-                        }
-                    }
-                }
-            }
-        }                    
-        CPubKey pkey;
-        if(fromaddresses.size() == 0)
-        {
-            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "This wallet doesn't have keys with create and admin permission");                
-        }        
-    }
-    
     lpScript->Clear();
     
     lpDetails->Clear();
@@ -144,10 +90,6 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
     bool protocol_version_found=false;
     int protocol_version;
     int start_block;
-    CScript scriptOpReturn=CScript();
-    
-    lpDetailsScript->Clear();
-    lpDetailsScript->AddElement();                   
 
     if(params[4].type() == obj_type)
     {
@@ -158,31 +100,22 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
             {
                 if(s.value_.type() != int_type)
                 {
-                    strError="Invalid protocol version, expecting integer";
-                    goto exitlbl;
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid protocol version, expecting integer");                                                                
                 }
                 protocol_version_found=true;
                 protocol_version=s.value_.get_int();
-                if( (protocol_version < mc_gState->MinProtocolVersion()) || 
-                    ( -mc_gState->VersionInfo(protocol_version) != mc_gState->GetNumericVersion() ) )
+                if(protocol_version < 0)
                 {
-                    strError=strprintf("Invalid value for protocol version. Valid range: %s\n",mc_SupportedProtocols().c_str());
-                    goto exitlbl;
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid protocol version, should be non-negative");                                                                                    
                 }
-                
-                if( protocol_version < mc_gState->MinProtocolDowngradeVersion() )
+                if(protocol_version > mc_gState->GetProtocolVersion())
                 {
-                    strError="Invalid protocol version, cannot downgrade to this version";
-                    goto exitlbl;
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid protocol version, cannot upgrade to future version");                                                                                    
                 }
-                if( mc_gState->m_NetworkParams->ProtocolVersion() >= mc_gState->MinProtocolForbiddenDowngradeVersion() )
+
+                if(protocol_version < MULTICHAIN_MIN_DOWNGRADE_PROTOCOL_VERSION)
                 {
-                    if(protocol_version < mc_gState->m_NetworkParams->ProtocolVersion())
-                    {
-                        strError="Invalid protocol version, cannot downgrade from current version";
-                        errorCode=RPC_NOT_ALLOWED;
-                        goto exitlbl;
-                    }                    
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid protocol version, cannot downgrade to this version");                                                                                    
                 }
                 lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,(unsigned char*)&protocol_version,4);        
             }
@@ -192,91 +125,114 @@ Value createupgradefromcmd(const Array& params, bool fHelp)
                 {
                     if(s.value_.type() != int_type)
                     {
-                        strError="Invalid start block, expecting integer";
-                        goto exitlbl;
+                        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid start block, expecting integer");                                                                
                     }
                     start_block=s.value_.get_int();
                     lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_START_BLOCK,(unsigned char*)&start_block,4);        
                 }                    
                 else
                 {
-                    if(mc_gState->m_Features->ParameterUpgrades())
-                    {                        
-                        if(!AddParamNameValueToScript(s.name_,s.value_,lpDetailsScript,0,&errorCode,&strError))
-                        {
-                            goto exitlbl;
-                        }
-                    }
-                    else
-                    {
-                        strError="Some upgrade parameters are not supported by the current protocol, please upgrade protocol separately first.";
-                        goto exitlbl;
-                    }
+                    throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid parameter name");                                                                
 //                    lpDetails->SetParamValue(s.name_.c_str(),s.name_.size(),(unsigned char*)s.value_.get_str().c_str(),s.value_.get_str().size());                                        
                 }
             }                
         }
-        
     }
     else
     {
-        strError="Invalid custom fields, expecting object";
-        goto exitlbl;
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields, expecting object");                                        
     }
 
-    size_t bytes;
-    const unsigned char *script;
-    
-    script = lpDetailsScript->GetData(0,&bytes);
-    if( !protocol_version_found && (bytes == 0) )
-    {        
-        strError="Missing protocol-version";
-        if(mc_gState->m_Features->ParameterUpgrades())
-        {
-            strError+=" or other parameters";
-        }
-        
-        goto exitlbl;
-    }
-    
-    if(bytes)
+    if(!protocol_version_found)
     {
-        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_CHAIN_PARAMS,script,bytes);                                                        
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "protocol-version is required");                                                
     }
     
     
+    size_t bytes;
+    const unsigned char *script;
     script=lpDetails->GetData(0,&bytes);
     
-
     int err;
     size_t elem_size;
     const unsigned char *elem;
+    CScript scriptOpReturn=CScript();
     
     lpDetailsScript->Clear();
     err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_UPGRADE,0,script,bytes);
     if(err)
     {
-        strError="Invalid custom fields or upgrade name, too long";
-        goto exitlbl;
+        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid custom fields or upgrade name, too long");                                                        
     }
 
     elem = lpDetailsScript->GetData(0,&elem_size);
     scriptOpReturn << vector<unsigned char>(elem, elem + elem_size) << OP_DROP << OP_RETURN;        
     
+    vector<CTxDestination> addresses;    
+    
+    vector<CTxDestination> fromaddresses;        
     
-    EnsureWalletIsUnlocked();
+    if(params[0].get_str() != "*")
     {
-        LOCK (pwalletMain->cs_wallet_send);
+        fromaddresses=ParseAddresses(params[0].get_str(),false,false);
 
-        SendMoneyToSeveralAddresses(addresses, 0, wtx, lpScript, scriptOpReturn,fromaddresses);
-    }
+        if(fromaddresses.size() != 1)
+        {
+            throw JSONRPCError(RPC_INVALID_PARAMETER, "Single from-address should be specified");                        
+        }
+
+        if( (IsMine(*pwalletMain, fromaddresses[0]) & ISMINE_SPENDABLE) != ISMINE_SPENDABLE )
+        {
+            throw JSONRPCError(RPC_WALLET_ADDRESS_NOT_FOUND, "Private key for from-address is not found in this wallet");                        
+        }
         
-exitlbl:
+        set<CTxDestination> thisFromAddresses;
+
+        BOOST_FOREACH(const CTxDestination& fromaddress, fromaddresses)
+        {
+            thisFromAddresses.insert(fromaddress);
+        }
 
-    if(strError.size())
+        CPubKey pkey;
+        if(!pwalletMain->GetKeyFromAddressBook(pkey,MC_PTP_CREATE | MC_PTP_ADMIN,&thisFromAddresses))
+        {
+            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "from-address doesn't have create or admin permission");                
+        }   
+    }
+    else
     {
-        throw JSONRPCError(errorCode, strError);                        
+        BOOST_FOREACH(const PAIRTYPE(CBitcoinAddress, CAddressBookData)& item, pwalletMain->mapAddressBook)
+        {
+            const CBitcoinAddress& address = item.first;
+            CKeyID keyID;
+
+            if(address.GetKeyID(keyID))
+            {
+                if( IsMine(*pwalletMain, keyID) & ISMINE_SPENDABLE )
+                {
+                    if(mc_gState->m_Permissions->CanCreate(NULL,(unsigned char*)(&keyID)))
+                    {
+                        if(mc_gState->m_Permissions->CanAdmin(NULL,(unsigned char*)(&keyID)))
+                        {
+                            fromaddresses.push_back(keyID);
+                        }
+                    }
+                }
+            }
+        }                    
+        CPubKey pkey;
+        if(fromaddresses.size() == 0)
+        {
+            throw JSONRPCError(RPC_INSUFFICIENT_PERMISSIONS, "This wallet doesn't have keys with create and admin permission");                
+        }        
     }
+    
+    
+    EnsureWalletIsUnlocked();
+    LOCK (pwalletMain->cs_wallet_send);
+    
+    SendMoneyToSeveralAddresses(addresses, 0, wtx, lpScript, scriptOpReturn,fromaddresses);
+ 
     return wtx.GetHash().GetHex();    
 }
 
@@ -307,17 +263,6 @@ Value approvefrom(const json_spirit::Array& params, bool fHelp)
     mc_EntityDetails entity;
     entity.Zero();
     ParseEntityIdentifier(entity_identifier,&entity, MC_ENT_TYPE_UPGRADE);           
-
-    if( mc_gState->m_NetworkParams->ProtocolVersion() >= mc_gState->MinProtocolForbiddenDowngradeVersion() )
-    {
-        if(entity.UpgradeProtocolVersion())
-        {
-            if(entity.UpgradeProtocolVersion() < mc_gState->m_NetworkParams->ProtocolVersion())
-            {
-                throw JSONRPCError(RPC_NOT_ALLOWED, "Invalid protocol version, cannot downgrade from current version");
-            }                    
-        }
-    }
     
     if(mc_gState->m_Permissions->IsApproved(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET,0))
     {
@@ -388,8 +333,6 @@ Value listupgrades(const json_spirit::Array& params, bool fHelp)
     Array results;
     mc_Buffer *upgrades;
     
-    set<uint160> inputUpgrades;
-    
     upgrades=NULL;
     
    
@@ -414,157 +357,155 @@ Value listupgrades(const json_spirit::Array& params, bool fHelp)
         }
     }
     
-    for(int is=0;is<(int)inputStrings.size();is++)
+    
+    if(inputStrings.size())
     {
-        string param=inputStrings[is];
-
-        mc_EntityDetails upgrade_entity;
-        ParseEntityIdentifier(param,&upgrade_entity, MC_ENT_TYPE_UPGRADE);           
+        {
+            LOCK(cs_main);
+            for(int is=0;is<(int)inputStrings.size();is++)
+            {
+                string param=inputStrings[is];
 
-        uint160 hash=0;
-        memcpy(&hash,upgrade_entity.GetTxID() + MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-        inputUpgrades.insert(hash);
+                mc_EntityDetails upgrade_entity;
+                ParseEntityIdentifier(param,&upgrade_entity, MC_ENT_TYPE_UPGRADE);           
+                
+                upgrades=mc_gState->m_Permissions->GetUpgradeList(upgrade_entity.GetTxID() + MC_AST_SHORT_TXID_OFFSET,upgrades);
+            }
+        }
     }
+    else
+    {        
+        {
+            LOCK(cs_main);
+            upgrades=mc_gState->m_Permissions->GetUpgradeList(NULL,upgrades);
+        }
+    }
+    
+    if(upgrades == NULL)
+        throw JSONRPCError(RPC_INTERNAL_ERROR, "Cannot open entity database");
 
-    vector<mc_UpgradedParameter> vParams;
-    vector<mc_UpgradeStatus> vUpgrades;
-    uint32_t current_height=chainActive.Height();
-    CreateUpgradeLists(chainActive.Height(),&vParams,&vUpgrades);
-
-    for(int u=0;u<(int)vUpgrades.size();u++)
+    set <uint160> stored_upgrades;
+    map <uint64_t,int> map_sorted;
+    uint160 hash;
+    
+    for(int i=0;i<upgrades->GetCount();i++)
+    {
+        mc_PermissionDetails *plsRow;
+        plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
+        if(plsRow->m_Type == MC_PTP_UPGRADE)
+        {            
+            memcpy(&hash,plsRow->m_Address,sizeof(uint160));
+            stored_upgrades.insert(hash);
+            map_sorted.insert(std::make_pair(plsRow->m_LastRow,i));
+        }        
+    }   
+    for(int i=0;i<upgrades->GetCount();i++)
+    {
+        mc_PermissionDetails *plsRow;
+        plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
+        if(plsRow->m_Type != MC_PTP_UPGRADE)
+        {
+            memcpy(&hash,plsRow->m_Address,sizeof(uint160));
+            if(stored_upgrades.count(hash) == 0)
+            {
+//                plsRow->m_Type = MC_PTP_UPGRADE;
+                plsRow->m_BlockTo = 0;
+                map_sorted.insert(std::make_pair(plsRow->m_LastRow,i));
+            }
+        }
+    }    
+    
+    BOOST_FOREACH(PAIRTYPE(const uint64_t, int)& item, map_sorted)
     {
+        int i=item.second;
         Object entry;
-        Object applied_params;
-        Object skipped_params;
         mc_PermissionDetails *plsRow;
         mc_PermissionDetails *plsDet;
         mc_EntityDetails upgrade_entity;
-        int consensus;
-        Value null_value;
-        string param_name;
-        
-        uint160 hash=0;
-        memcpy(&hash,vUpgrades[u].m_EntityShortTxID,sizeof(uint160));
+        bool take_it,approved;
+        int flags,consensus,remaining;
+        plsRow=(mc_PermissionDetails *)(upgrades->GetRow(i));
         
-        if( (inputUpgrades.size() == 0) || (inputUpgrades.count(hash) > 0) )
-        {
-            upgrade_entity.Zero();
-            mc_gState->m_Assets->FindEntityByShortTxID(&upgrade_entity,vUpgrades[u].m_EntityShortTxID);
-            entry=UpgradeEntry(upgrade_entity.GetTxID());
-
-            entry.push_back(Pair("approved", (vUpgrades[u].m_ApprovedBlock <= current_height+1)));            
+        upgrade_entity.Zero();
+        mc_gState->m_Assets->FindEntityByShortTxID(&upgrade_entity,plsRow->m_Address);
 
-            for(uint32_t p=vUpgrades[u].m_FirstParam;p<vUpgrades[u].m_LastParam;p++)
+        entry=UpgradeEntry(upgrade_entity.GetTxID());
+        approved=true;
+        if(plsRow->m_BlockFrom >= plsRow->m_BlockTo)
+        {
+            approved=false;  
+            entry.push_back(Pair("approved", false));            
+            Value null_value;
+            entry.push_back(Pair("appliedblock",null_value));            
+        }
+        else
+        {
+            entry.push_back(Pair("approved", true));
+            int current_height=chainActive.Height();     
+            int applied_height=upgrade_entity.UpgradeStartBlock();
+            if((int)plsRow->m_BlockReceived > applied_height)
             {
-                param_name=string(vParams[p].m_Param->m_DisplayName);
-                if(vParams[p].m_Skipped == MC_PSK_APPLIED)
-                {                
-                    if(vParams[p].m_Param->m_Type & MC_PRM_DECIMAL)
-                    {
-                        applied_params.push_back(Pair(param_name,mc_gState->m_NetworkParams->Int64ToDecimal(vParams[p].m_Value)));            
-                    }
-                    else
-                    {
-                        switch(vParams[p].m_Param->m_Type & MC_PRM_DATA_TYPE_MASK)
-                        {
-                            case MC_PRM_BOOLEAN:
-                                applied_params.push_back(Pair(param_name,(vParams[p].m_Value != 0)));            
-                                break;
-                            case MC_PRM_INT32:
-                                applied_params.push_back(Pair(param_name,(int)vParams[p].m_Value));            
-                            case MC_PRM_UINT32:
-                            case MC_PRM_INT64:
-                                applied_params.push_back(Pair(param_name,vParams[p].m_Value));            
-                                break;
-                        }                                
-                    }
-                }
-                else
-                {
-                    string param_err;
-                    switch(vParams[p].m_Skipped)
-                    {
-                        case MC_PSK_INTERNAL_ERROR:         param_err="Parameter not applied because of internal error, please report this"; break;
-                        case MC_PSK_NOT_FOUND:              param_err="Parameter name not recognized"; break;
-                        case MC_PSK_WRONG_SIZE:             param_err="Parameter is encoded with wrong size"; break;
-                        case MC_PSK_OUT_OF_RANGE:           param_err="Parameter value is out of range"; break;
-                        case MC_PSK_FRESH_UPGRADE:          param_err=strprintf("Parameter is upgraded less than %d blocks ago",MIN_BLOCKS_BETWEEN_UPGRADES); break;
-                        case MC_PSK_DOUBLE_RANGE:           param_err="New parameter value must be between half and double previous value"; break;
-                        case MC_PSK_NOT_SUPPORTED:          param_err="This parameter cannot be upgraded in this protocol version"; break;
-                        case MC_PSK_NEW_NOT_DOWNGRADABLE:   param_err="Cannot downgrade to this version"; break;
-                        case MC_PSK_OLD_NOT_DOWNGRADABLE:   param_err="Downgrades are not allowed in this protocol version"; break;
-                        default:                            param_err="Parameter not applied because of internal error, please report this"; break;
-                    }
-                    skipped_params.push_back(Pair(param_name,param_err));            
-                }
+                applied_height=plsRow->m_BlockReceived;
             }
-
-            if(vUpgrades[u].m_AppliedBlock <= current_height)
+            if(current_height >=applied_height)
             {
-                entry.push_back(Pair("appliedblock", (int64_t)vUpgrades[u].m_AppliedBlock));                  
-                entry.push_back(Pair("appliedparams", applied_params));                  
-                entry.push_back(Pair("skippedparams", skipped_params));                  
+                entry.push_back(Pair("appliedblock",(int64_t)applied_height));                            
             }
             else
             {
-                entry.push_back(Pair("appliedblock", null_value));                  
-                entry.push_back(Pair("appliedparams", null_value));                              
-                entry.push_back(Pair("skippedparams", null_value));                  
+                Value null_value;
+                entry.push_back(Pair("appliedblock",null_value));                            
             }
+        }
+        
+        take_it=true;
+        flags=plsRow->m_Flags;
+        consensus=plsRow->m_RequiredAdmins;
 
-            upgrades=mc_gState->m_Permissions->GetUpgradeList(upgrade_entity.GetTxID() + MC_AST_SHORT_TXID_OFFSET,upgrades);
-            if(upgrades->GetCount())
-            {
-                plsRow=(mc_PermissionDetails *)(upgrades->GetRow(upgrades->GetCount()-1));
-                consensus=plsRow->m_RequiredAdmins;
-                if(plsRow->m_Type != MC_PTP_UPGRADE)
-                {
-                    plsRow->m_BlockTo=0;
-                }
-
-                Array admins;
-                Array pending;
-                mc_Buffer *details;
+        if(take_it)
+        {
+            Array admins;
+            Array pending;
+            mc_Buffer *details;
 
-                if(plsRow->m_Type == MC_PTP_UPGRADE)
-                {
-                    details=mc_gState->m_Permissions->GetPermissionDetails(plsRow);                            
-                }
-                else
-                {
-                    details=NULL;
-                }
+            if(plsRow->m_Type == MC_PTP_UPGRADE)
+            {
+                details=mc_gState->m_Permissions->GetPermissionDetails(plsRow);                            
+            }
+            else
+            {
+                details=NULL;
+            }
 
-                if(details)
-                {             
-                    for(int j=0;j<details->GetCount();j++)
-                    {
-                        plsDet=(mc_PermissionDetails *)(details->GetRow(j));
-                        if(plsDet->m_BlockFrom < plsDet->m_BlockTo)
-                        {
-                            uint160 addr;
-                            memcpy(&addr,plsDet->m_LastAdmin,sizeof(uint160));
-                            CKeyID lpKeyID=CKeyID(addr);
-                            admins.push_back(CBitcoinAddress(lpKeyID).ToString());                                                
-                        }
-                    }                    
-                    consensus=plsRow->m_RequiredAdmins;
-                }
-                if(admins.size() == 0)
+            if(details)
+            {             
+                for(int j=0;j<details->GetCount();j++)
                 {
-                    if(plsRow->m_BlockFrom < plsRow->m_BlockTo)
+                    plsDet=(mc_PermissionDetails *)(details->GetRow(j));
+                    remaining=plsDet->m_RequiredAdmins;
+                    if(plsDet->m_BlockFrom < plsDet->m_BlockTo)
                     {
                         uint160 addr;
-                        memcpy(&addr,plsRow->m_LastAdmin,sizeof(uint160));
+                        memcpy(&addr,plsDet->m_LastAdmin,sizeof(uint160));
                         CKeyID lpKeyID=CKeyID(addr);
-                        admins.push_back(CBitcoinAddress(lpKeyID).ToString());                                                                    
-                    }                
-                }
-
-                entry.push_back(Pair("admins", admins));
-                entry.push_back(Pair("required", (int64_t)(consensus-admins.size())));
+                        admins.push_back(CBitcoinAddress(lpKeyID).ToString());                                                
+                    }
+                }                    
+                consensus=plsRow->m_RequiredAdmins;
             }
-            upgrades->Clear();
+            if(admins.size() == 0)
+            {
+                if(plsRow->m_BlockFrom < plsRow->m_BlockTo)
+                {
+                    uint160 addr;
+                    memcpy(&addr,plsRow->m_LastAdmin,sizeof(uint160));
+                    CKeyID lpKeyID=CKeyID(addr);
+                    admins.push_back(CBitcoinAddress(lpKeyID).ToString());                                                                    
+                }                
+            }
+            
+            entry.push_back(Pair("admins", admins));
+            entry.push_back(Pair("required", (int64_t)(consensus-admins.size())));
             results.push_back(entry);
         }
     }
@@ -574,4 +515,3 @@ Value listupgrades(const json_spirit::Array& params, bool fHelp)
     return results;
 }
 
-
diff --git a/src/rpc/rpcutils.cpp b/src/rpc/rpcutils.cpp
index a3b2e5a..c90279a 100644
--- a/src/rpc/rpcutils.cpp
+++ b/src/rpc/rpcutils.cpp
@@ -12,33 +12,17 @@
 #include "utils/util.h"
 #include "utils/utilmoneystr.h"
 #include "wallet/wallettxs.h"
-#include "json/json_spirit_ubjson.h"
 
 #include <boost/assign/list_of.hpp>
 
 using namespace std;
 using namespace json_spirit;
 
-uint256 hGenesisCoinbaseTxID=0;
+int MAX_FORMATTED_DATA_DEPTH=100;
+
+Value ubjson_read(const unsigned char *elem,size_t elem_size,int max_depth,int *err);
 
-int c_UTF8_charlen[256]={
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
- 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
- 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
- 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
- 4,4,4,4,4,4,4,4,5,5,5,5,6,6,0,0
-};
+uint256 hGenesisCoinbaseTxID=0;
 
 CScript RemoveOpDropsIfNeeded(const CScript& scriptInput)
 {
@@ -143,6 +127,23 @@ Value mc_ExtractDetailsJSONObject(const unsigned char *script,uint32_t total)
     return value;
 }
 
+void CheckWalletError(int err)
+{
+    if(err)
+    {
+        switch(err)
+        {
+            case MC_ERR_NOT_SUPPORTED:
+                throw JSONRPCError(RPC_NOT_SUPPORTED, "This feature is not supported in this build");                                        
+                break;
+            case MC_ERR_INTERNAL_ERROR:
+                throw JSONRPCError(RPC_INTERNAL_ERROR, "Internal wallet error");                                        
+                break;
+            default:
+                break;
+        }
+    }
+}
 
 int ParseAssetKey(const char* asset_key,unsigned char *txid,unsigned char *asset_ref,char *name,int *multiple,int *type,int entity_type)
 {
@@ -275,15 +276,22 @@ int ParseAssetKey(const char* asset_key,unsigned char *txid,unsigned char *asset
 int ParseAssetKeyToFullAssetRef(const char* asset_key,unsigned char *full_asset_ref,int *multiple,int *type,int entity_type)
 {
     int ret;
-    unsigned char txid[MC_ENT_KEY_SIZE];
-    ret=ParseAssetKey(asset_key,txid,NULL,NULL,multiple,type,entity_type);
-    if(ret == MC_ASSET_KEY_UNCONFIRMED_GENESIS)
+    if(mc_gState->m_Features->ShortTxIDInTx())
+    {
+        unsigned char txid[MC_ENT_KEY_SIZE];
+        ret=ParseAssetKey(asset_key,txid,NULL,NULL,multiple,type,entity_type);
+        if(ret == MC_ASSET_KEY_UNCONFIRMED_GENESIS)
+        {
+            ret=0;
+        }
+        memcpy(full_asset_ref+MC_AST_SHORT_TXID_OFFSET,txid+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        
+        mc_SetABRefType(full_asset_ref,MC_AST_ASSET_REF_TYPE_SHORT_TXID);        
+    }
+    else
     {
-        ret=0;
+        ret=ParseAssetKey(asset_key,NULL,full_asset_ref,NULL,multiple,type,entity_type);        
     }
-    memcpy(full_asset_ref+MC_AST_SHORT_TXID_OFFSET,txid+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
-
-    mc_SetABRefType(full_asset_ref,MC_AST_ASSET_REF_TYPE_SHORT_TXID);        
     return ret;
 }
 
@@ -439,42 +447,6 @@ Value PermissionForFieldEntry(mc_EntityDetails *lpEntity)
     return Value::null;
 }
 
-Array PerOutputDataEntries(const CTxOut& txout,mc_Script *lpScript,uint256 txid,int vout)
-{
-    Array results;
-    unsigned char *ptr;
-    int size;
-    
-    if(mc_gState->m_NetworkParams->IsProtocolMultichain() == 0)
-    {
-        return results;
-    }    
-    
-    const CScript& script1 = txout.scriptPubKey;        
-    CScript::const_iterator pc1 = script1.begin();
-
-    lpScript->Clear();
-    lpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-    
-    for (int e = 0; e < lpScript->GetNumElements(); e++)
-    {
-        lpScript->SetElement(e);
-        if(lpScript->GetRawData(&ptr,&size) == 0)      
-        {
-            uint32_t format=MC_SCR_DATA_FORMAT_UNKNOWN;
-            if(e > 0)
-            {
-                lpScript->SetElement(e-1);
-                lpScript->GetDataFormat(&format);
-            }
-            results.push_back(OpReturnFormatEntry(ptr,size,txid,vout,format,NULL));            
-        }        
-    }
-    
-    return results;
-}
-
-
 Array PermissionEntries(const CTxOut& txout,mc_Script *lpScript,bool fLong)
 {
     Array results;
@@ -515,13 +487,15 @@ Array PermissionEntries(const CTxOut& txout,mc_Script *lpScript,bool fLong)
             {                
                 Object entry;
                 entry.push_back(Pair("for", PermissionForFieldEntry(&entity)));            
-//                full_type=mc_gState->m_Permissions->GetPossiblePermissionTypes(entity.GetEntityType());
-                full_type=mc_gState->m_Permissions->GetPossiblePermissionTypes(&entity);
+                full_type=mc_gState->m_Permissions->GetPossiblePermissionTypes(entity.GetEntityType());
                 if(full_type & MC_PTP_CONNECT)entry.push_back(Pair("connect", (type & MC_PTP_CONNECT) ? true : false));
                 if(full_type & MC_PTP_SEND)entry.push_back(Pair("send", (type & MC_PTP_SEND) ? true : false));
                 if(full_type & MC_PTP_RECEIVE)entry.push_back(Pair("receive", (type & MC_PTP_RECEIVE) ? true : false));
-                if(full_type & MC_PTP_WRITE)entry.push_back(Pair("write", (type & MC_PTP_WRITE) ? true : false));                
-                if(full_type & MC_PTP_CREATE)entry.push_back(Pair("create", (type & MC_PTP_CREATE) ? true : false));                
+                if(mc_gState->m_Features->Streams())
+                {
+                    if(full_type & MC_PTP_WRITE)entry.push_back(Pair("write", (type & MC_PTP_WRITE) ? true : false));                
+                    if(full_type & MC_PTP_CREATE)entry.push_back(Pair("create", (type & MC_PTP_CREATE) ? true : false));                
+                }
                 if(full_type & MC_PTP_ISSUE)entry.push_back(Pair("issue", (type & MC_PTP_ISSUE) ? true : false));
                 if(full_type & MC_PTP_MINE)entry.push_back(Pair("mine", (type & MC_PTP_MINE) ? true : false));
                 if(full_type & MC_PTP_ADMIN)entry.push_back(Pair("admin", (type & MC_PTP_ADMIN) ? true : false));
@@ -617,27 +591,16 @@ Object StreamEntry(const unsigned char *txid,uint32_t output_level)
 
         if(output_level & 0x0004)
         {
-            if(mc_gState->m_Compatibility & MC_VCM_1_0)
-            {            
-                if(entity.AnyoneCanWrite())
-                {
-                    entry.push_back(Pair("open",true));                                
-                }
-                else
-                {
-                    entry.push_back(Pair("open",false));                                            
-                }
+            if(entity.AnyoneCanWrite())
+            {
+                entry.push_back(Pair("open",true));                                
             }
-            Object pObject;
-            pObject.push_back(Pair("write",entity.AnyoneCanWrite() ? false : true));
-            if(mc_gState->m_Features->OffChainData())
+            else
             {
-                pObject.push_back(Pair("onchain",(entity.Restrictions() & MC_ENT_ENTITY_RESTRICTION_ONCHAIN) ? true : false));
-                pObject.push_back(Pair("offchain",(entity.Restrictions() & MC_ENT_ENTITY_RESTRICTION_OFFCHAIN) ? true : false));
+                entry.push_back(Pair("open",false));                                            
             }
-            entry.push_back(Pair("restrict",pObject));                                            
         }
-       
+        
         
         size_t value_size;
         int64_t offset,new_offset;
@@ -764,64 +727,6 @@ Object StreamEntry(const unsigned char *txid,uint32_t output_level)
     return entry;
 }
 
-map<string, Value> ParamsToUpgrade(mc_EntityDetails *entity,int version)   
-{
-    map<string, Value> result;
-    int size=0;
-    const mc_OneMultichainParam *param;
-    char* ptr=(char*)entity->GetParamUpgrades(&size);
-    char* ptrEnd;
-    string param_name;
-    int param_size,given_size;
-    int64_t param_value;
-    if(ptr)
-    {
-        ptrEnd=ptr+size;
-        while(ptr<ptrEnd)
-        {
-            param=mc_gState->m_NetworkParams->FindParam(ptr);
-            ptr+=mc_gState->m_NetworkParams->GetParamFromScript(ptr,&param_value,&given_size);
-            
-            if(strcmp(ptr,"protocolversion"))
-            {        
-                if(param)
-                {
-                    param_size=mc_gState->m_NetworkParams->CanBeUpgradedByVersion(param->m_Name,version,0);
-                    if( (param_size > 0) && (param_size == given_size) )
-                    {
-                        param_name=string(param->m_DisplayName);
-                        if(result.find(param_name) == result.end())
-                        {
-                            if(param->m_Type & MC_PRM_DECIMAL)
-                            {
-                                result.insert(make_pair(param_name, mc_gState->m_NetworkParams->Int64ToDecimal(param_value)));
-                            }
-                            else
-                            {
-                                switch(param->m_Type & MC_PRM_DATA_TYPE_MASK)
-                                {
-                                    case MC_PRM_BOOLEAN:
-                                        result.insert(make_pair(param_name, (param_value != 0) ));
-                                        break;
-                                    case MC_PRM_INT32:
-                                        result.insert(make_pair(param_name, (int)param_value));
-                                    case MC_PRM_UINT32:
-                                    case MC_PRM_INT64:
-                                        result.insert(make_pair(param_name, param_value));
-                                        break;
-                                }                                
-                            }
-                        }
-                    }
-                }
-            }
-        }
-    }
-        
-    return result;    
-}
-
-
 Object UpgradeEntry(const unsigned char *txid)
 {
     Object entry;
@@ -847,15 +752,7 @@ Object UpgradeEntry(const unsigned char *txid)
         }
         entry.push_back(Pair("createtxid", hash.GetHex()));
         Object fields;
-        map<string, Value> params_to_upgrade=ParamsToUpgrade(&entity,0);
-        if(entity.UpgradeProtocolVersion())
-        {
-            fields.push_back(Pair("protocol-version",entity.UpgradeProtocolVersion()));                    
-        }
-        for(map<string,Value>::iterator it = params_to_upgrade.begin(); it != params_to_upgrade.end(); ++it) 
-        {
-            fields.push_back(Pair(it->first, it->second));  
-        }
+        fields.push_back(Pair("protocol-version",entity.UpgradeProtocolVersion()));                    
         entry.push_back(Pair("params",fields));      
         entry.push_back(Pair("startblock",(int64_t)entity.UpgradeStartBlock()));                    
         
@@ -886,402 +783,18 @@ Value OpReturnEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int
     return metadata_object;    
 }
 
-string OpReturnFormatToText(int format)
-{
-    switch(format)
-    {
-        case MC_SCR_DATA_FORMAT_UTF8:
-            return "text";
-        case MC_SCR_DATA_FORMAT_UBJSON:
-            return "json";            
-    }
-    return "raw";
-}
-
-int mc_IsUTF8(const unsigned char *elem,size_t elem_size)
-{
-    unsigned char *ptr=(unsigned char *)elem;
-    unsigned char *ptrEnd=ptr+elem_size;
-    int size;
-    while(ptr<ptrEnd)
-    {
-        size=c_UTF8_charlen[*ptr];
-        if(size==0)
-        {
-            return 0;
-        }
-        ptr+=size;
-    }
-    if(ptr>ptrEnd)
-    {
-        return 0;        
-    }
-    return 1;
-}
-
-const unsigned char *GetChunkDataInRange(int64_t *out_size,unsigned char* hashes,int chunk_count,int64_t start,int64_t count)
-{
-    mc_ChunkDBRow chunk_def;
-    int size,shift,chunk;
-    unsigned char *ptr;
-    size_t elem_size;
-    int64_t total_size=0;
-    unsigned char *elem;
-    int64_t read_from,read_size;
-
-    mc_gState->m_TmpBuffers->m_RpcChunkScript1->Clear();
-    mc_gState->m_TmpBuffers->m_RpcChunkScript1->AddElement();
-    
-    *out_size=0;
-    
-    ptr=hashes;
-    for(chunk=0;chunk<chunk_count;chunk++)
-    {
-        size=(int)mc_GetVarInt(ptr,MC_CDB_CHUNK_HASH_SIZE+16,-1,&shift);
-
-        if(size<0)
-        {
-            return NULL;
-        }
-        
-        if(size > MAX_CHUNK_SIZE)
-        {
-            return NULL;
-        }
-        
-        
-        ptr+=shift;
-        if(pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,ptr,NULL,NULL,-1) == MC_ERR_NOERROR)
-        {
-            read_from=0;
-            read_size=chunk_def.m_Size;
-            if( (total_size+read_size > start) && (total_size < start+count) )
-            {
-                if(total_size < start)
-                {
-                    read_from=start-total_size;
-                }             
-                if(total_size+read_size > start+count)
-                {
-                    read_size=start+count-total_size;
-                }
-                read_size-=read_from;
-                elem=pwalletTxsMain->m_ChunkDB->GetChunk(&chunk_def,0,-1,&elem_size);
-                if(elem)
-                {
-                    mc_gState->m_TmpBuffers->m_RpcChunkScript1->SetData(elem+read_from,read_size);
-                    *out_size+=read_size;
-                }
-            }            
-            total_size+=chunk_def.m_Size;
-        }
-        else
-        {
-            return NULL;
-        }
-        ptr+=MC_CDB_CHUNK_HASH_SIZE;
-    }
-    
-    return mc_gState->m_TmpBuffers->m_RpcChunkScript1->GetData(0,&elem_size);
-}
-
-uint32_t GetFormattedData(mc_Script *lpScript,const unsigned char **elem,int64_t *out_size,unsigned char* hashes,int chunk_count,int64_t total_size)
-{
-    uint32_t status;  
-    mc_ChunkDBRow chunk_def;
-    int size,shift,chunk;
-    unsigned char *ptr;
-    bool use_tmp_buf=false;    
-    bool skip_read=false;    
-    size_t elem_size;
-        
-    if(chunk_count > 1) 
-    {
-        if(total_size <= GetArg("-maxshowndata",MAX_OP_RETURN_SHOWN))
-        {
-            use_tmp_buf=true;
-        }
-        else
-        {
-            skip_read=true;
-        }
-    }
-    
-    
-    *elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-    *out_size=elem_size;
-    if(hashes == NULL)
-    {
-        return MC_OST_ON_CHAIN;
-    }
-    if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
-    {
-        return MC_OST_OFF_CHAIN | MC_OST_ERROR_NOT_SUPPORTED;
-    }
-    
-    if(use_tmp_buf)
-    {
-        mc_gState->m_TmpBuffers->m_RpcChunkScript1->Clear();
-        mc_gState->m_TmpBuffers->m_RpcChunkScript1->AddElement();
-    }
-    
-    status=MC_OST_OFF_CHAIN;
-    
-    ptr=hashes;
-
-    for(chunk=0;chunk<chunk_count;chunk++)
-    {
-        size=(int)mc_GetVarInt(ptr,MC_CDB_CHUNK_HASH_SIZE+16,-1,&shift);
-
-        if(size<0)
-        {
-            status |= MC_OST_ERROR_SCRIPT;
-            return status;
-        }
-        
-/*        
-        if(size > MAX_CHUNK_SIZE)
-        {
-            status |= MC_OST_ERROR_SCRIPT;
-            return status;
-        }
-*/        
-        ptr+=shift;
-        if(pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,ptr,NULL,NULL,-1) == MC_ERR_NOERROR)
-        {
-            if(size != (int)chunk_def.m_Size)
-            {
-                status |= MC_OST_ERROR_WRONG_SIZES;            
-                return status;                
-            }
-            if(!skip_read)
-            {
-                *elem=pwalletTxsMain->m_ChunkDB->GetChunk(&chunk_def,0,-1,&elem_size);
-                if(*elem)
-                {
-                    if(use_tmp_buf)
-                    {
-                        mc_gState->m_TmpBuffers->m_RpcChunkScript1->SetData(*elem,elem_size);
-                    }
-                }
-                else
-                {
-                    status = MC_OST_OFF_CHAIN | MC_OST_ERROR_CORRUPTED;            
-                    return status;
-                }
-            }
-        }
-        else
-        {
-            status=MC_OST_OFF_CHAIN;
-            *out_size=total_size;
-            return status;            
-        }
-        ptr+=MC_CDB_CHUNK_HASH_SIZE;
-    }
-    
-    status |= MC_OST_RETRIEVED;
-    
-    if(use_tmp_buf)
-    {
-        *elem = mc_gState->m_TmpBuffers->m_RpcChunkScript1->GetData(0,&elem_size);
-    }
-    else
-    {
-        if(chunk_count > 1) 
-        {
-            *elem=NULL;    
-        }        
-    }
-    
-    if(chunk_count > 1) 
-    {
-        *out_size=total_size;
-    }   
-    else
-    {
-        *out_size=elem_size;
-    }
-    
-    return status;
-}
-
-string OffChainError(uint32_t status,int *errorCode) 
-{
-    string error_str="";
-    switch(status & MC_OST_ERROR_MASK)
-    {
-        case MC_OST_ERROR_SCRIPT:
-            error_str="Error in script";
-            *errorCode=RPC_VERIFY_ERROR;
-            break;
-        case MC_OST_ERROR_WRONG_SIZES:
-            error_str="Chunk sizes don't match output script";
-            *errorCode=RPC_VERIFY_ERROR;
-            break;
-        case MC_OST_ERROR_CORRUPTED:
-            error_str="Internal error";
-            *errorCode=RPC_INTERNAL_ERROR;
-            break;
-        case MC_OST_ERROR_NOT_SUPPORTED:
-            error_str="Not supported";
-            *errorCode=RPC_NOT_SUPPORTED;
-            break;
-    }
-    return  error_str;
-}
-
-bool AvailableFromStatus(uint32_t status)
-{
-    bool available;
-    available=false;
-    
-    if( status == MC_OST_UNDEFINED )
-    {
-        available=true;               
-    }
-    
-    if( (status & MC_OST_STORAGE_MASK) == MC_OST_ON_CHAIN )
-    {
-        available=true;       
-    }
-    
-    if( (status & MC_OST_STORAGE_MASK) == MC_OST_OFF_CHAIN )
-    {
-        if( (status & MC_OST_STATUS_MASK) == MC_OST_RETRIEVED )
-        {
-            available=true;        
-        }
-        
-        if( status & MC_OST_CONTROL_NO_DATA )
-        {
-            available=false;
-        }   
-    }
-    
-    return available;
-}
-
-Value OpReturnFormatEntry(const unsigned char *elem,int64_t elem_size,uint256 txid, int vout, uint32_t format, string *format_text_out,uint32_t status)
-{
-    string metadata="";
-    Object metadata_object;
-    Value metadata_value;
-    bool available;//,offchain;
-    string error_str;    
-    int errorCode;
-    int err;
-    
-    available=AvailableFromStatus(status);
-    
-    if(status & MC_OST_ERROR_MASK)
-    {
-        error_str=OffChainError(status,&errorCode);
-    }
-     
-    if( (((int)elem_size <= GetArg("-maxshowndata",MAX_OP_RETURN_SHOWN)) || (txid == 0)) && available && ((status & MC_OST_ERROR_MASK) == 0) && (elem != NULL) )
-    {
-        if(format_text_out)
-        {
-            *format_text_out=OpReturnFormatToText(format);
-        }
-        switch(format)
-        {
-            case MC_SCR_DATA_FORMAT_UBJSON:
-                metadata_value=ubjson_read(elem,elem_size,MAX_FORMATTED_DATA_DEPTH,&err);
-                if(err == MC_ERR_NOERROR)
-                {
-                    metadata_object.push_back(Pair("json",metadata_value));
-                    return metadata_object;
-                }
-                metadata_object.push_back(Pair("json",Value::null));
-                return metadata_object;
-/*                
-                if(format_text_out)
-                {
-                    *format_text_out=OpReturnFormatToText(MC_SCR_DATA_FORMAT_UNKNOWN);
-                }
-                metadata=HexStr(elem,elem+elem_size);    
- */ 
-//                metadata_object.push_back(Pair("json",metadata));
-                break;
-            case MC_SCR_DATA_FORMAT_UTF8:
-                if(mc_IsUTF8(elem,elem_size) == 0)
-                {
-                    metadata_object.push_back(Pair("text",Value::null));
-                    return metadata_object;                    
-                }
-                metadata=string(elem,elem+elem_size);
-                metadata_object.push_back(Pair("text",metadata));
-                return metadata_object;
-//                metadata.push_back(0x00);
-                break;
-            default:                                                            // unknown
-                metadata=HexStr(elem,elem+elem_size);
-                break;
-        }
-        return metadata;
-    }    
-    if(format_text_out)
-    {
-        *format_text_out="gettxoutdata";
-    }
-    metadata_object.push_back(Pair("txid", txid.ToString()));
-    metadata_object.push_back(Pair("vout", vout));
-    metadata_object.push_back(Pair("format", OpReturnFormatToText(format)));
-    metadata_object.push_back(Pair("size", elem_size));
-/*    
-    if( ( status & MC_OST_CONTROL_NO_DATA ) == 0)
-    {
-        if(status & MC_OST_ERROR_MASK)
-        {
-            metadata_object.push_back(Pair("error", error_str));        
-        }
-        metadata_object.push_back(Pair("available", available));        
-    }
- */ 
-    return metadata_object;    
-}
-
-Value OpReturnFormatEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int vout, uint32_t format, string *format_text_out)
-{
-    return OpReturnFormatEntry(elem,elem_size,txid,vout,format,format_text_out,MC_OST_UNDEFINED);
-}
 
-Value OpReturnFormatEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int vout, uint32_t format)
-{
-    Value format_item_value;
-    string format_text_str;
-    Object result;
-
-    format_item_value=OpReturnFormatEntry(elem,elem_size,txid,vout,format,&format_text_str);
-    
-    result.push_back(Pair("format", format_text_str));
-    result.push_back(Pair("formatdata", format_item_value));
-    
-    return result;
-}
 
 Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uint32_t stream_output_level)
 {
-    // 0x0100 No offchain data
-    
     Object entry;
     Array publishers;
     set<uint160> publishers_set;
-    Array keys;
+    Array items;
     const unsigned char *ptr;
-    unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE+1];    
+    unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE+1];
     int item_key_size;
-//    Value item_value;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status;
-    Value format_item_value;
-    string format_text_str;
-    
+    Value item_value;
     mc_EntityDetails entity;
     uint256 hash;
     
@@ -1291,7 +804,6 @@ Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uin
     mc_gState->m_TmpScript->Clear();
     mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
 
-    
     if(mc_gState->m_TmpScript->IsOpReturnScript() == 0)                      
     {
         return Value::null;
@@ -1302,9 +814,6 @@ Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uin
         return Value::null;
     }
     
-//    mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format);
-    mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-    
     unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
     mc_gState->m_TmpScript->SetElement(0);
 
@@ -1320,56 +829,24 @@ Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uin
 
     hash=*(uint256*)entity.GetTxID();
     
-/*    
     if(already_seen.find(hash) != already_seen.end())
     {
         return Value::null;
     }
-*/
     
-    for(int e=1;e<mc_gState->m_TmpScript->GetNumElements()-1;e++)
+    mc_gState->m_TmpScript->SetElement(1);
+                                                                // Should be spkk
+    if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
     {
-        mc_gState->m_TmpScript->SetElement(e);
-                                                                    // Should be spkk
-        if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
-        {
-            return Value::null;
-        }                                            
-        item_key[item_key_size]=0;
-        keys.push_back(string(item_key,item_key+item_key_size));
-    }
+        return Value::null;
+    }                                            
+    item_key[item_key_size]=0;
 
+    size_t elem_size;
     const unsigned char *elem;
 
-//    elem = mc_gState->m_TmpScript->GetData(mc_gState->m_TmpScript->GetNumElements()-1,&elem_size);
-    retrieve_status = GetFormattedData(mc_gState->m_TmpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-//    item_value=OpReturnEntry(elem,elem_size,tx.GetHash(),n);
-    if(stream_output_level & 0x0100)
-    {
-        retrieve_status |= MC_OST_CONTROL_NO_DATA;
-    }
-	format_item_value=OpReturnFormatEntry(elem,out_size,tx.GetHash(),n,format,&format_text_str,retrieve_status);
-    
-    Array chunks;
-    if(retrieve_status & MC_OST_CONTROL_NO_DATA)
-    {
-        if(format_item_value.type() == obj_type)
-        {
-            for(int chunk=0;chunk<chunk_count;chunk++)
-            {
-                int chunk_shift,chunk_size;
-                Object chunk_obj;
-                
-                chunk_size=mc_GetVarInt(chunk_hashes,MC_CDB_CHUNK_HASH_SIZE+16,-1,&chunk_shift);
-                chunk_hashes+=chunk_shift;
-                chunk_obj.push_back(Pair("hash", ((uint256*)chunk_hashes)->ToString()));
-                chunk_obj.push_back(Pair("size", chunk_size));
-                chunks.push_back(chunk_obj);
-                chunk_hashes+=MC_CDB_CHUNK_HASH_SIZE;
-            }        
-//            format_item_value.get_obj().push_back(Pair("chunks", chunks));
-        }
-    }
+    elem = mc_gState->m_TmpScript->GetData(2,&elem_size);
+    item_value=OpReturnEntry(elem,elem_size,tx.GetHash(),n);
     
     already_seen.insert(hash);
     
@@ -1405,34 +882,9 @@ Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uin
 
     entry=StreamEntry((unsigned char*)&hash,stream_output_level);
     entry.push_back(Pair("publishers", publishers));
-    entry.push_back(Pair("keys", keys));
-    
-    if(mc_gState->m_Compatibility & MC_VCM_1_0)
-    {
-        entry.push_back(Pair("key", keys[0]));        
-    }
-    entry.push_back(Pair("offchain", (retrieve_status & MC_OST_STORAGE_MASK) == MC_OST_OFF_CHAIN));        
-    if( ( retrieve_status & MC_OST_CONTROL_NO_DATA ) == 0)
-    {
-        entry.push_back(Pair("available", AvailableFromStatus(retrieve_status)));        
-        if(retrieve_status & MC_OST_ERROR_MASK)
-        {
-            string error_str;
-            int errorCode;
-            error_str=OffChainError(retrieve_status,&errorCode);
-            entry.push_back(Pair("error", error_str));        
-        }
-    }
-    entry.push_back(Pair("data", format_item_value));   
+    entry.push_back(Pair("key", strprintf("%s",item_key)));
+    entry.push_back(Pair("data", item_value));        
     
-    
-    if(retrieve_status & MC_OST_CONTROL_NO_DATA)
-    {
-        if((retrieve_status & MC_OST_STORAGE_MASK) == MC_OST_OFF_CHAIN)
-        {
-            entry.push_back(Pair("chunks", chunks));            
-        }
-    }
     return entry;
 }
 
@@ -1442,7 +894,7 @@ Object AssetEntry(const unsigned char *txid,int64_t quantity,uint32_t output_lev
 // output_level constants
 // 0x0000 minimal: name, assetref, non-negative qty, negative actual issueqty    
 // 0x0001 raw 
-// 0x0002 multiple, units, open, details, permissions
+// 0x0002 multiple, units, open, details
 // 0x0004 issuetxid,     
 // 0x0008 subscribed/synchronized    
 // 0x0020 issuers
@@ -1508,11 +960,9 @@ Object AssetEntry(const unsigned char *txid,int64_t quantity,uint32_t output_lev
         uint64_t multiple=1;
         const unsigned char *ptr;
         double units=1.;
-        uint32_t permissions;
 
         ptr=entity.GetScript();
         multiple=genesis_entity.GetAssetMultiple();
-        permissions=genesis_entity.Permissions();
         units= 1./(double)multiple;
         if(output_level & 0x0002)
         {
@@ -1528,13 +978,6 @@ Object AssetEntry(const unsigned char *txid,int64_t quantity,uint32_t output_lev
                 {
                     entry.push_back(Pair("open",false));                                            
                 }
-                if(mc_gState->m_Features->PerAssetPermissions())
-                {
-                    Object pObject;
-                    pObject.push_back(Pair("send",(permissions & MC_PTP_SEND) ? true : false));
-                    pObject.push_back(Pair("receive",(permissions & MC_PTP_RECEIVE) ? true : false));
-                    entry.push_back(Pair("restrict",pObject));                                            
-                }
             }
         }
         
@@ -1752,12 +1195,17 @@ string ParseRawOutputObject(Value param,CAmount& nAmount,mc_Script *lpScript, in
     
     memset(buf,0,MC_AST_ASSET_FULLREF_BUF_SIZE);
     
-    assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+    if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+    {        
+        if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+        {
+            assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+        }
+    }
     
     BOOST_FOREACH(const Pair& a, param.get_obj()) 
     {
-        if( (a.value_.type() == obj_type) ||
-            (( (a.value_.type() == str_type) || (a.value_.type() == array_type) ) && (a.name_== "data")) )
+        if(a.value_.type() == obj_type)
         {
             bool parsed=false;
             
@@ -1895,47 +1343,6 @@ string ParseRawOutputObject(Value param,CAmount& nAmount,mc_Script *lpScript, in
                 lpScript->SetAssetQuantities(lpFollowonBuffer,MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON);                
                 parsed=true;
             }
-
-            if(!parsed && (a.name_ == "data"))
-            {
-                Array arr;
-                if( (a.value_.type() == str_type) || (a.value_.type() == obj_type) )
-                {
-                    arr.push_back(a.value_);
-                }
-                else
-                {
-                    if(a.value_.type() == array_type)
-                    {
-                        arr=a.value_.get_array();
-                    }
-                }
-                
-                for(int i=0;i<(int)arr.size();i++)
-                {
-                    uint32_t data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-                    int errorCode=RPC_INVALID_PARAMETER;
-
-                    mc_gState->m_TmpScript->Clear();
-
-                    vector<unsigned char> vData=ParseRawFormattedData(&(arr[i]),&data_format,mc_gState->m_TmpScript,MC_RFD_OPTION_INLINE,NULL,&errorCode,&strError);
-                    if(strError.size())
-                    {
-                        if(eErrorCode)
-                        {
-                            *eErrorCode=errorCode;
-                        }
-                        goto exitlbl;
-                    }
-
-                    if(data_format != MC_SCR_DATA_FORMAT_UNKNOWN)
-                    {
-                        lpScript->SetDataFormat(data_format);                    
-                    }
-                    lpScript->SetRawData(&(vData[0]),(int)vData.size());                    
-                }
-                parsed=true;
-            }
             
             if(!parsed && (a.name_ == "permissions"))
             {
@@ -2051,8 +1458,7 @@ string ParseRawOutputObject(Value param,CAmount& nAmount,mc_Script *lpScript, in
                 
                 if(type_string.size())
                 {
-                    type=mc_gState->m_Permissions->GetPermissionType(type_string.c_str(),&entity);
-//                    type=mc_gState->m_Permissions->GetPermissionType(type_string.c_str(),entity.GetEntityType());
+                    type=mc_gState->m_Permissions->GetPermissionType(type_string.c_str(),entity.GetEntityType());
                     if(entity.GetEntityType() == MC_ENT_TYPE_NONE)
                     {
                         if(required)
@@ -2445,10 +1851,8 @@ vector <pair<CScript, CAmount> > ParseRawOutputMultiObject(Object sendTo,int *re
     
     return vecSend;
 }
-
-
-
-CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_EntityDetails *given_entity,mc_EntityDetails *found_entity)
+    
+CScript ParseRawMetadata(Value param,uint32_t allowed_objects,mc_EntityDetails *given_entity,mc_EntityDetails *found_entity)
 {
 // codes for allowed_objects fields    
 // 0x0001 - create    
@@ -2459,8 +1863,7 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
 // 0x0020 - approval
 // 0x0040 - create upgrade
 // 0x0100 - encode empty hex
-// 0x0200 - raw hex
-// 0x1000 - cache input script
+// 0x0200 - cache input script
     
     CScript scriptOpReturn=CScript();
     if(found_entity)
@@ -2486,9 +1889,6 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
         mc_EntityDetails entity;
         vector<unsigned char> vKey;
         vector<unsigned char> vValue;
-        uint32_t data_format;
-        Value formatted_data=Value::null;
-        data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
         int protocol_version=-1;
         uint32_t startblock=0;
         int approve=-1;
@@ -2518,85 +1918,92 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             if(d.name_ == "inputcache")
             {
                 new_type=-3;
-                if(d.value_.type() != array_type)
+                if( ((allowed_objects & 0x0200) == 0) || (mc_gState->m_Features->CachedInputScript() == 0) )
                 {
-                    strError=string("Array should be specified for inputcache");                                                
+                    strError=string("Keyword not allowed in this API");                                                
                 }
                 else
                 {
-                    int cs_offset,cs_vin,cs_size;
-                    string cs_script="";
-                    Array csa=d.value_.get_array();
-                    lpDetails->Clear();
-                    lpDetails->SetCachedScript(0,&cs_offset,-1,NULL,-1);
-                    for(int csi=0;csi<(int)csa.size();csi++)
+                    if(d.value_.type() != array_type)
+                    {
+                        strError=string("Array should be specified for inputcache");                                                
+                    }
+                    else
                     {
-                        if(strError.size() == 0)
+                        int cs_offset,cs_vin,cs_size;
+                        string cs_script="";
+                        Array csa=d.value_.get_array();
+                        lpDetails->Clear();
+                        lpDetails->SetCachedScript(0,&cs_offset,-1,NULL,-1);
+                        for(int csi=0;csi<(int)csa.size();csi++)
                         {
-                            if(csa[csi].type() != obj_type)
+                            if(strError.size() == 0)
                             {
-                                strError=string("Elements of inputcache should be objects");                                                
-                            }
-                            cs_vin=-1;
-                            cs_size=-1;
-                            BOOST_FOREACH(const Pair& csf, csa[csi].get_obj())                                 
-                            {              
-                                bool cs_parsed=false;
-                                if(csf.name_ == "vin")
+                                if(csa[csi].type() != obj_type)
                                 {
-                                    cs_parsed=true;
-                                    if(csf.value_.type() != int_type)
+                                    strError=string("Elements of inputcache should be objects");                                                
+                                }
+                                cs_vin=-1;
+                                cs_size=-1;
+                                BOOST_FOREACH(const Pair& csf, csa[csi].get_obj())                                 
+                                {              
+                                    bool cs_parsed=false;
+                                    if(csf.name_ == "vin")
                                     {
-                                        strError=string("vin should be integer");                                                                                            
+                                        cs_parsed=true;
+                                        if(csf.value_.type() != int_type)
+                                        {
+                                            strError=string("vin should be integer");                                                                                            
+                                        }
+                                        else
+                                        {
+                                            cs_vin=csf.value_.get_int();
+                                        } 
                                     }
-                                    else
+                                    if(csf.name_ == "scriptPubKey")
                                     {
-                                        cs_vin=csf.value_.get_int();
-                                    } 
-                                }
-                                if(csf.name_ == "scriptPubKey")
-                                {
-                                    cs_parsed=true;
-                                    if(csf.value_.type() != str_type)
-                                    {
-                                        strError=string("scriptPubKey should be string");                                                                                            
+                                        cs_parsed=true;
+                                        if(csf.value_.type() != str_type)
+                                        {
+                                            strError=string("scriptPubKey should be string");                                                                                            
+                                        }
+                                        else
+                                        {
+                                            cs_script=csf.value_.get_str();
+                                            cs_size=cs_script.size()/2;
+                                        } 
                                     }
-                                    else
+                                    if(!cs_parsed)
                                     {
-                                        cs_script=csf.value_.get_str();
-                                        cs_size=cs_script.size()/2;
-                                    } 
-                                }
-                                if(!cs_parsed)
-                                {
-                                    strError=string("Invalid field: ") + csf.name_;                                                                                    
+                                        strError=string("Invalid field: ") + csf.name_;                                                                                    
+                                    }
                                 }
-                            }
-                            if(strError.size() == 0)
-                            {
-                                if(cs_vin<0)
+                                if(strError.size() == 0)
                                 {
-                                    strError=string("Missing vin field");                                                                                                                            
-                                }
-                            }
-                            if(strError.size() == 0)
-                            {
-                                if(cs_size<0)
-                                {
-                                    strError=string("Missing scriptPubKey field");                                                                                                                            
+                                    if(cs_vin<0)
+                                    {
+                                        strError=string("Missing vin field");                                                                                                                            
+                                    }
                                 }
-                            }                                
-                            if(strError.size() == 0)
-                            {
-                                bool fIsHex;
-                                vector<unsigned char> dataData(ParseHex(cs_script.c_str(),fIsHex));    
-                                if(!fIsHex)
+                                if(strError.size() == 0)
                                 {
-                                    strError=string("scriptPubKey should be hexadecimal string");                                                                                                                            
-                                }                                    
-                                else
+                                    if(cs_size<0)
+                                    {
+                                        strError=string("Missing scriptPubKey field");                                                                                                                            
+                                    }
+                                }                                
+                                if(strError.size() == 0)
                                 {
-                                    lpDetails->SetCachedScript(cs_offset,&cs_offset,cs_vin,&dataData[0],cs_size);                                        
+                                    bool fIsHex;
+                                    vector<unsigned char> dataData(ParseHex(cs_script.c_str(),fIsHex));    
+                                    if(!fIsHex)
+                                    {
+                                        strError=string("scriptPubKey should be hexadecimal string");                                                                                                                            
+                                    }                                    
+                                    else
+                                    {
+                                        lpDetails->SetCachedScript(cs_offset,&cs_offset,cs_vin,&dataData[0],cs_size);                                        
+                                    }
                                 }
                             }
                         }
@@ -2605,36 +2012,11 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                 parsed=true;
             }
             
-            if(d.name_ == "format")
-            {
-                data_format=MC_SCR_DATA_FORMAT_UNKNOWN;
-                if(d.value_.type() != null_type && !d.value_.get_str().empty())
-                {
-                    if(d.value_.get_str() == "text")
-                    {
-                        data_format=MC_SCR_DATA_FORMAT_UTF8;                        
-                    }
-                    if(d.value_.get_str() == "json")
-                    {
-                        data_format=MC_SCR_DATA_FORMAT_UBJSON;                        
-                    }
-                    if(data_format == MC_SCR_DATA_FORMAT_UNKNOWN)
-                    {
-                        strError=string("Invalid format");                                                    
-                    }
-                }
-                else
-                {
-                    strError=string("Invalid format");                            
-                }
-                parsed=true;
-            }
-            
             if(d.name_ == "create")
             {
                 if(new_type != 0)
                 {
-                    strError=string("Only one of the following keywords can appear in the object: create, update, for, format");                                                                        
+                    strError=string("Only one of the following keywords can appear in the object: create, update, for");                                                                        
                 }
                 if(d.value_.type() != null_type && !d.value_.get_str().empty())
                 {
@@ -2684,7 +2066,7 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             {                 
                 if(new_type != 0)
                 {
-                    strError=string("Only one of the following keywords can appear in the object: create, update, for, format");                                                                        
+                    strError=string("Only one of the following keywords can appear in the object: create, update, for");                                                                        
                 }
                 if(d.value_.type() != null_type && !d.value_.get_str().empty())
                 {
@@ -2724,7 +2106,7 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             {                 
                 if(new_type != 0)
                 {
-                    strError=string("Only one of the following keywords can appear in the object: create, update, for, format");                                                                        
+                    strError=string("Only one of the following keywords can appear in the object: create, update, for");                                                                        
                 }
                 if(d.value_.type() != null_type && !d.value_.get_str().empty())
                 {
@@ -2789,7 +2171,6 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             }
             if(d.name_ == "data")
             {
-/*                
                 if(d.value_.type() != null_type && (d.value_.type()==str_type))
                 {
                     bool fIsHex;
@@ -2804,8 +2185,6 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                 {
                     strError=string("Invalid value");                            
                 }
- */ 
-                formatted_data=d.value_;
                 if((allowed_objects & 0x0002) == 0)
                 {
                     strError=string("Keyword not allowed in this API");                                                
@@ -2818,6 +2197,14 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                 if(d.value_.type() != null_type && !d.value_.get_str().empty())
                 {
                     entity_name=d.value_.get_str().c_str();
+		            if(entity_name == "*")
+		            {
+		                strError=string("Invalid asset name"); 
+		            }
+	                if(entity_name.size() > MC_ENT_MAX_NAME_SIZE)
+	                {
+	                    strError=string("Invalid asset name - too long"); 
+	                }
                 }
                 else
                 {
@@ -2943,71 +2330,18 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             if(new_type == 0)
             {
 //                strError=string("One of the following keywords can appear in the object: create, update, for");                                                                        
-                if(data_format == MC_SCR_DATA_FORMAT_UNKNOWN)
+                if(given_entity && given_entity->GetEntityType())
                 {
-                    if(given_entity && given_entity->GetEntityType())
-                    {
-                        memcpy(&entity,given_entity,sizeof(mc_EntityDetails));
-                        new_type=-2;
-                    }
-                    else
-                    {
-                        new_type=MC_ENT_TYPE_ASSET; 
-                    }
+                    memcpy(&entity,given_entity,sizeof(mc_EntityDetails));
+                    new_type=-2;
                 }
                 else
                 {
-                    new_type=-4;
+                    new_type=MC_ENT_TYPE_ASSET; 
                 }
             }
         }
 
-        if( (data_format != MC_SCR_DATA_FORMAT_UNKNOWN) || (new_type == -1) )
-        {
-            switch(data_format)
-            {
-                case MC_SCR_DATA_FORMAT_UNKNOWN:
-                    if(formatted_data.type() != null_type && (formatted_data.type()==str_type))
-                    {
-                        bool fIsHex;
-                        vValue=ParseHex(formatted_data.get_str().c_str(),fIsHex);    
-                        if(!fIsHex)
-                        {
-                            strError=string("value should be hexadecimal string");                            
-                        }
-    //                    value_is_set=true;
-                    }
-                    else
-                    {
-                        strError=string("Invalid value");                            
-                    }
-                    break;
-                case MC_SCR_DATA_FORMAT_UTF8:
-                    if(formatted_data.type() != null_type && (formatted_data.type()==str_type))
-                    {
-                        vValue=vector<unsigned char> (formatted_data.get_str().begin(),formatted_data.get_str().end());    
-                    }
-                    else
-                    {
-                        strError=string("Invalid value");                            
-                    }
-                    break;
-                case MC_SCR_DATA_FORMAT_UBJSON:
-                    size_t bytes;
-                    int err;
-                    const unsigned char *script;
-                    lpDetailsScript->Clear();
-                    lpDetailsScript->AddElement();
-                    if((err = ubjson_write(formatted_data,lpDetailsScript,MAX_FORMATTED_DATA_DEPTH)) != MC_ERR_NOERROR)
-                    {
-                        strError=string("Couldn't transfer JSON object to internal UBJSON format");    
-                    }
-                    script = lpDetailsScript->GetData(0,&bytes);
-                    vValue=vector<unsigned char> (script,script+bytes);                                            
-                    break;
-            }
-        }
-        
         if(strError.size() == 0)
         {
             if(new_type == -2)
@@ -3046,11 +2380,17 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                     }            
                     if(multiple_is_set)
                     {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
+                        if(mc_gState->m_Features->OpDropDetailsScripts())
+                        {
+                            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_ASSET_MULTIPLE,(unsigned char*)&multiple,4);
+                        }
                     }
                     if(entity_name.size())
                     {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());//+1);
+                        if(mc_gState->m_Features->OpDropDetailsScripts())
+                        {
+                            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());//+1);
+                        }
                     }
                     if(vKey.size())
                     {
@@ -3115,46 +2455,83 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                 {
                     strError=string("Invalid field: startblock");
                 }
-            }
-            if(new_type != -5)
-            {
-                if(approve >= 0)
+            }
+            if(new_type != -5)
+            {
+                if(approve >= 0)
+                {
+                    strError=string("Invalid field: approve");                    
+                }
+            }
+        }
+        
+        if(strError.size() == 0)
+        {
+            if(new_type == MC_ENT_TYPE_UPGRADE)
+            {
+                if(mc_gState->m_Features->Upgrades())
+                {
+                    if((allowed_objects & 0x0040) == 0)
+                    {
+                        strError=string("Creating new upgrades not allowed in this API");                                                
+                    }
+                    else
+                    {
+                        if(lpDetails->m_Size)
+                        {
+                            strError=string("Invalid fields in details object");                                                            
+                        }
+                        if(entity_name.size())
+                        {
+                            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());//+1);
+                        }
+                        if(protocol_version > 0)
+                        {
+                            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,(unsigned char*)&protocol_version,4);                                
+                        }
+                        else
+                        {
+                            strError=string("Missing protocol-version");                                                                                    
+                        }
+                        if(startblock > 0)
+                        {
+                            lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_START_BLOCK,(unsigned char*)&startblock,4);        
+                        }                    
+                        if(multiple_is_set)
+                        {
+                            strError=string("Invalid field: multiple");                                                            
+                        }
+                        if(open_is_set)
+                        {
+                            strError=string("Invalid field: open");                                                            
+                        }
+                        if(vKey.size())
+                        {
+                            strError=string("Invalid field: key");                                                            
+                        }
+                        if(vValue.size())
+                        {
+                            strError=string("Invalid field: value");                                                            
+                        }
+                    }
+                }
+                else
                 {
-                    strError=string("Invalid field: approve");                    
+                    strError=string("Upgrades are not supported by this protocol version"); 
                 }
             }
         }
         
         if(strError.size() == 0)
         {
-            if(new_type == MC_ENT_TYPE_UPGRADE)
+            if(new_type == -5)
             {
-                if((allowed_objects & 0x0040) == 0)
-                {
-                    strError=string("Creating new upgrades not allowed in this API");                                                
-                }
-                else
+                if(mc_gState->m_Features->Upgrades())
                 {
                     if(lpDetails->m_Size)
                     {
-                        strError=string("Invalid fields in details object");                                                            
-                    }
-                    if(entity_name.size())
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_NAME,(const unsigned char*)(entity_name.c_str()),entity_name.size());//+1);
-                    }
-                    if(protocol_version > 0)
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_PROTOCOL_VERSION,(unsigned char*)&protocol_version,4);                                
-                    }
-                    else
-                    {
-                        strError=string("Missing protocol-version");                                                                                    
+                        strError=string("Invalid field: details");                                                            
                     }
-                    if(startblock > 0)
-                    {
-                        lpDetails->SetSpecialParamValue(MC_ENT_SPRM_UPGRADE_START_BLOCK,(unsigned char*)&startblock,4);        
-                    }                    
                     if(multiple_is_set)
                     {
                         strError=string("Invalid field: multiple");                                                            
@@ -3172,32 +2549,9 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                         strError=string("Invalid field: value");                                                            
                     }
                 }
-            }
-        }
-        
-        if(strError.size() == 0)
-        {
-            if(new_type == -5)
-            {
-                if(lpDetails->m_Size)
-                {
-                    strError=string("Invalid field: details");                                                            
-                }
-                if(multiple_is_set)
-                {
-                    strError=string("Invalid field: multiple");                                                            
-                }
-                if(open_is_set)
-                {
-                    strError=string("Invalid field: open");                                                            
-                }
-                if(vKey.size())
-                {
-                    strError=string("Invalid field: key");                                                            
-                }
-                if(vValue.size())
+                else
                 {
-                    strError=string("Invalid field: value");                                                            
+                    strError=string("Upgrades are not supported by this protocol version"); 
                 }
             }
         }
@@ -3210,32 +2564,64 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             
             if(new_type == MC_ENT_TYPE_ASSET)
             {
-                script=lpDetails->GetData(0,&bytes);
-                err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,0,script,bytes);
-                if(err)
+                if(mc_gState->m_Features->OpDropDetailsScripts())
                 {
-                    strError=string("Invalid custom fields, too long");                                                            
+                    script=lpDetails->GetData(0,&bytes);
+                    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,0,script,bytes);
+                    if(err)
+                    {
+                        strError=string("Invalid custom fields, too long");                                                            
+                    }
+                    else
+                    {
+                        script = lpDetailsScript->GetData(0,&bytes);
+                        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    }
                 }
                 else
                 {
+                    script=lpDetails->GetData(0,&bytes);
+                    lpDetailsScript->SetAssetDetails(entity_name.c_str(),multiple,script,bytes);                
                     script = lpDetailsScript->GetData(0,&bytes);
-                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    if(bytes > 0)
+                    {
+                        scriptOpReturn << OP_RETURN << vector<unsigned char>(script, script + bytes);
+                    }                    
                 }
             }
             
             if(new_type == MC_ENT_TYPE_STREAM)
             {
-                int err;
-                script=lpDetails->GetData(0,&bytes);
-                err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
-                if(err)
+                if(mc_gState->m_Features->OpDropDetailsScripts())
                 {
-                    strError=string("Invalid custom fields, too long");                                                            
+                    int err;
+                    script=lpDetails->GetData(0,&bytes);
+                    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM,0,script,bytes);
+                    if(err)
+                    {
+                        strError=string("Invalid custom fields, too long");                                                            
+                    }
+                    else
+                    {
+                        script = lpDetailsScript->GetData(0,&bytes);
+                        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    }
                 }
                 else
                 {
+                    lpDetailsScript->Clear();
+                    lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_STREAM);
                     script = lpDetailsScript->GetData(0,&bytes);
-                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
+                    
+                    lpDetailsScript->Clear();
+                    script=lpDetails->GetData(0,&bytes);
+                    lpDetailsScript->SetGeneralDetails(script,bytes);                
+                    script = lpDetailsScript->GetData(0,&bytes);
+                    if(bytes > 0)
+                    {
+                        scriptOpReturn << OP_RETURN << vector<unsigned char>(script, script + bytes);
+                    }
                 }
             }
             
@@ -3257,23 +2643,37 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
             
             if(new_type == -2)
             {
-                int err;
-                lpDetailsScript->Clear();
-                lpDetailsScript->SetEntity(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET);
-                script = lpDetailsScript->GetData(0,&bytes);
-                scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
-
-                lpDetailsScript->Clear();
-                script=lpDetails->GetData(0,&bytes);
-                err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,1,script,bytes);
-                if(err)
+                if(mc_gState->m_Features->OpDropDetailsScripts())
                 {
-                    strError=string("Invalid custom fields, too long");                                                            
+                    int err;
+                    lpDetailsScript->Clear();
+                    lpDetailsScript->SetEntity(entity.GetTxID()+MC_AST_SHORT_TXID_OFFSET);
+                    script = lpDetailsScript->GetData(0,&bytes);
+                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
+
+                    lpDetailsScript->Clear();
+                    script=lpDetails->GetData(0,&bytes);
+                    err=lpDetailsScript->SetNewEntityType(MC_ENT_TYPE_ASSET,1,script,bytes);
+                    if(err)
+                    {
+                        strError=string("Invalid custom fields, too long");                                                            
+                    }
+                    else
+                    {
+                        script = lpDetailsScript->GetData(0,&bytes);
+                        scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    }
                 }
                 else
                 {
+                    lpDetailsScript->Clear();
+                    script=lpDetails->GetData(0,&bytes);
+                    lpDetailsScript->SetGeneralDetails(script,bytes);                
                     script = lpDetailsScript->GetData(0,&bytes);
-                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP << OP_RETURN;
+                    if(bytes > 0)
+                    {
+                        scriptOpReturn << OP_RETURN << vector<unsigned char>(script, script + bytes);
+                    }                    
                 }
             }
                 
@@ -3291,27 +2691,9 @@ CScript ParseRawMetadataNotRefactored(Value param,uint32_t allowed_objects,mc_En
                     scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;
                 }
 
-                if(data_format != MC_SCR_DATA_FORMAT_UNKNOWN)
-                {
-                    lpDetailsScript->Clear();
-                    lpDetailsScript->SetDataFormat(data_format);
-                    script = lpDetailsScript->GetData(0,&bytes);
-                    scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-                }
-                
                 scriptOpReturn << OP_RETURN << vValue;                    
             }
                 
-            if(new_type == -4)
-            {
-                lpDetailsScript->Clear();
-                lpDetailsScript->SetDataFormat(data_format);
-                script = lpDetailsScript->GetData(0,&bytes);
-                scriptOpReturn << vector<unsigned char>(script, script + bytes) << OP_DROP;                    
-                
-                scriptOpReturn << OP_RETURN << vValue;                    
-            }
-            
             if(new_type == -3)
             {
                 script=lpDetails->GetData(0,&bytes);
@@ -3978,246 +3360,3 @@ int paramtoint(Value param,bool check_for_min,int min_value,string error_message
     
     return result;
 }
-
-int64_t paramtoint64(Value param,bool check_for_min,int64_t min_value,string error_message)
-{
-    int64_t result;
-    
-    if(param.type() != int_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, error_message);        
-    }
-    
-    result=param.get_int64();
-    if(check_for_min)
-    {
-        if(result < min_value)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, error_message);                    
-        }
-    }
-    
-    return result;
-}
-
-
-bool mc_IsJsonObjectForMerge(const Value *value,int level)
-{
-    if(value->type() != obj_type)
-    {
-        return false;
-    }
-    if(level == 0)
-    {
-        if(value->get_obj().size() != 1)
-        {
-            return false;            
-        }
-        if((value->get_obj()[0].name_ != "json"))
-        {
-            return false;            
-        }
-        if((value->get_obj()[0].value_.type() != obj_type))
-        {
-            return false;            
-        }        
-    }
-    
-    return true;
-}
-
-Value mc_MergeValues(const Value *value1,const Value *value2,uint32_t mode,int level,int *error)
-{
-    int no_merge=0;
-    
-    if(mode & MC_VMM_OMIT_NULL)
-    {
-        if(mode & MC_VMM_TAKE_FIRST)
-        {
-            if(value1->type() == null_type)    
-            {
-                return Value::null;
-            }
-        }            
-        else
-        {
-            if(value2->type() == null_type)    
-            {
-                return Value::null;                
-            }            
-        }        
-    }
-    
-    bool value1_is_obj=mc_IsJsonObjectForMerge(value1,level);
-    bool value2_is_obj=mc_IsJsonObjectForMerge(value2,level);
-    if( (mode & MC_VMM_MERGE_OBJECTS) == 0)
-    {
-        no_merge=1;
-    }
-    else
-    {
-        if(level>1)
-        {
-            if( (mode & MC_VMM_RECURSIVE) == 0 )
-            {
-                no_merge=1;
-            }
-        }
-    }
-/*            
-    if(!value1_is_obj)
-    {
-        if(!value2_is_obj)
-        {
-            no_merge=1;
-        }
-    }
-*/    
-    if(no_merge)
-    {
-        if(mode & MC_VMM_TAKE_FIRST)
-        {
-            return *value1;
-        }
-        return *value2;                
-    }
-    
-        
-        
-    if(!value1_is_obj)
-    {
-        if(mode & MC_VMM_IGNORE_OTHER)
-        {
-            return *value2; 
-        }
-        *error=MC_ERR_INVALID_PARAMETER_VALUE;
-        return Value::null;
-    }
-    else
-    {
-        if(!value2_is_obj)
-        {
-            if(mode & MC_VMM_IGNORE_OTHER)
-            {
-                return *value1;
-            }            
-            *error=MC_ERR_INVALID_PARAMETER_VALUE;
-            return Value::null;
-        }       
-    }
-    
-    
-    Object result;
-    map<string, Value> map1;   
-    map<string, Value> map2;   
-    
-    BOOST_FOREACH(const Pair& a, value1->get_obj()) 
-    {
-        map<string, Value>::iterator it1 = map1.find(a.name_); 
-        if( it1 == map1.end() )
-        {
-            map1.insert(make_pair(a.name_, a.value_));
-        }
-        else
-        {
-            if( (mode & MC_VMM_TAKE_FIRST_FOR_FIELD) == 0 )
-            {
-                it1->second=a.value_;
-            }
-        }
-    }
-
-    BOOST_FOREACH(const Pair& a, value2->get_obj()) 
-    {
-        map<string, Value>::iterator it2 = map2.find(a.name_); 
-        if( it2 == map2.end() )
-        {
-            map2.insert(make_pair(a.name_, a.value_));
-        }
-        else
-        {
-            if( (mode & MC_VMM_TAKE_FIRST_FOR_FIELD) == 0 )
-            {
-                it2->second=a.value_;
-            }
-        }
-    }
-    
-    for(map<string,Value>::iterator it1 = map1.begin(); it1 != map1.end(); ++it1) 
-    {
-        map<string, Value>::iterator it2 = map2.find(it1->first); 
-        if( it2 == map2.end() )
-        {
-            if( ((mode & MC_VMM_OMIT_NULL) == 0) || (it1->second.type() != null_type) )
-            {
-                result.push_back(Pair(it1->first, it1->second));  
-            }
-        }
-        else
-        {
-            Value merged=mc_MergeValues(&(it1->second),&it2->second,mode,level+1,error);
-            if(*error)
-            {
-                return Value::null;                
-            }
-            if( ((mode & MC_VMM_OMIT_NULL) == 0) || (merged.type() != null_type) )
-            {
-                result.push_back(Pair(it1->first, merged));  
-            }
-            map2.erase(it2);
-        }
-    }
-    
-    for(map<string,Value>::iterator it2 = map2.begin(); it2 != map2.end(); ++it2) 
-    {
-        if( ((mode & MC_VMM_OMIT_NULL) == 0) || (it2->second.type() != null_type) )
-        {
-            result.push_back(Pair(it2->first, it2->second));  
-        }
-    }
-    
-    return result;
-}
-
-int mc_BinaryCacheFile(string id,int mode)
-{
-    char dir_name[MC_DCT_DB_MAX_PATH];                   
-    char file_name[MC_DCT_DB_MAX_PATH];                   
-    int flags;
-    
-    
-    string str_file_name=strprintf("cache/%s",id);
-    
-    mc_GetFullFileName(mc_gState->m_Params->NetworkName(),"cache","",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,dir_name);
-    mc_CreateDir(dir_name);
-    mc_GetFullFileName(mc_gState->m_Params->NetworkName(),str_file_name.c_str(),"",MC_FOM_RELATIVE_TO_DATADIR,file_name);
-    
-    flags=O_RDONLY;
-    if(mode & 1)
-    {
-       flags=O_CREAT; 
-    }
-    if(mode & 2)
-    {
-       flags=O_RDWR; 
-    }
-    return open(file_name,_O_BINARY | flags, S_IRUSR | S_IWUSR);
-}
-
-void mc_RemoveBinaryCacheFile(string id)
-{
-    char file_name[MC_DCT_DB_MAX_PATH];                   
-    
-    if(id == "*")
-    {
-        mc_RemoveDir(mc_gState->m_Params->NetworkName(),"cache");
-        return; 
-    }
-    
-    string str_file_name=strprintf("cache/%s",id);
-    
-    mc_GetFullFileName(mc_gState->m_Params->NetworkName(),str_file_name.c_str(),"",MC_FOM_RELATIVE_TO_DATADIR,file_name);
-
-    __US_DeleteFile(file_name);
-}
-
diff --git a/src/rpc/rpcutils.h b/src/rpc/rpcutils.h
index f80c34a..ced39af 100644
--- a/src/rpc/rpcutils.h
+++ b/src/rpc/rpcutils.h
@@ -19,7 +19,7 @@
 #include "json/json_spirit_value.h"
 #include "multichain/multichain.h"
 #include "utils/utilparse.h"
-#include "wallet/chunkdb.h"
+
 
 using namespace std;
 using namespace json_spirit;
@@ -34,63 +34,6 @@ using namespace json_spirit;
 #define MC_ASSET_KEY_INVALID_SIZE          -4
 #define MC_ASSET_KEY_INVALID_EMPTY         -5
 
-#define MC_DATA_API_PARAM_TYPE_NONE            0x00000000
-#define MC_DATA_API_PARAM_TYPE_CREATE_STREAM   0x00000001
-#define MC_DATA_API_PARAM_TYPE_PUBLISH         0x00000002
-#define MC_DATA_API_PARAM_TYPE_ISSUE           0x00000004
-#define MC_DATA_API_PARAM_TYPE_FOLLOWON        0x00000008
-#define MC_DATA_API_PARAM_TYPE_RESERVED1       0x00000010
-#define MC_DATA_API_PARAM_TYPE_APPROVAL        0x00000020
-#define MC_DATA_API_PARAM_TYPE_CREATE_UPGRADE  0x00000040
-#define MC_DATA_API_PARAM_TYPE_EMPTY_RAW       0x00000100
-#define MC_DATA_API_PARAM_TYPE_RAW             0x00000200
-#define MC_DATA_API_PARAM_TYPE_FORMATTED       0x00000400
-#define MC_DATA_API_PARAM_TYPE_CIS             0x00001000
-
-#define MC_DATA_API_PARAM_TYPE_SIMPLE          0x00000602
-#define MC_DATA_API_PARAM_TYPE_ALL             0xFFFFFFFF
-
-#define MC_VMM_MERGE_OBJECTS                   0x00000001
-#define MC_VMM_RECURSIVE                       0x00000002
-#define MC_VMM_IGNORE_OTHER                    0x00000004
-#define MC_VMM_TAKE_FIRST                      0x00000008
-#define MC_VMM_TAKE_FIRST_FOR_FIELD            0x00000010
-#define MC_VMM_OMIT_NULL                       0x00000020
-#define MC_VMM_IGNORE_MISSING                  0x00000040
-
-#define MC_RFD_OPTION_NONE                     0x00000000
-#define MC_RFD_OPTION_INLINE                   0x00000001
-#define MC_RFD_OPTION_OFFCHAIN                 0x00000002
-#define MC_RFD_OPTION_CACHE                    0x00000004
-
-#define MC_OST_UNDEFINED                       0x00000000
-#define MC_OST_UNKNOWN                         0x00000001
-#define MC_OST_ON_CHAIN                        0x00000002
-#define MC_OST_OFF_CHAIN                       0x00000003
-#define MC_OST_STORAGE_MASK                    0x000000FF                  
-#define MC_OST_RETRIEVED                       0x00000100
-#define MC_OST_STATUS_MASK                     0x0000FF00                  
-#define MC_OST_ERROR_SCRIPT                    0x00010000
-#define MC_OST_ERROR_WRONG_SIZES               0x00020000
-#define MC_OST_ERROR_CORRUPTED                 0x00030000
-#define MC_OST_ERROR_NOT_SUPPORTED             0x00040000
-#define MC_OST_ERROR_MASK                      0x00FF0000
-#define MC_OST_CONTROL_NO_DATA                 0x01000000
-
-
-// codes for allowed_objects fields    
-// 0x0001 - create    
-// 0x0002 - publish    
-// 0x0004 - issue
-// 0x0008 - follow-on
-// 0x0010 - pure details
-// 0x0020 - approval
-// 0x0040 - create upgrade
-// 0x0100 - encode empty hex
-// 0x0200 - cache input script
-
-
-
 //string HelpRequiringPassphrase();
 string AllowedPermissions();
 string AllowedPausedServices();
@@ -105,16 +48,10 @@ int ParseAssetKeyToFullAssetRef(const char* asset_key,unsigned char *full_asset_
 Array AddressEntries(const CTxIn& txin,txnouttype& typeRet,mc_Script *lpScript);
 Array AddressEntries(const CTxOut& txout,txnouttype& typeRet);
 Value PermissionForFieldEntry(mc_EntityDetails *lpEntity);
-Array PerOutputDataEntries(const CTxOut& txout,mc_Script *lpScript,uint256 txid,int vout);
 Array PermissionEntries(const CTxOut& txout,mc_Script *lpScript,bool fLong);
 Object StreamEntry(const unsigned char *txid,uint32_t output_level);
 Object UpgradeEntry(const unsigned char *txid);
-const unsigned char *GetChunkDataInRange(int64_t *out_size,unsigned char* hashes,int chunk_count,int64_t start,int64_t count);
-uint32_t GetFormattedData(mc_Script *lpScript,const unsigned char **elem,int64_t *out_size,unsigned char* hashes,int chunk_count,int64_t total_size);
 Value OpReturnEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int vout);
-Value OpReturnFormatEntry(const unsigned char *elem,int64_t elem_size,uint256 txid, int vout, uint32_t format, string *format_text_out,uint32_t status);
-Value OpReturnFormatEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int vout, uint32_t format, string *format_text_out);
-Value OpReturnFormatEntry(const unsigned char *elem,size_t elem_size,uint256 txid, int vout, uint32_t format);
 Value DataItemEntry(const CTransaction& tx,int n,set <uint256>& already_seen,uint32_t stream_output_level);
 Object AssetEntry(const unsigned char *txid,int64_t quantity,uint32_t output_level);
 string ParseRawOutputObject(Value param,CAmount& nAmount,mc_Script *lpScript,int *eErrorCode);
@@ -131,21 +68,10 @@ void ParseRawAction(string action,bool& lock_it, bool& sign_it,bool& send_it);
 bool paramtobool(Value param);
 bool paramtobool(Value param,bool strict);
 int paramtoint(Value param,bool check_for_min,int min_value,string error_message);
-int64_t paramtoint64(Value param,bool check_for_min,int64_t min_value,string error_message);
 int ParseBlockIdentifier(Value blockset_identifier);
 int ParseRescanParameter(Value rescan_identifier, bool *fRescan);
 vector<int> ParseBlockSetIdentifier(Value blockset_identifier);
-vector<unsigned char> ParseRawFormattedData(const Value *value,uint32_t *data_format,mc_Script *lpDetailsScript,uint32_t in_options,uint32_t *out_options,int *errorCode,string *strError);
-void ParseRawDetails(const Value *value,mc_Script *lpDetails,mc_Script *lpDetailsScript,int *errorCode,string *strError);
-bool mc_IsJsonObjectForMerge(const Value *value,int level);
-Value mc_MergeValues(const Value *value1,const Value *value2,uint32_t mode,int level,int *error);
-Value mc_ExtractDetailsJSONObject(const unsigned char *script,uint32_t total);
-void AppendOffChainFormatData(uint32_t data_format,uint32_t out_options,mc_Script *lpDetailsScript,vector<unsigned char>& vValue,vector<uint256>* vChunkHashes,int *errorCode,string *strError);
-int mc_BinaryCacheFile(string id,int mode);
-void mc_RemoveBinaryCacheFile(string id);
-bool AvailableFromStatus(uint32_t status);
-string OffChainError(uint32_t status,int *errorCode); 
-bool RawDataParseRestrictParameter(const Value& param,uint32_t *restrict,uint32_t *permissions,string *strError);
+void CheckWalletError(int err);
 
 
 #endif	/* RPCMULTICHAINUTILS_H */
diff --git a/src/rpc/rpcwallet.cpp b/src/rpc/rpcwallet.cpp
index 277829a..152f0a2 100644
--- a/src/rpc/rpcwallet.cpp
+++ b/src/rpc/rpcwallet.cpp
@@ -514,80 +514,7 @@ Value listaddresses(const Array& params, bool fHelp)
 
 
 
-Value storechunk(const Array& params, bool fHelp)
-{
-    int err;
-    
-    if (fHelp || params.size() != 1) 
-        throw runtime_error("Help message not found\n");
-    
-    if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
-    {
-        throw JSONRPCError(RPC_NOT_SUPPORTED, "API is not supported with this wallet version. To get this functionality, run \"multichaind -walletdbversion=2 -rescan\" ");        
-    }   
-    
-    vector<unsigned char> vValue;
-    if(params[0].type() != str_type)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data should be hexadecimal string");                                                                                                                
-    }
-    
-    bool fIsHex;
-    vValue=ParseHex(params[0].get_str().c_str(),fIsHex);    
-    if(!fIsHex)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data should be hexadecimal string");                                                                                                                
-    }        
-    
-    if(vValue.size() == 0)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data should be non-empty hexadecimal string");                                                                                                                        
-    }
 
-    if((int)vValue.size() > MAX_CHUNK_SIZE)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "data is too long");                                                                                                                        
-    }
-    
-    uint256 hash;
-    mc_gState->m_TmpBuffers->m_RpcHasher1->DoubleHash(&vValue[0],(int)vValue.size(),&hash);
-/*    
-    mc_SHA256 *hasher;
-    
-    hasher=new mc_SHA256;    
-    hasher->Reset();
-    hasher->Write(&vValue[0],(int)vValue.size());
-    hasher->GetHash((unsigned char*)&hash);
-    hasher->Reset();
-    hasher->Write((unsigned char*)&hash,32);
-    hasher->GetHash((unsigned char*)&hash);
-    
-    delete hasher;
-*/    
-    mc_TxEntity entity;
-    entity.Zero();
-    entity.m_EntityType=MC_TET_AUTHOR;
-    
-    err=pwalletTxsMain->m_ChunkDB->AddChunk((unsigned char*)&hash,&entity,NULL,-1,(unsigned char*)&vValue[0],NULL,(int)vValue.size(),0,0);
-    
-    if(err)
-    {
-        switch(err)
-        {
-            case MC_ERR_FOUND:
-                break;
-            default:
-                throw JSONRPCError(RPC_INVALID_PARAMETER, "Internal error: couldn't store chunk");                                                                                                                                
-                break;
-        }
-    }
-    
-//    pwalletTxsMain->m_ChunkDB->FlushSourceChunks(GetArg("-chunkflushmode",MC_CDB_FLUSH_MODE_COMMIT));
-    pwalletTxsMain->m_ChunkDB->FlushSourceChunks(GetArg("-flushsourcechunks",true) ? (MC_CDB_FLUSH_MODE_FILE | MC_CDB_FLUSH_MODE_DATASYNC) : MC_CDB_FLUSH_MODE_NONE);
-    pwalletTxsMain->m_ChunkDB->Dump("storechunk");
-    
-    return hash.GetHex();
-}
 
 
 
@@ -643,128 +570,49 @@ Value gettxoutdata(const Array& params, bool fHelp)
     mc_gState->m_TmpScript->Clear();
     mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
 
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status;
-    size_t elem_size;
-    const unsigned char *elem;
-    string error_str;
-    int errorCode;
+    string metadata="";
     
     if(mc_gState->m_TmpScript->IsOpReturnScript() == 0)                      
     {
-        unsigned char *ptr;
-        int size;
-        elem=NULL;
-        
-        for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
-        {
-            mc_gState->m_TmpScript->SetElement(e);
-            if(mc_gState->m_TmpScript->GetRawData(&ptr,&size) == 0)      
-            {
-                if(elem)
-                {
-                    throw JSONRPCError(RPC_NOT_ALLOWED, "This output has more than one data item");                                
-                }
-                format=MC_SCR_DATA_FORMAT_UNKNOWN;
-                if(e > 0)
-                {
-                    mc_gState->m_TmpScript->SetElement(e-1);
-                    mc_gState->m_TmpScript->GetDataFormat(&format);
-                }
-                elem=ptr;
-                elem_size=size;
-                out_size=elem_size;
-            }        
-        }
-        if(elem == NULL)
-        {
-            throw JSONRPCError(RPC_OUTPUT_NOT_DATA, "Output without metadata");        
-        }
-    }
-    else
-    {
-//        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format);
-        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-        retrieve_status = GetFormattedData(mc_gState->m_TmpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-        if(retrieve_status & MC_OST_ERROR_MASK)
-        {
-            error_str=OffChainError(retrieve_status,&errorCode);
-            throw JSONRPCError(errorCode, error_str);                    
-        }
-        
-        elem_size=(size_t)out_size;
-        if( ( (retrieve_status & MC_OST_STATUS_MASK) != MC_OST_RETRIEVED ) && 
-            ( (retrieve_status & MC_OST_STORAGE_MASK) != MC_OST_ON_CHAIN ) )
-        {
-                throw JSONRPCError(RPC_OUTPUT_NOT_FOUND, "Data for this output is not available");        
-        }            
-//        elem = mc_gState->m_TmpScript->GetData(mc_gState->m_TmpScript->GetNumElements()-1,&elem_size);
+        throw JSONRPCError(RPC_OUTPUT_NOT_DATA, "Output without metadata");        
     }
+    size_t elem_size;
+    const unsigned char *elem;
 
-    int64_t count,start;
-    count=out_size;
-    start=0;
-    
+    elem = mc_gState->m_TmpScript->GetData(mc_gState->m_TmpScript->GetNumElements()-1,&elem_size);
+
+    int count,start;
+    count=elem_size;
     if (params.size() > 2)    
     {
-        count=paramtoint64(params[2],true,0,"Invalid count");
+        count=paramtoint(params[2],true,0,"Invalid count");
     }
+    start=0;
     if (params.size() > 3)    
     {
-        start=paramtoint64(params[3],false,0,"Invalid start");
+        start=paramtoint(params[3],false,0,"Invalid start");
     }
-
-
+    
+    
     if(start < 0)
     {
-        start=out_size+start;
+        start=elem_size+start;
         if(start<0)
         {
             start=0;
         }        
     }
-
-    if(start > out_size)
+    
+    if(start > (int)elem_size)
     {
-        start=out_size;
+        start=elem_size;
     }
-    if(start+count > out_size)
+    if(start+count > (int)elem_size)
     {
-        count=out_size-start;
+        count=elem_size-start;
     }
 
-    if( (format == MC_SCR_DATA_FORMAT_UBJSON) || (format == MC_SCR_DATA_FORMAT_UTF8) )
-    {
-        if(start != 0)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid start, must be 0 for text and JSON data");                                                                            
-        }
-        if(count != out_size)
-        {
-            throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid count, must include all text or JSON data");                                                                            
-        }
-    }
-    if(count > 0x4000000)
-    {
-        throw JSONRPCError(RPC_INVALID_PARAMETER, "Invalid count, must be below 64MB");                                                                            
-    }
-
-    if(chunk_count > 1)
-    {
-        if(elem == NULL)
-        {
-            elem=GetChunkDataInRange(&out_size,chunk_hashes,chunk_count,start,count);
-            if(elem == NULL)
-            {
-                throw JSONRPCError(RPC_INTERNAL_ERROR, "Couldn't retrieve data for this output");                                                                                            
-            }
-            return OpReturnFormatEntry(elem,count,0,0,format,NULL);        
-        }
-    }
-    return OpReturnFormatEntry(elem+start,count,0,0,format,NULL);        
+    return HexStr(elem+start,elem+start+count);
 }
 
 /* MCHN END */
@@ -1765,6 +1613,7 @@ Value listsinceblock(const Array& params, bool fHelp)
             while(up_tx-down_tx>chunk_size)
             {
                 err=pwalletTxsMain->GetList(&wallet_entity,this_tx,1,lpEntRowBuffer);
+                CheckWalletError(err);
                 if( (err == MC_ERR_NOERROR) && (lpEntRowBuffer->GetCount() > 0) )
                 {
                     entrow=(mc_TxEntityRow *)(lpEntRowBuffer->GetRow(0));
@@ -1788,6 +1637,7 @@ Value listsinceblock(const Array& params, bool fHelp)
             while(this_tx<=tx_count)
             {
                 err=pwalletTxsMain->GetList(&wallet_entity,this_tx,chunk_size,lpEntRowBuffer);
+                CheckWalletError(err);
                 if( (err == MC_ERR_NOERROR) && (lpEntRowBuffer->GetCount() > 0) )
                 {
                     for(int i=0;i<lpEntRowBuffer->GetCount();i++)
diff --git a/src/rpc/rpcwallet.h b/src/rpc/rpcwallet.h
index b212d64..cf8b817 100644
--- a/src/rpc/rpcwallet.h
+++ b/src/rpc/rpcwallet.h
@@ -20,36 +20,14 @@
 
 #include "multichain/multichain.h"
 #include "wallet/wallettxs.h"
-#include "wallet/chunkdb.h"
 #include "rpc/rpcutils.h"
 
-#define MC_QCT_KEY                  1
-#define MC_QCT_PUBLISHER            2
-
-
-typedef struct mc_QueryCondition
-{
-    uint32_t m_Type;
-    string m_Value;      
-    bool m_TmpMatch;
-    
-    mc_QueryCondition(int type, string value)
-    {
-        m_Type=type;
-        m_Value=value;
-        m_TmpMatch=false;
-    }
-} mc_QueryCondition;
-
-
-
-
 void SendMoneyToSeveralAddresses(const std::vector<CTxDestination> addresses, CAmount nValue, CWalletTx& wtxNew,mc_Script *dropscript,CScript scriptOpReturn,const std::vector<CTxDestination>& fromaddresses);
 vector<CTxDestination> ParseAddresses(string param, bool create_full_list, bool allow_scripthash);
 void FindAddressesWithPublishPermission(std::vector<CTxDestination>& fromaddresses,mc_EntityDetails *stream_entity);
 set<string> ParseAddresses(Value param, isminefilter filter);
 bool CBitcoinAddressFromTxEntity(CBitcoinAddress &address,mc_TxEntity *lpEntity);
-Object StreamItemEntry(const CWalletTx& wtx,int first_output,const unsigned char *stream_id, bool verbose, vector<mc_QueryCondition> *given_conditions,int *output);
+Object StreamItemEntry(const CWalletTx& wtx,const unsigned char *stream_id, bool verbose);
 Object TxOutEntry(const CTxOut& TxOutIn,int vout,const CTxIn& TxIn,uint256 hash,mc_Buffer *amounts,mc_Script *lpScript);
 void WalletTxToJSON(const CWalletTx& wtx, Object& entry,bool skipWalletConflicts = false, int vout = -1);
 void MinimalWalletTxToJSON(const CWalletTx& wtx, Object& entry);
diff --git a/src/rpc/rpcwalletsend.cpp b/src/rpc/rpcwalletsend.cpp
index 550a732..ee71244 100644
--- a/src/rpc/rpcwalletsend.cpp
+++ b/src/rpc/rpcwalletsend.cpp
@@ -73,7 +73,7 @@ Value createrawsendfrom(const Array& params, bool fHelp)
     {
         BOOST_FOREACH(const Value& data, params[2].get_array()) 
         {
-            CScript scriptOpReturn=ParseRawMetadata(data,MC_DATA_API_PARAM_TYPE_ALL-MC_DATA_API_PARAM_TYPE_CIS,&entity,&found_entity);
+            CScript scriptOpReturn=ParseRawMetadata(data,0x01FF,&entity,&found_entity);
             if(found_entity.GetEntityType() == MC_ENT_TYPE_STREAM)
             {
                 FindAddressesWithPublishPermission(fromaddresses,&found_entity);
@@ -329,7 +329,7 @@ Value sendwithmetadatafrom(const Array& params, bool fHelp)
     }
     
     mc_EntityDetails found_entity;
-    CScript scriptOpReturn=ParseRawMetadata(params[3],MC_DATA_API_PARAM_TYPE_SIMPLE,NULL,&found_entity);
+    CScript scriptOpReturn=ParseRawMetadata(params[3],0x0002,NULL,&found_entity);
     
     vector<CTxDestination> fromaddresses;        
     set<CTxDestination> thisFromAddresses;
@@ -863,6 +863,13 @@ Value sendassetfrom(const Array& params, bool fHelp)
         mc_EntityDetails entity;
         ParseEntityIdentifier(params[2],&entity, MC_ENT_TYPE_ASSET);           
         memcpy(buf,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
+        if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+        {
+            if(entity.IsUnconfirmedGenesis())
+            {
+                throw JSONRPCError(RPC_UNCONFIRMED_ENTITY, "Unconfirmed asset: "+params[2].get_str());            
+            }
+        }
         multiple=entity.GetAssetMultiple();
     }
     else
@@ -987,6 +994,13 @@ Value sendassettoaddress(const Array& params, bool fHelp)
         mc_EntityDetails entity;
         ParseEntityIdentifier(params[1],&entity, MC_ENT_TYPE_ASSET);           
         memcpy(buf,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
+        if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+        {
+            if(entity.IsUnconfirmedGenesis())
+            {
+                throw JSONRPCError(RPC_UNCONFIRMED_ENTITY, "Unconfirmed asset: "+params[1].get_str());            
+            }
+        }
         multiple=entity.GetAssetMultiple();
     }
     else
diff --git a/src/rpc/rpcwallettxs.cpp b/src/rpc/rpcwallettxs.cpp
index c184a77..eb83331 100644
--- a/src/rpc/rpcwallettxs.cpp
+++ b/src/rpc/rpcwallettxs.cpp
@@ -176,13 +176,6 @@ Object ListWalletTransactions(const CWalletTx& wtx, bool fLong, const isminefilt
     Array aPermissions;
     Array aMetaData;
     Array aItems;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status;
-    Array aFormatMetaData;
-    vector<Array> aFormatMetaDataPerOutput;
 
     nIsFromMeCount=GetInputOffer(wtx,addresses,filter,nAmount,amounts,lpScript,&from_addresses,&my_addresses);
     nIsToMeCount=0;
@@ -195,8 +188,6 @@ Object ListWalletTransactions(const CWalletTx& wtx, bool fLong, const isminefilt
         mc_SetABQuantity(amounts->GetRow(i),quantity);        
     }
     
-    aFormatMetaDataPerOutput.resize(wtx.vout.size());
-    
     new_entity_type=MC_ENT_TYPE_NONE;
     nIsToMeCount=0;
     for (int i = 0; i < (int)wtx.vout.size(); ++i)
@@ -252,34 +243,23 @@ Object ListWalletTransactions(const CWalletTx& wtx, bool fLong, const isminefilt
             lpScript->Clear();
             lpScript->SetScript((unsigned char*)(&pc2[0]),(size_t)(script2.end()-pc2),MC_SCR_TYPE_SCRIPTPUBKEY);
             
-//        	lpScript->ExtractAndDeleteDataFormat(&format);
-            lpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-            
+            size_t elem_size;
             const unsigned char *elem;
 
             if(lpScript->GetNumElements()<=1)
             {
                 if(lpScript->GetNumElements()==1)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-//                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-                    Value metadata=OpReturnFormatEntry(elem,out_size,wtx.GetHash(),i,format,NULL,retrieve_status);
-                    aFormatMetaData.push_back(metadata);
-                    aFormatMetaDataPerOutput[i].push_back(metadata);
+                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
                 }                        
             }
             else
             {
-                if(mc_gState->m_Compatibility & MC_VCM_1_0)
+                elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
+                if(elem_size)
                 {
-//                    elem = lpScript->GetData(lpScript->GetNumElements()-1,&elem_size);
-                    retrieve_status = GetFormattedData(lpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-                    if(out_size)
-                    {
-    //                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
-                        aFormatMetaData.push_back(OpReturnFormatEntry(elem,out_size,wtx.GetHash(),i,format,NULL,retrieve_status));
-                    }
+                    aMetaData.push_back(OpReturnEntry(elem,elem_size,wtx.GetHash(),i));
                 }
                 
                 lpScript->SetElement(0);
@@ -390,18 +370,7 @@ Object ListWalletTransactions(const CWalletTx& wtx, bool fLong, const isminefilt
                 aTxOutItems.push_back(data_item_entry);
             }
             Object txout_entry=TxOutEntry(wtx.vout[i],i,TxIn,wtx.GetHash(),amounts,lpScript);
-            if( (aTxOutItems.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-            {
-                txout_entry.push_back(Pair("items", aTxOutItems));
-            }
-            if( (mc_gState->m_Compatibility & MC_VCM_1_0) == 0)
-            {
-                if(aFormatMetaDataPerOutput[i].size())
-                {
-                    txout_entry.push_back(Pair("data", aFormatMetaDataPerOutput[i]));                    
-                }
-            }
-            
+            txout_entry.push_back(Pair("items", aTxOutItems));
             vout.push_back(txout_entry);
         }
     }        
@@ -460,8 +429,7 @@ Object ListWalletTransactions(const CWalletTx& wtx, bool fLong, const isminefilt
         }        
     }
     entry.push_back(Pair("items", aItems));
-        
-    entry.push_back(Pair("data", aFormatMetaData));
+    entry.push_back(Pair("data", aMetaData));
     
     WalletTxToJSON(wtx, entry, true);
 
@@ -527,7 +495,7 @@ Value listwallettransactions(const Array& params, bool fHelp)
         {
             wallet_by_time.m_EntityType |= MC_TET_WALLET_SPENDABLE;            
         }
-        pwalletTxsMain->GetList(&wallet_by_time,-nFrom,nCount,entity_rows);
+        CheckWalletError(pwalletTxsMain->GetList(&wallet_by_time,-nFrom,nCount,entity_rows));
         for(int i=0;i<entity_rows->GetCount();i++)
         {
             lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
@@ -658,7 +626,7 @@ Value listaddresstransactions(const Array& params, bool fHelp)
             memcpy(address_by_time.m_EntityID,lpScriptID,MC_TDB_ENTITY_ID_SIZE);
             address_by_time.m_EntityType=MC_TET_SCRIPT_ADDRESS | MC_TET_TIMERECEIVED;
         }
-        pwalletTxsMain->GetList(&address_by_time,-nFrom,nCount,entity_rows);
+        CheckWalletError(pwalletTxsMain->GetList(&address_by_time,-nFrom,nCount,entity_rows));
         for(int i=0;i<entity_rows->GetCount();i++)
         {
             lpEntTx=(mc_TxEntityRow*)entity_rows->GetRow(i);
diff --git a/src/rpc/rpcwalletutils.cpp b/src/rpc/rpcwalletutils.cpp
index 74804c3..abe3a4c 100644
--- a/src/rpc/rpcwalletutils.cpp
+++ b/src/rpc/rpcwalletutils.cpp
@@ -430,422 +430,99 @@ bool CBitcoinAddressFromTxEntity(CBitcoinAddress &address,mc_TxEntity *lpEntity)
     return false;
 }
 
-Object StreamItemEntry1(const CWalletTx& wtx,int first_output,const unsigned char *stream_id, bool verbose, const char** given_key,const char ** given_publisher,int *output)
+Object StreamItemEntry(const CWalletTx& wtx,const unsigned char *stream_id, bool verbose)
 {
     Object entry;
     Array publishers;
     set<uint160> publishers_set;
-    Array keys;    
+    Array items;
     int stream_output;
     const unsigned char *ptr;
     unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE+1];
     int item_key_size;
-//    Value item_value;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status=0;
-    Value format_item_value;
-    string format_text_str;
-    int start_from=first_output;
-    bool key_found,publisher_found;
+    Value item_value;
     
     stream_output=-1;
-    if(output)
+    for (int j = 0; j < (int)wtx.vout.size(); ++j)
     {
-        *output=(int)wtx.vout.size();
-    }
-    while( (stream_output < 0) && (start_from<(int)wtx.vout.size()) )
-    {
-        stream_output=-1;
-        for (int j = start_from; j < (int)wtx.vout.size(); ++j)
-        {
-            if(stream_output < 0)
-            {
-                keys.clear();
-                const CScript& script1 = wtx.vout[j].scriptPubKey;        
-                CScript::const_iterator pc1 = script1.begin();
-
-                mc_gState->m_TmpScript->Clear();
-                mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-
-                if(mc_gState->m_TmpScript->IsOpReturnScript())                      
-                {
-                    if(mc_gState->m_TmpScript->GetNumElements()) // 2 OP_DROPs + OP_RETURN - item key
-                    {
-                        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-//                        chunk_hashes=NULL;
-//                        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format);
-
-                        unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-                        mc_gState->m_TmpScript->SetElement(0);
-
-                        if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)           
-                        {
-                            if(memcmp(short_txid,stream_id,MC_AST_SHORT_TXID_SIZE) == 0)
-                            {
-                                stream_output=j;
-                                key_found=false;
-                                for(int e=1;e<mc_gState->m_TmpScript->GetNumElements()-1;e++)
-                                {
-                                    mc_gState->m_TmpScript->SetElement(e);
-                                                                                                // Should be spkk
-                                    if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
-                                    {
-                                        return entry;
-                                    }                                            
-                                    item_key[item_key_size]=0;
-                                    if(given_key)
-                                    {
-                                        if(strcmp((char*)item_key,*given_key) == 0)
-                                        {
-                                            key_found=true;                                   
-                                        }
-                                    }
-                                    keys.push_back(string(item_key,item_key+item_key_size));
-                                }
-                                
-                                if(given_key)
-                                {
-                                    if(!key_found)
-                                    {
-                                        stream_output=-1;
-                                    }
-                                }
-
-                                const unsigned char *elem;
-
-//                                elem = mc_gState->m_TmpScript->GetData(mc_gState->m_TmpScript->GetNumElements()-1,&elem_size);
-                                retrieve_status = GetFormattedData(mc_gState->m_TmpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-//                                item_value=OpReturnEntry(elem,elem_size,wtx.GetHash(),j);
-                                format_item_value=OpReturnFormatEntry(elem,out_size,wtx.GetHash(),j,format,&format_text_str,retrieve_status);
-                            }
-                        }
-                    }                        
-                }
-            }
-        }
-
         if(stream_output < 0)
         {
-            return entry;
-        }
-        if(output)
-        {
-            *output=stream_output;
-        }
+            const CScript& script1 = wtx.vout[j].scriptPubKey;        
+            CScript::const_iterator pc1 = script1.begin();
 
-        publishers.clear();
-        publishers_set.clear();
-        publisher_found=false;
-        for (int i = 0; i < (int)wtx.vin.size(); ++i)
-        {
-            int op_addr_offset,op_addr_size,is_redeem_script,sighash_type;
-
-            const CScript& script2 = wtx.vin[i].scriptSig;        
-            CScript::const_iterator pc2 = script2.begin();
+            mc_gState->m_TmpScript->Clear();
+            mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
 
-            ptr=mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,0);
-            if(ptr)
+            if(mc_gState->m_TmpScript->IsOpReturnScript())                      
             {
-                if( (sighash_type == SIGHASH_ALL) || ( (sighash_type == SIGHASH_SINGLE) && (i == stream_output) ) )
+                if(mc_gState->m_TmpScript->GetNumElements()) // 2 OP_DROPs + OP_RETURN - item key
                 {
-                    uint160 publisher_hash=Hash160(ptr+op_addr_offset,ptr+op_addr_offset+op_addr_size);
-                    if(publishers_set.count(publisher_hash) == 0)
+                    unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
+                    mc_gState->m_TmpScript->SetElement(0);
+
+                    if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)           
                     {
-                        publishers_set.insert(publisher_hash);
-                        string publisher_str;
-                        if(is_redeem_script)
+                        if(memcmp(short_txid,stream_id,MC_AST_SHORT_TXID_SIZE) == 0)
                         {
-                            publisher_str=CBitcoinAddress((CScriptID)publisher_hash).ToString();
-                        }
-                        else
-                        {
-                            publisher_str=CBitcoinAddress((CKeyID)publisher_hash).ToString();                    
-                        }
-                        if(given_publisher)
-                        {
-                            if(strcmp(publisher_str.c_str(),*given_publisher) == 0)
+                            stream_output=j;
+                            mc_gState->m_TmpScript->SetElement(1);
+                                                                                        // Should be spkk
+                            if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
                             {
-                                publisher_found=true;                                   
-                            }
+                                return entry;
+                            }                                            
+                            item_key[item_key_size]=0;
+                            
+                            size_t elem_size;
+                            const unsigned char *elem;
+
+                            elem = mc_gState->m_TmpScript->GetData(2,&elem_size);
+                            item_value=OpReturnEntry(elem,elem_size,wtx.GetHash(),j);
                         }
-                        publishers.push_back(publisher_str);
                     }
-                }
-            }        
-        }
-        if(given_publisher)
-        {
-            if(!publisher_found)
-            {
-                stream_output=-1;
+                }                        
             }
         }
-                
-        if(stream_output < 0)
-        {
-            start_from++;
-        }
     }
-
+    
     if(stream_output < 0)
     {
         return entry;
     }
-
-    
-    entry.push_back(Pair("publishers", publishers));
-    entry.push_back(Pair("keys", keys));
-    if(mc_gState->m_Compatibility & MC_VCM_1_0)
-    {
-        entry.push_back(Pair("key", keys[0]));        
-    }
-    entry.push_back(Pair("offchain", (retrieve_status & MC_OST_STORAGE_MASK) == MC_OST_OFF_CHAIN));        
-    if( ( retrieve_status & MC_OST_CONTROL_NO_DATA ) == 0)
-    {
-        entry.push_back(Pair("available", AvailableFromStatus(retrieve_status)));        
-        if(retrieve_status & MC_OST_ERROR_MASK)
-        {
-            string error_str;
-            int errorCode;
-            error_str=OffChainError(retrieve_status,&errorCode);
-            entry.push_back(Pair("error", error_str));        
-        }
-    }
-    entry.push_back(Pair("data", format_item_value));        
     
-    if(verbose)
-    {
-        WalletTxToJSON(wtx, entry, true, stream_output);
-    }
-    else
-    {
-        MinimalWalletTxToJSON(wtx, entry);
-    }
-    
-    return entry;
-}
-
-Object StreamItemEntry(const CWalletTx& wtx,int first_output,const unsigned char *stream_id, bool verbose, vector<mc_QueryCondition> *given_conditions,int *output)
-{
-    Object entry;
-    Array publishers;
-    set<uint160> publishers_set;
-    Array keys;    
-    int stream_output;
-    const unsigned char *ptr;
-    unsigned char item_key[MC_ENT_MAX_ITEM_KEY_SIZE+1];
-    int item_key_size;
-//    Value item_value;
-    uint32_t format;
-    unsigned char *chunk_hashes;
-    int chunk_count;   
-    int64_t total_chunk_size,out_size;
-    uint32_t retrieve_status=0;
-    Value format_item_value;
-    string format_text_str;
-    int start_from=first_output;
-    
-    stream_output=-1;
-    if(output)
-    {
-        *output=(int)wtx.vout.size();
-    }
-    while( (stream_output < 0) && (start_from<(int)wtx.vout.size()) )
-    {
-        stream_output=-1;
-        for (int j = start_from; j < (int)wtx.vout.size(); ++j)
-        {
-            if(stream_output < 0)
-            {
-                if(given_conditions)
-                {
-                    for(int c=0;c<(int)(*given_conditions).size();c++)
-                    {
-                        (*given_conditions)[c].m_TmpMatch=false;
-                    }
-                }
-                keys.clear();
-                const CScript& script1 = wtx.vout[j].scriptPubKey;        
-                CScript::const_iterator pc1 = script1.begin();
-
-                mc_gState->m_TmpScript->Clear();
-                mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-
-                if(mc_gState->m_TmpScript->IsOpReturnScript())                      
-                {
-                    if(mc_gState->m_TmpScript->GetNumElements()) // 2 OP_DROPs + OP_RETURN - item key
-                    {
-                        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format,&chunk_hashes,&chunk_count,&total_chunk_size);
-//                        chunk_hashes=NULL;
-//                        mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(&format);
-
-                        unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
-                        mc_gState->m_TmpScript->SetElement(0);
-
-                        if(mc_gState->m_TmpScript->GetEntity(short_txid) == 0)           
-                        {
-                            if(memcmp(short_txid,stream_id,MC_AST_SHORT_TXID_SIZE) == 0)
-                            {
-                                stream_output=j;
-                                for(int e=1;e<mc_gState->m_TmpScript->GetNumElements()-1;e++)
-                                {
-                                    mc_gState->m_TmpScript->SetElement(e);
-                                                                                                // Should be spkk
-                                    if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
-                                    {
-                                        return entry;
-                                    }                                            
-                                    item_key[item_key_size]=0;
-                                    
-                                    if(given_conditions)
-                                    {
-                                        for(int c=0;c<(int)(*given_conditions).size();c++)
-                                        {
-                                            if((*given_conditions)[c].m_Type == MC_QCT_KEY)
-                                            {
-                                                if(strcmp((char*)item_key,(*given_conditions)[c].m_Value.c_str()) == 0)
-                                                {
-                                                    (*given_conditions)[c].m_TmpMatch=true;
-                                                }                                                
-                                            }
-                                        }
-                                    }
-                                    
-                                    keys.push_back(string(item_key,item_key+item_key_size));
-                                }
-                                
-                                if(given_conditions)
-                                {
-                                    for(int c=0;c<(int)(*given_conditions).size();c++)
-                                    {
-                                        if((*given_conditions)[c].m_Type == MC_QCT_KEY)
-                                        {
-                                            if(!(*given_conditions)[c].m_TmpMatch)
-                                            {
-                                                stream_output=-1;                                                
-                                            }
-                                        }
-                                    }
-                                }
-
-                                const unsigned char *elem;
-
-//                                elem = mc_gState->m_TmpScript->GetData(mc_gState->m_TmpScript->GetNumElements()-1,&elem_size);
-                                retrieve_status = GetFormattedData(mc_gState->m_TmpScript,&elem,&out_size,chunk_hashes,chunk_count,total_chunk_size);
-//                                item_value=OpReturnEntry(elem,elem_size,wtx.GetHash(),j);
-                                format_item_value=OpReturnFormatEntry(elem,out_size,wtx.GetHash(),j,format,&format_text_str,retrieve_status);
-                            }
-                        }
-                    }                        
-                }                
-            }
-        }
-
-        if(stream_output < 0)
-        {
-            return entry;
-        }
-        if(output)
-        {
-            *output=stream_output;
-        }
-
-        publishers.clear();
-        publishers_set.clear();
-        for (int i = 0; i < (int)wtx.vin.size(); ++i)
-        {
-            int op_addr_offset,op_addr_size,is_redeem_script,sighash_type;
-
-            const CScript& script2 = wtx.vin[i].scriptSig;        
-            CScript::const_iterator pc2 = script2.begin();
-
-            ptr=mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,0);
-            if(ptr)
+    publishers_set.clear();
+    for (int i = 0; i < (int)wtx.vin.size(); ++i)
+    {
+        int op_addr_offset,op_addr_size,is_redeem_script,sighash_type;
+                    
+        const CScript& script2 = wtx.vin[i].scriptSig;        
+        CScript::const_iterator pc2 = script2.begin();
+                                          
+        ptr=mc_ExtractAddressFromInputScript((unsigned char*)(&pc2[0]),(int)(script2.end()-pc2),&op_addr_offset,&op_addr_size,&is_redeem_script,&sighash_type,0);
+        if(ptr)
+        {
+            if( (sighash_type == SIGHASH_ALL) || ( (sighash_type == SIGHASH_SINGLE) && (i == stream_output) ) )
             {
-                if( (sighash_type == SIGHASH_ALL) || ( (sighash_type == SIGHASH_SINGLE) && (i == stream_output) ) )
+                uint160 publisher_hash=Hash160(ptr+op_addr_offset,ptr+op_addr_offset+op_addr_size);
+                if(publishers_set.count(publisher_hash) == 0)
                 {
-                    uint160 publisher_hash=Hash160(ptr+op_addr_offset,ptr+op_addr_offset+op_addr_size);
-                    if(publishers_set.count(publisher_hash) == 0)
+                    publishers_set.insert(publisher_hash);
+                    if(is_redeem_script)
                     {
-                        publishers_set.insert(publisher_hash);
-                        string publisher_str;
-                        if(is_redeem_script)
-                        {
-                            publisher_str=CBitcoinAddress((CScriptID)publisher_hash).ToString();
-                        }
-                        else
-                        {
-                            publisher_str=CBitcoinAddress((CKeyID)publisher_hash).ToString();                    
-                        }
-                        
-                        if(given_conditions)
-                        {
-                            for(int c=0;c<(int)(*given_conditions).size();c++)
-                            {
-                                if((*given_conditions)[c].m_Type == MC_QCT_PUBLISHER)
-                                {
-                                    if(strcmp(publisher_str.c_str(),(*given_conditions)[c].m_Value.c_str()) == 0)
-                                    {
-                                        (*given_conditions)[c].m_TmpMatch=true;
-                                    }                                                
-                                }
-                            }
-                        }
-                        
-                        publishers.push_back(publisher_str);
+                        publishers.push_back(CBitcoinAddress((CScriptID)publisher_hash).ToString());
                     }
-                }
-            }        
-        }
-
-        if(given_conditions)
-        {
-            for(int c=0;c<(int)(*given_conditions).size();c++)
-            {
-                if((*given_conditions)[c].m_Type == MC_QCT_PUBLISHER)
-                {
-                    if(!(*given_conditions)[c].m_TmpMatch)
+                    else
                     {
-                        stream_output=-1;                                                
+                        publishers.push_back(CBitcoinAddress((CKeyID)publisher_hash).ToString());                    
                     }
                 }
             }
-        }
-                        
-        if(stream_output < 0)
-        {
-            start_from++;
-        }
-    }
-
-    if(stream_output < 0)
-    {
-        return entry;
+        }        
     }
-
     
     entry.push_back(Pair("publishers", publishers));
-    entry.push_back(Pair("keys", keys));
-    if(mc_gState->m_Compatibility & MC_VCM_1_0)
-    {
-        entry.push_back(Pair("key", keys[0]));        
-    }
-    entry.push_back(Pair("offchain", (retrieve_status & MC_OST_STORAGE_MASK) == MC_OST_OFF_CHAIN));        
-    if( ( retrieve_status & MC_OST_CONTROL_NO_DATA ) == 0)
-    {
-        entry.push_back(Pair("available", AvailableFromStatus(retrieve_status)));        
-        if(retrieve_status & MC_OST_ERROR_MASK)
-        {
-            string error_str;
-            int errorCode;
-            error_str=OffChainError(retrieve_status,&errorCode);
-            entry.push_back(Pair("error", error_str));        
-        }
-    }
-    entry.push_back(Pair("data", format_item_value));        
+    entry.push_back(Pair("key", strprintf("%s",item_key)));
+    entry.push_back(Pair("data", item_value));        
     
     if(verbose)
     {
@@ -871,7 +548,6 @@ Object TxOutEntry(const CTxOut& TxOutIn,int vout,const CTxIn& TxIn,uint256 hash,
 
     Object txout_entry;
     Array permissions;
-    Array peroutputdata;
     isminetype fIsMine=ISMINE_NO;
     amounts->Clear();
 //    int iad=-1;
@@ -957,183 +633,13 @@ Object TxOutEntry(const CTxOut& TxOutIn,int vout,const CTxIn& TxIn,uint256 hash,
     if(fIsFound)
     {
         txout_entry.push_back(Pair("amount", ValueFromAmount(txout.nValue)));
-        Array assets;
-        assets=AssetArrayFromAmounts(amounts,-1,hash,fIsInput ? 0 : 1);
-        if( (assets.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-        {
-            txout_entry.push_back(Pair("assets", AssetArrayFromAmounts(amounts,-1,hash,fIsInput ? 0 : 1)));                
-        }
-        
+        txout_entry.push_back(Pair("assets", AssetArrayFromAmounts(amounts,-1,hash,fIsInput ? 0 : 1)));                
         if(!fIsInput)
         {
-            if( (permissions.size() > 0) || (mc_gState->m_Compatibility & MC_VCM_1_0) )
-            {
-                txout_entry.push_back(Pair("permissions", permissions));                            
-            }
-            
-            peroutputdata=PerOutputDataEntries(txout,lpScript,hash,vout);
-            if(peroutputdata.size())
-            {
-                txout_entry.push_back(Pair("data", peroutputdata));
-            }            
+            txout_entry.push_back(Pair("permissions", permissions));                            
         }
     }
 
     return txout_entry;
 }
 
-void AppendOffChainFormatData(uint32_t data_format,
-                              uint32_t out_options,
-                              mc_Script *lpDetailsScript,
-                              vector<unsigned char>& vValue,
-                              vector<uint256>* vChunkHashes,
-                              int *errorCode,
-                              string *strError)
-{
-    if((mc_gState->m_WalletMode & MC_WMD_TXS) == 0)
-    {
-        *strError="Offchain data is not supported with this wallet version. To get this functionality, run \"multichaind -walletdbversion=2 -rescan\"";
-        *errorCode=RPC_NOT_SUPPORTED;
-        return;
-    }   
-    mc_ChunkDBRow chunk_def;
-    lpDetailsScript->Clear();
-    
-    int chunk_count;
-    int tail_size,size,max_chunk_size;
-    int64_t total_size;
-    int fHan;
-    int err;
-    unsigned char *ptr;
-    uint256 hash;
-    mc_TxEntity entity;
-    entity.Zero();
-    entity.m_EntityType=MC_TET_AUTHOR;    
-    
-    if(out_options & MC_RFD_OPTION_OFFCHAIN)
-    {
-        chunk_count=(int)vValue.size()/MC_CDB_CHUNK_HASH_SIZE;
-        if(chunk_count > MAX_CHUNK_COUNT)
-        {
-            *strError="Too many chunks in the script";
-            return; 
-        }
-        
-        lpDetailsScript->SetChunkDefHeader(data_format,chunk_count);
-        for(int i=0;i<chunk_count;i++)
-        {
-            err=pwalletTxsMain->m_ChunkDB->GetChunkDef(&chunk_def,(unsigned char*)&vValue[i*MC_CDB_CHUNK_HASH_SIZE],&entity,NULL,-1);
-            if(err)
-            {
-                *strError="Chunk not found in this wallet";
-                return; 
-            }
-            lpDetailsScript->SetChunkDefHash((unsigned char*)&vValue[i*MC_CDB_CHUNK_HASH_SIZE],chunk_def.m_Size);
-            if(vChunkHashes)
-            {
-                vChunkHashes->push_back(*(uint256*)&vValue[i*MC_CDB_CHUNK_HASH_SIZE]);
-            }
-        }
-    }
-    else
-    {
-        chunk_count=0;
-        tail_size=0;
-        ptr=NULL;
-        fHan=-1;
-        if(vValue.size())
-        {
-            if(out_options & MC_RFD_OPTION_CACHE)
-            {            
-                fHan=mc_BinaryCacheFile((char*)&vValue[0],0);
-                if(fHan <= 0)
-                {
-                    *strError="Binary cache item with this identifier not found";
-                    return;                     
-                }
-                total_size=lseek64(fHan,0,SEEK_END);
-                if(lseek64(fHan,0,SEEK_SET) != 0)
-                {
-                    *strError="Cannot read binary cache item";
-                    close(fHan);
-                    return;                                         
-                }
-                if(total_size)
-                {
-                    chunk_count=(int)((total_size-1)/MAX_CHUNK_SIZE)+1;                    
-                }
-                tail_size=(int)(total_size-(int64_t)(chunk_count-1)*MAX_CHUNK_SIZE);            
-            }
-            else
-            {
-                chunk_count=((int)vValue.size()-1)/MAX_CHUNK_SIZE+1;            
-                tail_size=(int)vValue.size()-(chunk_count-1)*MAX_CHUNK_SIZE;            
-            }
-            max_chunk_size=tail_size;
-            if(chunk_count > 1)
-            {
-                max_chunk_size=MAX_CHUNK_SIZE;
-            }
-            mc_gState->m_TmpBuffers->m_RpcChunkScript1->Clear();
-            mc_gState->m_TmpBuffers->m_RpcChunkScript1->Resize(max_chunk_size,1);
-            ptr=mc_gState->m_TmpBuffers->m_RpcChunkScript1->m_lpData;
-            
-            lpDetailsScript->SetChunkDefHeader(data_format,chunk_count);
-            for(int i=0;i<chunk_count;i++)
-            {
-                size=MAX_CHUNK_SIZE;
-                if(i == chunk_count-1)
-                {
-                    size=tail_size;
-                }
-                if(fHan > 0)
-                {
-                    if(read(fHan,ptr,size) != size)
-                    {
-                        *errorCode=RPC_INTERNAL_ERROR;
-                        *strError="Cannot read binary cache item";
-                        close(fHan);
-                        return;                     
-                    }
-                }
-                else
-                {
-                    ptr=(unsigned char*)&vValue[i*MAX_CHUNK_SIZE];
-                }
-                
-                mc_gState->m_TmpBuffers->m_RpcHasher1->DoubleHash(ptr,size,&hash);
-                
-                err=pwalletTxsMain->m_ChunkDB->AddChunk((unsigned char*)&hash,&entity,NULL,-1,ptr,NULL,size,0,0);   
-                if(err)
-                {
-                    switch(err)
-                    {
-                        case MC_ERR_FOUND:
-                            break;
-                        default:
-                            *strError="Internal error: couldn't store chunk";
-                            if(fHan > 0)
-                            {
-                                close(fHan);
-                            }
-                            return; 
-                    }
-                }
-    
-                lpDetailsScript->SetChunkDefHash((unsigned char*)&hash,size);
-                if(vChunkHashes)
-                {
-                    vChunkHashes->push_back(*(uint256*)&hash);
-                }
-            }
-        }
-        if(fHan > 0)
-        {
-            close(fHan);
-            fHan=0;
-        }
-    }
-    
-//            err=pwalletTxsMain->m_ChunkDB->AddChunk((unsigned char*)&hash,&entity,NULL,-1,(unsigned char*)&vValue[0],NULL,(int)vValue.size(),0,0);
-}                             
-
diff --git a/src/script/interpreter.cpp b/src/script/interpreter.cpp
index 8f08b69..5091557 100644
--- a/src/script/interpreter.cpp
+++ b/src/script/interpreter.cpp
@@ -257,6 +257,10 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un
     int nOpCount = 0;
     bool fRequireMinimal = (flags & SCRIPT_VERIFY_MINIMALDATA) != 0;
 
+/* MCHN START */            
+    bool fLongElement=false;
+/* MCHN END */            
+    
     try
     {
         while (pc < pend)
@@ -268,7 +272,40 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, un
             //
             if (!script.GetOp(pc, opcode, vchPushValue))
                 return set_error(serror, SCRIPT_ERR_BAD_OPCODE);
-            
+/* MCHN START */            
+            if(fLongElement)
+            {
+                if(mc_gState->m_Features->FixedIn10007() == 0)
+                {
+                    if(opcode != OP_DROP)
+                    {
+                        return set_error(serror, SCRIPT_ERR_PUSH_SIZE);                    
+                    }                
+                }
+            }
+            if(mc_gState->m_Features->Streams())                                // It is now part of the IsStandard check
+            {
+                fLongElement=false;                                
+            }
+            else
+            {
+                if (vchPushValue.size() > MAX_SCRIPT_ELEMENT_SIZE)
+                {
+                    if(mc_gState->m_Features->VerifySizeOfOpDropElements() == 0)
+                    {
+                        fLongElement=true;                    
+                    }
+                    else
+                    {
+                        return set_error(serror, SCRIPT_ERR_PUSH_SIZE);
+                    }
+                }
+                else
+                {
+                    fLongElement=false;                
+                }
+            }
+/* MCHN END */            
             // Note how OP_RESERVED does not count towards the opcode limit.
             if (opcode > OP_16 && ++nOpCount > 201)
                 return set_error(serror, SCRIPT_ERR_OP_COUNT);
@@ -1149,11 +1186,14 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne
 //        return set_error(serror, SCRIPT_ERR_EVAL_FALSE);
 /* MCHN START */
         
-    if(!scriptSig.HasSmallIntegerInTheBeginning())
+    if(mc_gState->m_Features->Streams())
     {
-        if(stack.size() != 1)
+        if(!scriptSig.HasSmallIntegerInTheBeginning())
         {
-            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);                    
+            if(stack.size() != 1)
+            {
+                return set_error(serror, SCRIPT_ERR_EVAL_FALSE);                    
+            }
         }
     }
 /* MCHN END */
@@ -1168,28 +1208,31 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, unsigne
         unsigned int p2shflags=flags;
         CTxDestination addressRet;
 
-        if(!scriptSig.HasSmallIntegerInTheBeginning())
-        {
-            return set_error(serror, SCRIPT_ERR_EVAL_FALSE);                    
-        }
-        if(!ExtractDestination(scriptPubKey, addressRet))
-        {
-            return set_error(serror, SCRIPT_ERR_VERIFY);
-        }
-
-        if( (p2shflags & SCRIPT_VERIFY_SKIP_SEND_PERMISSION_CHECK) == 0)
+        if(mc_gState->m_Features->Streams())
         {
-            CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
-            if(lpScriptID)
+            if(!scriptSig.HasSmallIntegerInTheBeginning())
             {
-                if(mc_gState->m_Permissions->CanSend(NULL,(unsigned char*)(lpScriptID)))
-                {
-                    p2shflags |= SCRIPT_VERIFY_SKIP_SEND_PERMISSION_CHECK;
-                }                
+                return set_error(serror, SCRIPT_ERR_EVAL_FALSE);                    
             }
-            else
+            if(!ExtractDestination(scriptPubKey, addressRet))
             {
-                return set_error(serror, SCRIPT_ERR_VERIFY);                
+                return set_error(serror, SCRIPT_ERR_VERIFY);
+            }
+
+            if( (p2shflags & SCRIPT_VERIFY_SKIP_SEND_PERMISSION_CHECK) == 0)
+            {
+                CScriptID *lpScriptID=boost::get<CScriptID> (&addressRet);
+                if(lpScriptID)
+                {
+                    if(mc_gState->m_Permissions->CanSend(NULL,(unsigned char*)(lpScriptID)))
+                    {
+                        p2shflags |= SCRIPT_VERIFY_SKIP_SEND_PERMISSION_CHECK;
+                    }                
+                }
+                else
+                {
+                    return set_error(serror, SCRIPT_ERR_VERIFY);                
+                }
             }
         }
  
diff --git a/src/script/script.cpp b/src/script/script.cpp
index 5f6e894..863f138 100644
--- a/src/script/script.cpp
+++ b/src/script/script.cpp
@@ -215,20 +215,13 @@ unsigned int CScript::GetSigOpCount(const CScript& scriptSig) const
 bool CScript::IsPayToScriptHash() const
 {
     // Extra-fast test for pay-to-script-hash CScripts:
+/* MCHN START*/    
 //    return (this->size() == 23 &&
-    if(mc_gState->m_NetworkParams->IsProtocolMultichain())
-    {
-        return (this->size() >= 23 &&
-                this->at(0) == OP_HASH160 &&
-                this->at(1) == 0x14 &&
-                this->at(22) == OP_EQUAL);
-    }
-    
-        return (this->size() == 23 &&
-                this->at(0) == OP_HASH160 &&
-                this->at(1) == 0x14 &&
-                this->at(22) == OP_EQUAL);
-    
+    return (this->size() >= 23 &&
+/* MCHN END*/    
+            this->at(0) == OP_HASH160 &&
+            this->at(1) == 0x14 &&
+            this->at(22) == OP_EQUAL);
 }
 
 bool CScript::IsPushOnly() const
diff --git a/src/script/script.h b/src/script/script.h
index 6bc2367..ff6c542 100644
--- a/src/script/script.h
+++ b/src/script/script.h
@@ -21,7 +21,6 @@
 /* MCHN END */
 
 extern unsigned int MAX_SCRIPT_ELEMENT_SIZE;                                    // MCHN global
-extern unsigned int MAX_OP_RETURN_OP_DROP_COUNT;                                // MCHN global
 //static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes
 
 template <typename T>
@@ -602,16 +601,17 @@ public:
      * regardless of the initial stack. This allows outputs to be pruned
      * instantly when entering the UTXO set.
      */
-    bool IsUnspendable() const;
-/*    
+    bool IsUnspendable() const
     {
+/* MCHN START */        
         int op_drop_offset[2];
         int op_drop_size[2];
         int op_return_offset,op_return_size;
         return (mc_ParseOpDropOpReturnScript((unsigned char*)&begin()[0],(int)size(),op_drop_offset,op_drop_size,2,&op_return_offset,&op_return_size)) != NULL;        
 //        return (size() > 0 && *begin() == OP_RETURN);
+/* MCHN END */        
     }
-*/
+
     std::string ToString() const;
 
 /* MCHN START */    
diff --git a/src/script/standard.cpp b/src/script/standard.cpp
index ce040d9..e372336 100644
--- a/src/script/standard.cpp
+++ b/src/script/standard.cpp
@@ -64,10 +64,14 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi
 /* MCHN START*/    
         if(mc_gState->m_NetworkParams->IsProtocolMultichain())
         {
-            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_RETURN));            
-            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_RETURN << OP_SMALLDATA));            
-            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_DROPDATA << OP_DROP << OP_RETURN));            
-            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_DROPDATA << OP_DROP << OP_RETURN << OP_SMALLDATA));            
+            if(mc_gState->m_Features->Streams())
+            {
+                mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_RETURN));            
+                mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_RETURN << OP_SMALLDATA));            
+                mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_DROPDATA << OP_DROP << OP_RETURN));            
+                mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_DROPDATA << OP_DROP << OP_DROPDATA << OP_DROP << OP_RETURN << OP_SMALLDATA));            
+            }
+        
         }
         
         mTemplates.insert(make_pair(TX_SCRIPTHASH, CScript() << OP_HASH160 << OP_PUBKEYHASH << OP_EQUAL));
@@ -186,8 +190,11 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi
             else if (opcode2 == OP_DROPDATA)
             {
                 // small pushdata, <= nMaxDatacarrierBytes
-                if (vch1.size() > MAX_SCRIPT_ELEMENT_SIZE)
-                    break;
+                if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+                {
+                    if (vch1.size() > MAX_SCRIPT_ELEMENT_SIZE)
+                        break;
+                }
             }
 /* MCHN END */        
             else if (opcode1 != opcode2 || vch1 != vch2)
@@ -377,19 +384,11 @@ bool IsStandardNullData(const CScript& scriptPubKey,bool standard_check)
     vector<unsigned char> vch;
     bool recheck=false;
     bool fixed=(mc_gState->m_Features->FixedDestinationExtraction() != 0);
-    int op_drop_count=0;
+	int op_drop_count=0;
     int max_op_drop_count=2;
-    bool check_sizes=false;
-
-    if( !fixed || standard_check )
-    {
-        check_sizes=true;
-    }
-    
-    if(mc_gState->m_Features->FormattedData())
-    {    
-        max_op_drop_count=MAX_OP_RETURN_OP_DROP_COUNT;
-    }
+    unsigned int sizes[2];
+    sizes[0]=0;
+    sizes[1]=0;
     
     CScript::const_iterator pc = scriptPubKey.begin();
     
@@ -416,13 +415,7 @@ bool IsStandardNullData(const CScript& scriptPubKey,bool standard_check)
         {
             if( opcode < OP_PUSHDATA1 )
             {
-                if(check_sizes)
-                {
-                    if( (unsigned int)opcode > MAX_SCRIPT_ELEMENT_SIZE )
-                    {
-                        return false;
-                    }                                
-                }
+                sizes[op_drop_count]=(unsigned int)opcode;
             }
             else
             {
@@ -472,17 +465,7 @@ bool IsStandardNullData(const CScript& scriptPubKey,bool standard_check)
             scriptPubKey.GetOp(pc, opcode);
             if(opcode >= OP_PUSHDATA1)
             {
-                if(mc_gState->m_Features->FormattedData())
-                {
-                    if(opcode > OP_16)
-                    {
-                        return false;                        
-                    }
-                }
-                else
-                {
-                    return false;
-                }
+                return false;
             }
             if( !fixed || standard_check )
             {
@@ -498,79 +481,57 @@ bool IsStandardNullData(const CScript& scriptPubKey,bool standard_check)
         }
     }
 
-    if(check_sizes && recheck)
+    if(mc_gState->m_Features->VerifySizeOfOpDropElements())
     {
-        pc = scriptPubKey.begin();
-
-        op_drop_count=0;
-        while( op_drop_count < max_op_drop_count+1 )
-        {
-            scriptPubKey.GetOp(pc, opcode, vch);
-            if(opcode == OP_RETURN)
-            {
-                op_drop_count=max_op_drop_count+1;
-            }
-            if( opcode >= OP_PUSHDATA1 )
-            {
-                if( opcode <= OP_PUSHDATA4 )
-                {
-                    if( (unsigned int)vch.size() > MAX_SCRIPT_ELEMENT_SIZE )
-                    {
-                        return false;
-                    }                                
-                }            
-            }
-            if(op_drop_count < max_op_drop_count+1)
-            {
-                scriptPubKey.GetOp(pc, opcode);
-                op_drop_count++;
-            }        
-        }                       
-
-/*        
-        for(op_drop_count=0;op_drop_count<max_op_drop_count;op_drop_count++)
-        {
-            if( sizes[op_drop_count] > MAX_SCRIPT_ELEMENT_SIZE )
-            {
-                return false;
-            }            
-        }
- */ 
-/*        
-        if( (sizes[0] > MAX_SCRIPT_ELEMENT_SIZE) || (sizes[1] > MAX_SCRIPT_ELEMENT_SIZE) )
+        if( !fixed || standard_check )
         {
-            return false;
+		    if(recheck)
+		    {
+		        pc = scriptPubKey.begin();
+
+		        op_drop_count=0;
+		        while( op_drop_count < max_op_drop_count+1 )
+		        {
+		            scriptPubKey.GetOp(pc, opcode, vch);
+		            if(opcode == OP_RETURN)
+		            {
+		                op_drop_count=max_op_drop_count+1;
+		            }
+		            if( opcode >= OP_PUSHDATA1 )
+		            {
+		                if( opcode <= OP_PUSHDATA4 )
+		                {
+		                    sizes[op_drop_count]=(unsigned int)vch.size();
+		                }            
+		            }
+		            if(op_drop_count < max_op_drop_count+1)
+		            {
+		                scriptPubKey.GetOp(pc, opcode);
+		                op_drop_count++;
+		            }        
+		        }                       
+		    }
+
+		    for(op_drop_count=0;op_drop_count<max_op_drop_count;op_drop_count++)
+		    {
+		        if( sizes[op_drop_count] > MAX_SCRIPT_ELEMENT_SIZE )
+		        {
+		            return false;
+		        }            
+		    }
         }
-*/        
     }
     
     return true;
 }
 
-bool CScript::IsUnspendable() const
-{
-    if(mc_gState->m_Features->FixedIsUnspendable() == 0)
-    {
-        int op_drop_offset[2];
-        int op_drop_size[2];
-        int op_return_offset,op_return_size;
-        return (mc_ParseOpDropOpReturnScript((unsigned char*)&begin()[0],(int)size(),op_drop_offset,op_drop_size,2,&op_return_offset,&op_return_size)) != NULL;                
-    }
-    return IsStandardNullData(*this,false);
-}
-
-
-bool ExtractDestinations10008(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet, bool no_clear, bool *not_cleared)
+bool ExtractDestinations10008(const CScript& scriptPubKey, txnouttype& typeRet, vector<CTxDestination>& addressRet, int& nRequiredRet)
 {
     addressRet.clear();
     typeRet = TX_NONSTANDARD;
     opcodetype opcode;
     vector<unsigned char> vch;
 
-    if(not_cleared)
-    {
-        *not_cleared=false;
-    }
     nRequiredRet=1;
     
     CScript::const_iterator pc = scriptPubKey.begin();
@@ -652,17 +613,7 @@ bool ExtractDestinations10008(const CScript& scriptPubKey, txnouttype& typeRet,
         return true;
     }
     
-    if(!no_clear)
-    {
-        addressRet.clear();
-    }
-    else
-    {
-        if(not_cleared)
-        {
-            *not_cleared=true;
-        }        
-    }
+    addressRet.clear();
     typeRet = TX_NONSTANDARD;
     return true;
 }
@@ -688,7 +639,7 @@ bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, vecto
 {
     if(mc_gState->m_Features->FixedDestinationExtraction() == 0)
     {
-        return ExtractDestinations10008(scriptPubKey,typeRet,addressRet,nRequiredRet,false,NULL);
+        return ExtractDestinations10008(scriptPubKey,typeRet,addressRet,nRequiredRet);
     }
     
     addressRet.clear();
@@ -897,7 +848,6 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)
     vector<unsigned char> vch;
     whichType = TX_NONSTANDARD;
     int max_op_drops;
-    bool result;
 
     CScript::const_iterator pc = scriptPubKey.begin();
     
@@ -946,16 +896,7 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)
                 }
                 else
                 {
-                    result=IsStandardFull(scriptPubKey,whichType);
-                    if( (whichType == TX_PUBKEY) || (whichType == TX_MULTISIG) )
-                    {
-                        return result;
-                    }
-                    else                                                        // Avoiding duplicate check for other type
-                    {
-                        whichType = TX_NONSTANDARD;
-                        return false;
-                    }
+                    return IsStandardFull(scriptPubKey,whichType);
                 }
             }
         }
@@ -963,27 +904,54 @@ bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType)
 
     max_op_drops=MCP_STD_OP_DROP_COUNT;
     
-    for(int d=0;d<max_op_drops;d++)
+    if(mc_gState->m_Features->VerifySizeOfOpDropElements())
     {
-        if (pc < scriptPubKey.end())                                            
+        for(int d=0;d<max_op_drops;d++)
         {
-            if ( !scriptPubKey.GetOp(pc, opcode, vch) || (vch.size() > MAX_SCRIPT_ELEMENT_SIZE) )
+            if (pc < scriptPubKey.end())                                            
             {
-                whichType = TX_NONSTANDARD;
-                return false;
+                if ( !scriptPubKey.GetOp(pc, opcode, vch) || (vch.size() > MAX_SCRIPT_ELEMENT_SIZE) )
+                {
+                    whichType = TX_NONSTANDARD;
+                    return false;
+                }
+                if ( !scriptPubKey.GetOp(pc, opcode) || (opcode != OP_DROP) )
+                {
+                    whichType = TX_NONSTANDARD;
+                    return false;
+                }
             }
-            if ( !scriptPubKey.GetOp(pc, opcode) || (opcode != OP_DROP) )
+            else
             {
-                whichType = TX_NONSTANDARD;
-                return false;
+                return true;
             }
         }
-        else
+    }
+    else
+    {
+        for(int d=0;d<max_op_drops;d++)
         {
-            return true;
-        }
+            if (pc < scriptPubKey.end())                                            
+            {
+                if ( !scriptPubKey.GetOp(pc, opcode) )
+                {
+                    whichType = TX_NONSTANDARD;
+                    return false;
+                }
+                if ( !scriptPubKey.GetOp(pc, opcode) || (opcode != OP_DROP) )
+                {
+                    whichType = TX_NONSTANDARD;
+                    return false;
+                }
+            }        
+            else
+            {
+                return true;
+            }
+        }        
     }
     
+    
     if (pc < scriptPubKey.end())                                                
     {
         whichType = TX_NONSTANDARD;
diff --git a/src/structs/base58.cpp b/src/structs/base58.cpp
index bbe4b3d..9e117bc 100644
--- a/src/structs/base58.cpp
+++ b/src/structs/base58.cpp
@@ -262,90 +262,81 @@ std::string BurnAddress(const std::vector<unsigned char>& vchVersion)
     char res[100];    
     
     int shift=nDataBytes / nVersionBytes;
-    CKeyID kBurn;
+    vch.resize(nDataBytes + nVersionBytes + nHashBytes);
     int p;
-    
-    if(*(uint160*)(mc_gState->m_BurnAddress) == 0)
+    for(int i=2;i<nDataBytes + nVersionBytes + nHashBytes;i++)
     {
-        vch.resize(nDataBytes + nVersionBytes + nHashBytes);
-        for(int i=2;i<nDataBytes + nVersionBytes + nHashBytes;i++)
-        {
-            vch[i]=0x00;
-        }
-        vch[0]=vchVersion[0];
-        vch[1]=0x80;
-
+        vch[i]=0x00;
+    }
+    vch[0]=vchVersion[0];
+    vch[1]=0x80;
 
-        strcpy(res,EncodeBase58(vch).c_str());
-        memset(res+1,'X',strlen(res)-1);
+    
+    strcpy(res,EncodeBase58(vch).c_str());
+    memset(res+1,'X',strlen(res)-1);
+    DecodeBase58(res,vch);
+    while((int)vch.size() > nDataBytes + nVersionBytes + nHashBytes)
+    {
+        res[strlen(res)-1]=0x00;
         DecodeBase58(res,vch);
-        while((int)vch.size() > nDataBytes + nVersionBytes + nHashBytes)
-        {
-            res[strlen(res)-1]=0x00;
-            DecodeBase58(res,vch);
-        }
+    }
 
-        p=0;
-        while(p<nDataBytes + nVersionBytes)
+    p=0;
+    while(p<nDataBytes + nVersionBytes)
+    {
+        if( (p % (shift+1)) == 0)
         {
-            if( (p % (shift+1)) == 0)
+            if(vch[p] != vchVersion[p / (shift+1)])
             {
-                if(vch[p] != vchVersion[p / (shift+1)])
+                memset(&vch[p+2],0x00,vch.size()-p-2);
+                vch[p] = vchVersion[p / (shift+1)];
+                vch[p+1] = 0x80;
+                strcpy(test,EncodeBase58(vch).c_str());
+                if(strlen(test) != strlen(res))
                 {
-                    memset(&vch[p+2],0x00,vch.size()-p-2);
-                    vch[p] = vchVersion[p / (shift+1)];
-                    vch[p+1] = 0x80;
-                    strcpy(test,EncodeBase58(vch).c_str());
-                    if(strlen(test) != strlen(res))
+                    if(strlen(test) > strlen(res))
                     {
-                        if(strlen(test) > strlen(res))
-                        {
-                            res[strlen(res)+1]=0x00;
-                            res[strlen(res)]='X';
-                        }                        
-                        if(strlen(test) < strlen(res))
-                        {
-                            res[strlen(res)-1]=0x00;
-                        }                        
-                    }
-                    int j=0;
-                    while( (j<(int)strlen(res)) && (res[j] == test[j]) )
+                        res[strlen(res)+1]=0x00;
+                        res[strlen(res)]='X';
+                    }                        
+                    if(strlen(test) < strlen(res))
                     {
-                        j++;
-                    }
-                    int k=0;
-                    while( (k<3) && (j<(int)strlen(res)) && ((vch[p] != vchVersion[p / (shift+1)])  || (k ==0)))
-                    {
-                        res[j]=test[j];
-                        DecodeBase58(res,vch);
-                        k++;
-                        j++;
-                    }                
+                        res[strlen(res)-1]=0x00;
+                    }                        
                 }
+                int j=0;
+                while( (j<(int)strlen(res)) && (res[j] == test[j]) )
+                {
+                    j++;
+                }
+                int k=0;
+                while( (k<3) && (j<(int)strlen(res)) && ((vch[p] != vchVersion[p / (shift+1)])  || (k ==0)))
+                {
+                    res[j]=test[j];
+                    DecodeBase58(res,vch);
+                    k++;
+                    j++;
+                }                
             }
-            p++;
-        }
-
-    //    strcpy(test,EncodeBase58(vch).c_str());
-
-
-        for(int i=0;i<(int)nVersionBytes;i++)
-        {
-            int size=shift;
-            if(i == (int)(nVersionBytes-1))
-            {
-                size=nDataBytes-i*shift;
-            }
-            memcpy(data+i*shift,&vch[i*(shift+1)+1],size);
         }
-
-        memcpy(&kBurn,data,nDataBytes);
-        memcpy(mc_gState->m_BurnAddress,data,nDataBytes);
+        p++;
     }
-    else
+    
+//    strcpy(test,EncodeBase58(vch).c_str());
+  
+    
+    for(int i=0;i<(int)nVersionBytes;i++)
     {
-        memcpy(&kBurn,mc_gState->m_BurnAddress,nDataBytes);        
+        int size=shift;
+        if(i == (int)(nVersionBytes-1))
+        {
+            size=nDataBytes-i*shift;
+        }
+        memcpy(data+i*shift,&vch[i*(shift+1)+1],size);
     }
+    
+    CKeyID kBurn;
+    memcpy(&kBurn,data,nDataBytes);
   
     CBitcoinAddress ba;
     ba.Set(kBurn,vchVersion);
diff --git a/src/structs/uint256.cpp b/src/structs/uint256.cpp
index fa4f9ef..cc5d915 100644
--- a/src/structs/uint256.cpp
+++ b/src/structs/uint256.cpp
@@ -216,14 +216,6 @@ unsigned int base_uint<BITS>::bits() const
     return 0;
 }
 
-// Explicit instantiations for base_uint<96>
-template int base_uint<96>::CompareTo(const base_uint<96>&) const;
-template bool base_uint<96>::EqualTo(uint64_t) const;
-template std::string base_uint<96>::GetHex() const;
-template std::string base_uint<96>::ToString() const;
-
-
-
 // Explicit instantiations for base_uint<160>
 template base_uint<160>::base_uint(const std::string&);
 template base_uint<160>::base_uint(const std::vector<unsigned char>&);
diff --git a/src/structs/uint256.h b/src/structs/uint256.h
index 5647410..7f39dd7 100644
--- a/src/structs/uint256.h
+++ b/src/structs/uint256.h
@@ -286,14 +286,6 @@ public:
     }
 };
 
-/** 96-bit unsigned big integer. */
-class uint96 : public base_uint<96> {
-public:
-    uint96() {}
-    uint96(const base_uint<96>& b) : base_uint<96>(b) {}
-    uint96(uint64_t b) : base_uint<96>(b) {}
-};
-
 /** 160-bit unsigned big integer. */
 class uint160 : public base_uint<160> {
 public:
diff --git a/src/utils/dbwrapper.cpp b/src/utils/dbwrapper.cpp
index f689795..d76f05c 100644
--- a/src/utils/dbwrapper.cpp
+++ b/src/utils/dbwrapper.cpp
@@ -410,12 +410,10 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
 {
     char *err = NULL;
     const char *lpIterRead;
-    const char *lpIterReadKey;
     char *lpRead;
     char *lpNewBuffer;
     int NewSize;
     size_t vallen;
-    size_t kallen;
 
     int klen=key_len;
     
@@ -437,7 +435,6 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
 
     lpRead=NULL;
     lpIterRead=NULL;
-    lpIterReadKey=NULL;
     
     switch(m_Options & MC_OPT_DB_DATABASE_TYPE_MASK)
     {
@@ -446,7 +443,7 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
 //            *error=MC_ERR_NOT_SUPPORTED;
 //            return NULL;
 
-            if(Options & (MC_OPT_DB_DATABASE_SEEK_ON_READ | MC_OPT_DB_DATABASE_NEXT_ON_READ) )
+            if(Options & MC_OPT_DB_DATABASE_SEEK_ON_READ)
             {
 //                *error=MC_ERR_OPERATION_NOT_SUPPORTED;
 //                return NULL;                
@@ -462,10 +459,10 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
                 leveldb_iter_seek((leveldb_iterator_t*)m_Iterator, key, klen);
                 if(leveldb_iter_valid((leveldb_iterator_t*)m_Iterator))
                 {
-                    lpIterReadKey=leveldb_iter_key((leveldb_iterator_t*)m_Iterator, &kallen);
-                    if(lpIterReadKey)
+                    lpIterRead=leveldb_iter_key((leveldb_iterator_t*)m_Iterator, &vallen);
+                    if(lpIterRead)
                     {
-                        if( ((int)kallen == klen) && ( ((Options & MC_OPT_DB_DATABASE_NEXT_ON_READ) != 0) || (memcmp(lpIterReadKey,key,klen) == 0) ) )
+                        if( ((int)vallen == klen) && (memcmp(lpIterRead,key,klen) == 0) )
                         {
                             lpIterRead=leveldb_iter_value((leveldb_iterator_t*)m_Iterator, &vallen);                            
                         }
@@ -502,9 +499,9 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
             break;
     }
     
-    if(*value_len+klen+1>m_ReadBufferSize)
+    if(*value_len+1>m_ReadBufferSize)
     {
-        NewSize=((*value_len+klen)/MC_DCT_DB_READ_BUFFER_SIZE + 1) * MC_DCT_DB_READ_BUFFER_SIZE;
+        NewSize=((*value_len)/MC_DCT_DB_READ_BUFFER_SIZE + 1) * MC_DCT_DB_READ_BUFFER_SIZE;
         lpNewBuffer=(char*)mc_New(NewSize);
         if(lpNewBuffer  == NULL)
         {
@@ -521,22 +518,12 @@ char *cs_Database::Read(char *key,int key_len,int *value_len,int Options,int *er
     if(lpRead)
     {
         memcpy(m_ReadBuffer,lpRead,*value_len);
-        m_ReadBuffer[*value_len]=0;
     }
     if(lpIterRead)
     {
-        if(Options & MC_OPT_DB_DATABASE_NEXT_ON_READ)
-        {
-            memcpy(m_ReadBuffer,lpIterReadKey,klen);
-            memcpy(m_ReadBuffer+klen,lpIterRead,*value_len);
-            m_ReadBuffer[klen+*value_len]=0;
-        }
-        else
-        {
-            memcpy(m_ReadBuffer,lpIterRead,*value_len);
-            m_ReadBuffer[*value_len]=0;
-        }
+        memcpy(m_ReadBuffer,lpIterRead,*value_len);
     }
+    m_ReadBuffer[*value_len]=0;
     
     switch(m_Options & MC_OPT_DB_DATABASE_TYPE_MASK)
     {
@@ -624,14 +611,7 @@ int cs_Database::Commit(int Options)
 
             if(Options & MC_OPT_DB_DATABASE_TRANSACTIONAL)
             {
-                if(Options & MC_OPT_DB_DATABASE_SYNC_ON_COMMIT)
-                {
-                    leveldb_write((leveldb_t*)m_DB, (leveldb_writeoptions_t*)m_SyncOptions, (leveldb_writebatch_t*)m_WriteBatch, &err);        
-                }
-                else
-                {
-                    leveldb_write((leveldb_t*)m_DB, (leveldb_writeoptions_t*)m_WriteOptions, (leveldb_writebatch_t*)m_WriteBatch, &err);                            
-                }
+                leveldb_write((leveldb_t*)m_DB, (leveldb_writeoptions_t*)m_WriteOptions, (leveldb_writebatch_t*)m_WriteBatch, &err);        
                 leveldb_writebatch_clear((leveldb_writebatch_t*)m_WriteBatch);
             }
 
diff --git a/src/utils/dbwrapper.h b/src/utils/dbwrapper.h
index 2c00e32..2339365 100644
--- a/src/utils/dbwrapper.h
+++ b/src/utils/dbwrapper.h
@@ -25,8 +25,6 @@
 #define MC_OPT_DB_DATABASE_READONLY                         0x00000004
 #define MC_OPT_DB_DATABASE_SEEK_ON_READ                     0x00000010
 #define MC_OPT_DB_DATABASE_DELAYED_OPEN                     0x00000020
-#define MC_OPT_DB_DATABASE_NEXT_ON_READ                     0x00000040
-#define MC_OPT_DB_DATABASE_SYNC_ON_COMMIT                   0x00000080
 #define MC_OPT_DB_DATABASE_OPTION_MASK                      0x000FFFFF
 #define MC_OPT_DB_DATABASE_LEVELDB                          0x00100000
 #define MC_OPT_DB_DATABASE_FSR_UTXOC_BLOCKS                 0x00200000
diff --git a/src/utils/declare.h b/src/utils/declare.h
index e379edf..2d3c17b 100644
--- a/src/utils/declare.h
+++ b/src/utils/declare.h
@@ -35,7 +35,6 @@ typedef struct mc_MapStringIndex
     void Remove(const char* key,int size);
     int Get(const char* key);
     int Get(const unsigned char* key,int size);
-    void Set(const unsigned char* key,int size,int value);
     void Destroy();
     void Clear();
 } mc_MapStringIndex;
@@ -91,7 +90,6 @@ typedef struct mc_Buffer
     int Seek(void *lpKey);
     unsigned char *GetRow(int RowID);    
     int PutRow(int RowID,const void *lpKey,const void *lpValue);    
-    int UpdateRow(int RowID,const void *lpKey,const void *lpValue);    
     int GetCount();    
     int SetCount(int count);
     
@@ -140,8 +138,6 @@ typedef struct mc_SHA256
     void Write(const void *lpData,int size);
     void GetHash(unsigned char *hash);
     
-    void DoubleHash(const void *lpData,int size,void *hash);
-    
     mc_SHA256()
     {
         Init();
@@ -208,7 +204,6 @@ void *mc_New(int Size);
 void mc_Delete(void *ptr);
 void mc_PutLE(void *dest,void *src,int dest_size);
 int64_t mc_GetLE(void *src,int size);
-uint32_t mc_SwapBytes32(uint32_t src);
 int mc_BackupFile(const char *network_name,const char *filename, const char *extension,int options);
 int mc_RecoverFile(const char *network_name,const char *filename, const char *extension,int options);
 FILE *mc_OpenFile(const char *network_name,const char *filename, const char *extension,const char *mode, int options);        
@@ -234,13 +229,11 @@ double mc_TimeNowAsDouble();
 int mc_GetFullFileName(const char *network_name,const char *filename, const char *extension,int options,char *buf);
 int64_t mc_GetVarInt(const unsigned char *buf,int max_size,int64_t default_value,int* shift);
 int mc_PutVarInt(unsigned char *buf,int max_size,int64_t value);
-int mc_BuildDescription(int build, char *desc);
 
 void mc_GetCompoundHash160(void *result,const void  *hash1,const void  *hash2);
 int mc_SetIPv4ServerAddress(const char* host);
 int mc_FindIPv4ServerAddress(uint32_t *all_ips,int max_ips);
 int mc_GenerateConfFiles(const char *network_name);
-void mc_CreateDir(const char *dir_name);
 void mc_RemoveDataDir(const char *network_name);
 void mc_RemoveDir(const char *network_name,const char *dir_name);
 int mc_GetDataDirArg(char *buf);
@@ -249,7 +242,6 @@ void mc_SetDataDirArg(char *buf);
 void mc_ExpandDataDirParam();
 void mc_CheckDataDirInConfFile();
 void mc_AdjustStartAndCount(int *count,int *start,int size);
-void* custom_get_blockchain_default(const char *param,int* size,void *param_in);
 
 
 int mc_TestScenario(char* scenario_file);
@@ -261,7 +253,6 @@ void mc_StringLowerCase(char *buf,uint32_t len);
 int mc_StringCompareCaseInsensitive(const char *str1,const char *str2,int len);
 
 uint32_t mc_GetParamFromDetailsScript(const unsigned char *ptr,uint32_t total,uint32_t offset,uint32_t* param_value_start,size_t *bytes);
-uint32_t mc_GetParamFromDetailsScriptErr(const unsigned char *ptr,uint32_t total,uint32_t offset,uint32_t* param_value_start,size_t *bytes, int *err);
 uint32_t mc_FindSpecialParamInDetailsScript(const unsigned char *ptr,uint32_t total,uint32_t param,size_t *bytes);
 uint32_t mc_FindNamedParamInDetailsScript(const unsigned char *ptr,uint32_t total,const char *param,size_t *bytes);
 
@@ -284,9 +275,6 @@ uint64_t __US_ThreadID();
 const char* __US_UserHomeDir();
 char * __US_FullPath(const char* path, char *full_path, int len);
 void __US_FlushFile(int FileHan);
-void __US_FlushFileWithMode(int FileHan,uint32_t use_data_sync);
-int __US_DeleteFile(const char *file_name);
-void sprintf_hex(char *hex,const unsigned char *bin,int size);
 
 
 
diff --git a/src/utils/systemdependent.cpp b/src/utils/systemdependent.cpp
index b892186..3abfbdb 100644
--- a/src/utils/systemdependent.cpp
+++ b/src/utils/systemdependent.cpp
@@ -229,27 +229,6 @@ void __US_FlushFile(int FileHan)
     fsync(FileHan);
 }
 
-void __US_FlushFileWithMode(int FileHan,uint32_t use_data_sync)
-{
-    if(use_data_sync)
-    {
-#ifdef MAC_OSX
-        fcntl(FileHan, F_FULLFSYNC, 0);
-#else
-        fdatasync(FileHan);
-#endif        
-    }
-    else
-    {
-        fsync(FileHan);
-    }
-}
-
-int __US_DeleteFile(const char *file_name)
-{
-    return unlink(file_name);
-}
-
 #else
 
 #include "windows.h"
@@ -325,16 +304,4 @@ void __US_FlushFile(int FileHan)
     FlushFileBuffers(hFile);
 }
 
-void __US_FlushFileWithMode(int FileHan,uint32_t use_data_sync)
-{
-    HANDLE hFile = (HANDLE)_get_osfhandle(FileHan);
-    FlushFileBuffers(hFile);
-}
-
-int __US_DeleteFile(const char *file_name)
-{
-    return (int)DeleteFile(file_name);
-}
-
-
 #endif
diff --git a/src/utils/tools.cpp b/src/utils/tools.cpp
index ede25ea..770194d 100644
--- a/src/utils/tools.cpp
+++ b/src/utils/tools.cpp
@@ -68,17 +68,6 @@ int mc_MapStringIndex::Get(const unsigned char* key,int size)
     return value;
 }
 
-void mc_MapStringIndex::Set(const unsigned char* key,int size, int value)
-{
-    std::map<string, int>::iterator it;
-    it=((std::map<string, int>*)mapObject)->find(string(key,key+size));
-    if (it != ((std::map<string, int>*)mapObject)->end())
-    {
-        it->second=value;
-    }    
-}
-
-
 void mc_MapStringString::Init()
 {
     mapObject=new std::map<string, string>;
diff --git a/src/utils/util.cpp b/src/utils/util.cpp
index e39a9bf..3599bc6 100644
--- a/src/utils/util.cpp
+++ b/src/utils/util.cpp
@@ -853,75 +853,3 @@ void SetThreadPriority(int nPriority)
 #endif // PRIO_THREAD
 #endif // WIN32
 }
-
-
-std::string mc_SupportedProtocols()
-{
-    std::string protocol_list;
-    int protocol_min,protocol_max,protocol_next,this_build,next_build,out_it;
-    
-    protocol_list="";
-    this_build=mc_gState->GetNumericVersion();
-    protocol_next=mc_gState->MinProtocolVersion();
-    protocol_min=0;
-    protocol_max=-1;
-    next_build=-mc_gState->VersionInfo(protocol_next);
-    
-    while(next_build <= this_build)
-    {
-        out_it=0;
-        if(next_build > 0)
-        {
-            if(next_build == this_build)
-            {
-                if(protocol_min == 0)
-                {
-                    protocol_min=protocol_next;                    
-                }
-                protocol_max=protocol_next;
-            }
-            else
-            {
-                out_it=1;
-            }
-            protocol_next++;
-        }
-        else
-        {
-            out_it=1;   
-            protocol_next=-next_build;
-        }
-        next_build=-mc_gState->VersionInfo(protocol_next);
-        if(next_build > this_build)
-        {
-            out_it=1;
-        }
-        if(out_it)
-        {
-            if(protocol_list.size())
-            {
-                protocol_list += ", ";
-            }
-            if(protocol_max > protocol_min)
-            {
-                protocol_list += strprintf("%d-%d",protocol_min,protocol_max);
-            }
-            else
-            {
-                protocol_list += strprintf("%d",protocol_min);                
-            }
-            protocol_min=0;
-            protocol_max=-1;
-        }
-    }
-    
-    
-    return protocol_list;    
-}
-
-std::string mc_BuildDescription(int build)
-{
-    char build_desc[32];
-    mc_BuildDescription(build,build_desc);
-    return std::string(build_desc);
-}
diff --git a/src/utils/util.h b/src/utils/util.h
index 710a711..f3e89df 100644
--- a/src/utils/util.h
+++ b/src/utils/util.h
@@ -94,9 +94,6 @@ int RaiseFileDescriptorLimit(int nMinFD);
 void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);
 bool RenameOver(boost::filesystem::path src, boost::filesystem::path dest);
 bool TryCreateDirectory(const boost::filesystem::path& p);
-std::string mc_SupportedProtocols();
-std::string mc_BuildDescription(int build);
-
 boost::filesystem::path GetDefaultDataDir();
 const boost::filesystem::path &GetDataDir(bool fNetSpecific = true);
 boost::filesystem::path GetConfigFile();
diff --git a/src/utils/utility.cpp b/src/utils/utility.cpp
index 3ebf0d7..ed891a3 100644
--- a/src/utils/utility.cpp
+++ b/src/utils/utility.cpp
@@ -89,20 +89,6 @@ int64_t mc_GetLE(void *src,int size)
     return result;                                                              // Assuming all systems are little endian
 }
 
-uint32_t mc_SwapBytes32(uint32_t src)
-{
-    uint32_t res=0;
-    unsigned char *pr;
-    unsigned char *ps;
-    pr=(unsigned char*)&res;
-    ps=(unsigned char*)&src;
-    for(int i=0;i<4;i++)
-    {
-        pr[3-i]=ps[i];        
-    }
-    return res;
-}
-
 void mc_print(const char *message)
 {
     printf("%s\n",message);
@@ -451,14 +437,7 @@ int mc_Buffer::Add(const void *lpKey,const void *lpValue)
     
     if(m_KeySize<m_RowSize)
     {
-        if(lpValue)
-        {
-            memcpy(m_lpData+m_Size+m_KeySize,lpValue,m_RowSize-m_KeySize);
-        }
-        else
-        {
-            memset(m_lpData+m_Size+m_KeySize,0,m_RowSize-m_KeySize);
-        }
+        memcpy(m_lpData+m_Size+m_KeySize,lpValue,m_RowSize-m_KeySize);
     }
         
     m_Size+=m_RowSize;
@@ -478,21 +457,6 @@ int mc_Buffer::Add(const void *lpKeyValue)
     return Add(lpKeyValue,(unsigned char*)lpKeyValue+m_KeySize);
 }
 
-int mc_Buffer::UpdateRow(int RowID,const void *lpKey,const void *lpValue)
-{
-    if(RowID>=m_Count)
-    {
-        return MC_ERR_INTERNAL_ERROR;
-    }
-    
-    if(m_lpIndex)
-    {
-        m_lpIndex->Remove((char*)GetRow(RowID),m_RowSize-m_KeySize);
-    }
-    
-    return PutRow(RowID,lpKey,lpValue);
-}
-
 int mc_Buffer::PutRow(int RowID,const void *lpKey,const void *lpValue)
 {
     unsigned char *ptr;
@@ -516,14 +480,7 @@ int mc_Buffer::PutRow(int RowID,const void *lpKey,const void *lpValue)
     
     if(m_lpIndex)
     {
-        if(m_lpIndex->Get((unsigned char*)lpKey,m_KeySize) >= 0)
-        {
-            m_lpIndex->Set((unsigned char*)lpKey,m_KeySize,RowID);            
-        }
-        else
-        {
-            m_lpIndex->Add((unsigned char*)lpKey,m_KeySize,RowID);
-        }
+        m_lpIndex->Add((unsigned char*)lpKey,m_KeySize,RowID);
     }
     
     return MC_ERR_NOERROR;
@@ -1912,14 +1869,3 @@ void mc_AdjustStartAndCount(int *count,int *start,int size)
     }    
 }
 
-void sprintf_hex(char *hex,const unsigned char *bin,int size)
-{
-    int i;
-    for(i=0;i<size;i++)
-    {
-        sprintf(hex+(i*2),"%02x",bin[size-1-i]);
-    }
-    
-    hex[size*2]=0;      
-}
-
diff --git a/src/utils/utilparse.cpp b/src/utils/utilparse.cpp
index 38a5384..a19a298 100644
--- a/src/utils/utilparse.cpp
+++ b/src/utils/utilparse.cpp
@@ -27,100 +27,6 @@ const unsigned char* GetAddressIDPtr(const CTxDestination& address)
     return aptr;
 }
 
-bool mc_ExtractOutputAssetQuantities(mc_Buffer *assets,string& reason,bool with_followons)
-{
-    int err;
-    uint32_t script_type=MC_SCR_ASSET_SCRIPT_TYPE_TRANSFER;
-    if(with_followons)
-    {        
-        script_type |= MC_SCR_ASSET_SCRIPT_TYPE_FOLLOWON;
-    }
-    for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
-    {
-        mc_gState->m_TmpScript->SetElement(e);
-        err=mc_gState->m_TmpScript->GetAssetQuantities(assets,script_type);
-        if((err != MC_ERR_NOERROR) && (err != MC_ERR_WRONG_SCRIPT))
-        {
-            reason="Asset transfer script rejected - error in output transfer script";
-            return false;                                
-        }
-    }
-
-    return true;
-}
-
-bool mc_VerifyAssetPermissions(mc_Buffer *assets, vector<CTxDestination> addressRets, int required_permissions, uint32_t permission, string& reason)
-{
-    mc_EntityDetails entity;
-    int asset_count=-1;
-    
-    for(int i=0;i<assets->GetCount();i++)
-    {
-        if(mc_gState->m_Assets->FindEntityByFullRef(&entity,assets->GetRow(i)))
-        {
-            if( entity.Permissions() & (MC_PTP_SEND | MC_PTP_RECEIVE) )
-            {
-                if( (addressRets.size() != 1) || (required_permissions > 1) )
-                {
-                    reason="Sending restricted asset to non-standard and multisig addresses not allowed";
-                    return false;                                                    
-                }
-                if(assets->GetCount() > 1)
-                {
-                    if(asset_count < 0)
-                    {
-                        asset_count=0;
-                        for(int j=0;j<assets->GetCount();j++)
-                        {
-                            if(mc_GetABRefType(assets->GetRow(j)) != MC_AST_ASSET_REF_TYPE_SPECIAL)
-                            {
-                                asset_count++;
-                            }                            
-                        }
-                    }
-                    if(asset_count > 1)
-                    {
-                        if(permission == MC_PTP_SEND)
-                        {
-                            reason="One of multiple assets in input has per-asset permissions";
-                        }
-                        if(permission == MC_PTP_RECEIVE)
-                        {
-                            reason="One of multiple assets in output has per-asset permissions";
-                        }
-                        return false;                                
-                    }
-                }
-                if(entity.Permissions() & permission)
-                {
-                    int found=required_permissions;
-                    for(int j=0;j<(int)addressRets.size();j++)
-                    {
-                        if(mc_gState->m_Permissions->GetPermission(entity.GetTxID(),GetAddressIDPtr(addressRets[j]),permission))
-                        {
-                            found--;
-                        }
-                    }
-                    if(found > 0)
-                    {
-                        if(permission == MC_PTP_SEND)
-                        {
-                            reason="One of the inputs doesn't have per-asset send permission";
-                        }
-                        if(permission == MC_PTP_RECEIVE)
-                        {
-                            reason="One of the outputs doesn't have per-asset receive permission";
-                        }                    
-                        return false;                                
-                    }
-                }
-            }
-        }        
-    }
-    
-    return true;
-}
-
 
 /* 
  * Parses txout script into asset-quantity buffer
@@ -243,27 +149,41 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                         *allowed -= MC_PTP_SEND;                        
                     }
                     
-                    memcpy(buf,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
-                    row=amounts->Seek(buf);
-                    last=0;
-                    if(row >= 0)
+                    if((mc_gState->m_Features->ShortTxIDInTx() == 0) && (entity.IsUnconfirmedGenesis() != 0) )
                     {
-                        last=mc_GetABQuantity(amounts->GetRow(row));
-                        total+=last;
-                        mc_SetABQuantity(amounts->GetRow(row),total);
-                    }
-                    else
-                    {
-                        mc_SetABQuantity(buf,total);
-                        amounts->Add(buf);                        
+                        if(required)                                            // Unconfirmed genesis in protocol < 10007, cannot be spent
+                        {
+                            memset(buf,0,MC_AST_ASSET_FULLREF_SIZE);
+                            mc_SetABRefType(buf,MC_AST_ASSET_REF_TYPE_GENESIS);
+                            mc_SetABQuantity(buf,total);
+                            amounts->Add(buf);        
+                            *required |= MC_PTP_ISSUE;
+                        }
                     }
-
-                    if(required)
+                    else            
                     {
-                        if(expected_required == 0)                          
+                        memcpy(buf,entity.GetFullRef(),MC_AST_ASSET_FULLREF_SIZE);
+                        row=amounts->Seek(buf);
+                        last=0;
+                        if(row >= 0)
                         {
-                            *required |= MC_PTP_ISSUE;
-                        }                            
+                            last=mc_GetABQuantity(amounts->GetRow(row));
+                            total+=last;
+                            mc_SetABQuantity(amounts->GetRow(row),total);
+                        }
+                        else
+                        {
+                            mc_SetABQuantity(buf,total);
+                            amounts->Add(buf);                        
+                        }
+                        
+                        if(required)
+                        {
+                            if(expected_required == 0)                          
+                            {
+                                *required |= MC_PTP_ISSUE;
+                            }                            
+                        }
                     }
                 }                
                 else                                                            // Asset not found, no error but the caller should check required field
@@ -437,6 +357,14 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                                         }                                    
                                     }
                                 }
+                                else
+                                {
+                                    if(mc_gState->m_Features->OpDropDetailsScripts() == 0)// May be Follow-on details from v10007
+                                    {
+                                        strFailReason="Invalid publish script, not stream";
+                                        return false;                                                                    
+                                    }
+                                }                            
                             }                        
                             else
                             {
@@ -490,10 +418,16 @@ bool ParseMultichainTxOutToBuffer(uint256 hash,
                         *required |= admin_type;
                         if( type & (MC_PTP_ADMIN | MC_PTP_MINE) )
                         {
-                            if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+                            if(mc_gState->m_Features->CachedInputScript())
                             {
-                                *required |= MC_PTP_CACHED_SCRIPT_REQUIRED;
-                            }        
+                                if(mc_gState->m_NetworkParams->GetInt64Param("supportminerprecheck"))                                
+                                {
+		                            if(entity.GetEntityType() == MC_ENT_TYPE_NONE)
+                                    {
+                                        *required |= MC_PTP_CACHED_SCRIPT_REQUIRED;
+                                    }        
+                                }        
+                            }
                         }
                         
                         if(hash == 0)
diff --git a/src/utils/utilparse.h b/src/utils/utilparse.h
index 41c76e8..ba7dbd7 100644
--- a/src/utils/utilparse.h
+++ b/src/utils/utilparse.h
@@ -20,8 +20,6 @@ void LogAssetTxOut(std::string message,uint256 hash,int index,unsigned char* ass
 bool AddressCanReceive(CTxDestination address);
 bool FindFollowOnsInScript(const CScript& script1,mc_Buffer *amounts,mc_Script *lpScript);
 int CheckRequiredPermissions(const CTxDestination& addressRet,int expected_allowed,std::map<uint32_t, uint256>* mapSpecialEntity,std::string* strFailReason);
-bool mc_VerifyAssetPermissions(mc_Buffer *assets, std::vector<CTxDestination> addressRets, int required_permissions, uint32_t permission, std::string& reason);
-bool mc_ExtractOutputAssetQuantities(mc_Buffer *assets,std::string& reason,bool with_followons);
 
 
 
diff --git a/src/utils/utilwrapper.cpp b/src/utils/utilwrapper.cpp
index 66ff33b..7910a3d 100644
--- a/src/utils/utilwrapper.cpp
+++ b/src/utils/utilwrapper.cpp
@@ -47,7 +47,6 @@
 #include "structs/hash.h"
 #include "core/main.h"
 #include "net/net.h"
-#include "custom/custom.h"
 
 #define MC_DCT_SEED_NODE_MAX_SIZE 32
 
@@ -78,8 +77,6 @@ void mc_Params::Parse(int argc, const char* const argv[],int exe_type)
     ParseParameters(argc,argv);
     mc_ExpandDataDirParam();
     
-    custom_set_runtime_defaults(exe_type);
-    
     m_NumArguments=0;
     length=MC_DCT_SEED_NODE_MAX_SIZE+1;
     for (i = 1; i < argc; i++)
@@ -144,28 +141,25 @@ void mc_Params::Parse(int argc, const char* const argv[],int exe_type)
                     int err;
                     const char *seed_node;
 
-                    if(!GetBoolArg("-addnodeonly",false))
-                    {
-                        mapConfig=new mc_MapStringString;
+                    mapConfig=new mc_MapStringString;
 
-                        err=mc_ReadGeneralConfigFile(mapConfig,mc_gState->m_Params->NetworkName(),"seed",".dat");
+                    err=mc_ReadGeneralConfigFile(mapConfig,mc_gState->m_Params->NetworkName(),"seed",".dat");
 
-                        if(err == MC_ERR_NOERROR)
-                        {
-                            seed_node=mapConfig->Get("seed");
+                    if(err == MC_ERR_NOERROR)
+                    {
+                        seed_node=mapConfig->Get("seed");
 
-                            if(seed_node)
+                        if(seed_node)
+                        {
+                            if(strlen(seed_node) <= MC_DCT_SEED_NODE_MAX_SIZE)
                             {
-                                if(strlen(seed_node) <= MC_DCT_SEED_NODE_MAX_SIZE)
-                                {
-                                    strcpy(m_Arguments[m_NumArguments],seed_node);
-                                    length+=strlen(seed_node);
-                                }
+                                strcpy(m_Arguments[m_NumArguments],seed_node);
+                                length+=strlen(seed_node);
                             }
                         }
-
-                        delete mapConfig;                            
                     }
+
+                    delete mapConfig;                            
                     m_NumArguments++;                                                                
                 }                
             }            
@@ -390,11 +384,6 @@ const boost::filesystem::path mc_GetDataDir(const char *network_name,int create)
     return path;
 }
 
-void mc_CreateDir(const char *dir_name)
-{
-    boost::filesystem::create_directories(boost::filesystem::path(dir_name));    
-}
-
 void mc_RemoveDataDir(const char *network_name)
 {
     boost::filesystem::path path;
@@ -504,7 +493,7 @@ FILE *mc_OpenFile(const char *network_name,const char *filename, const char *ext
 
 int mc_RemoveFile(const char *network_name,const char *filename, const char *extension,int options)        
 {    
-    return __US_DeleteFile(mc_GetFullFileName(network_name,filename,extension,options).c_str()); 
+    return unlink(mc_GetFullFileName(network_name,filename,extension,options).c_str()); 
 }
 
 
@@ -700,68 +689,6 @@ int mc_ReadGeneralConfigFile(mc_MapStringString *mapConfig,const char *network_n
     return mc_ReadConfigFile(mc_GetConfigFile(network_name,file_name,extension),(std::map<string, string>*)mapConfig->mapObject, NULL,"");
 }
 
-int mc_BuildDescription(int build, char *desc)
-{
-    int v;
-    int c[5];
-    
-    v=build;
-    
-    c[4]=v%100;v/=100;
-    c[3]=v%10 ;v/=10 ;
-    c[2]=v%100;v/=100;
-    c[1]=v%100;v/=100;
-    c[0]=v%100;v/=100;
-    if(c[0] < 1)return MC_ERR_INVALID_PARAMETER_VALUE;
-    sprintf(desc,"%d.%d",c[0],c[1]);
-    if(c[2])
-    {
-        sprintf(desc+strlen(desc),".%d",c[2]);
-    }
-    switch(c[3])
-    {
-        case 1:
-            sprintf(desc+strlen(desc)," alpha ");
-            break;
-        case 2:
-            sprintf(desc+strlen(desc)," beta ");
-            break;
-        case 7:
-            sprintf(desc+strlen(desc)," build ");
-            break;
-        case 9:
-            if(c[4] != 1)return MC_ERR_INVALID_PARAMETER_VALUE;
-            break;
-        default:
-            return MC_ERR_INVALID_PARAMETER_VALUE;
-    }
-    if(c[3] != 9)
-    {
-        sprintf(desc+strlen(desc),"%d",c[4]);        
-    }
-    
-    return MC_ERR_NOERROR;
-}
-
-
-int mc_MultichainParams::SetProtocolGlobals()
-{
-    MCP_ALLOW_ARBITRARY_OUTPUTS=1; 
-    if(mc_gState->m_Features->FixedDestinationExtraction() != 0)
-    {
-        int aao=mc_gState->m_NetworkParams->GetInt64Param("allowarbitraryoutputs");
-        if(aao>=0)
-        {
-            MCP_ALLOW_ARBITRARY_OUTPUTS=aao;
-        }
-    }    
-    if(mc_gState->m_Features->ParameterUpgrades())
-    {
-        MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;
-        MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;
-    }
-    return MC_ERR_NOERROR;
-}
 
 int mc_MultichainParams::SetGlobals()
 {
@@ -777,12 +704,9 @@ int mc_MultichainParams::SetGlobals()
     m_ProtocolVersion=ProtocolVersion();
     
     MIN_RELAY_TX_FEE=(unsigned int)GetInt64Param("minimumrelayfee");    
-    MIN_OFFCHAIN_FEE=(unsigned int)GetInt64Param("minimumoffchainfee");    
     MAX_OP_RETURN_RELAY=(unsigned int)GetInt64Param("maxstdopreturnsize");    
     MAX_OP_RETURN_RELAY=GetArg("-datacarriersize", MAX_OP_RETURN_RELAY);
     MAX_BLOCK_SIZE=(unsigned int)GetInt64Param("maximumblocksize");    
-    MAX_CHUNK_SIZE=(unsigned int)GetInt64Param("maximumchunksize");    
-    MAX_CHUNK_COUNT=(unsigned int)GetInt64Param("maximumchunkcount");    
     DEFAULT_BLOCK_MAX_SIZE=MAX_BLOCK_SIZE;    
     while(MAX_BLOCK_SIZE>MAX_BLOCKFILE_SIZE)
     {
@@ -792,11 +716,14 @@ int mc_MultichainParams::SetGlobals()
     {
         MAX_SIZE *= 2;
     }
-    while(MAX_CHUNK_SIZE+OFFCHAIN_MSG_PADDING>MAX_SIZE)
+
+    if(mc_gState->m_Features->FixedIn1001120003())
     {
-        MAX_SIZE *= 2;
+        MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;
+        MAX_TX_SIGOPS = MAX_BLOCK_SIGOPS/5;
     }
-    MIN_BLOCKS_BETWEEN_UPGRADES=(unsigned int)GetInt64Param("timingupgrademingap"); 
+
+
     MAX_STANDARD_TX_SIZE=(unsigned int)GetInt64Param("maxstdtxsize");    
     MAX_SCRIPT_ELEMENT_SIZE=(unsigned int)GetInt64Param("maxstdelementsize");
     COINBASE_MATURITY=(int)GetInt64Param("rewardspendabledelay");    
@@ -809,6 +736,12 @@ int mc_MultichainParams::SetGlobals()
         CENT=0;
         MAX_MONEY=0;
     }
+    
+    if(mc_gState->m_Features->ShortTxIDInTx() == 0)
+    {
+        m_AssetRefSize=MC_AST_ASSET_REF_SIZE;
+    }
+    
     MCP_MAX_STD_OP_RETURN_COUNT=mc_gState->m_NetworkParams->GetInt64Param("maxstdopreturnscount");
     MCP_INITIAL_BLOCK_REWARD=mc_gState->m_NetworkParams->GetInt64Param("initialblockreward");
     MCP_FIRST_BLOCK_REWARD=mc_gState->m_NetworkParams->GetInt64Param("firstblockreward");
@@ -829,6 +762,15 @@ int mc_MultichainParams::SetGlobals()
         if(MCP_ANYONE_CAN_ISSUE)MCP_ANYONE_CAN_SEND=1;
     }
     MCP_MINIMUM_PER_OUTPUT=mc_gState->m_NetworkParams->GetInt64Param("minimumperoutput");
+    MCP_ALLOW_ARBITRARY_OUTPUTS=1; 
+    if(mc_gState->m_Features->FixedDestinationExtraction() != 0)
+    {
+        int aao=mc_gState->m_NetworkParams->GetInt64Param("allowarbitraryoutputs");
+        if(aao>=0)
+        {
+            MCP_ALLOW_ARBITRARY_OUTPUTS=aao;
+        }
+    }
     MCP_ALLOW_MULTISIG_OUTPUTS=mc_gState->m_NetworkParams->GetInt64Param("allowmultisigoutputs");
     MCP_ALLOW_P2SH_OUTPUTS=mc_gState->m_NetworkParams->GetInt64Param("allowp2shoutputs");
     MCP_WITH_NATIVE_CURRENCY=0;
@@ -839,7 +781,7 @@ int mc_MultichainParams::SetGlobals()
     MCP_STD_OP_DROP_COUNT=mc_gState->m_NetworkParams->GetInt64Param("maxstdopdropscount");
     MCP_STD_OP_DROP_SIZE=mc_gState->m_NetworkParams->GetInt64Param("maxstdopdropsize");
     MCP_ANYONE_CAN_RECEIVE_EMPTY=mc_gState->m_NetworkParams->GetInt64Param("anyonecanreceiveempty");
-    return SetProtocolGlobals();
+    return MC_ERR_NOERROR;
 }
 
 
@@ -881,16 +823,6 @@ void mc_SHA256::GetHash(unsigned char *hash)
     }        
 }
 
-void mc_SHA256::DoubleHash(const void *lpData,int size,void *hash)
-{
-    Reset();
-    Write(lpData,size);
-    GetHash((unsigned char *)hash);
-    Reset();
-    Write((unsigned char *)hash,32);
-    GetHash((unsigned char *)hash);    
-}
-
 int mc_MultichainParams::Import(const char *name,const char *source_address)
 {
     
@@ -1065,4 +997,4 @@ int mc_FindIPv4ServerAddress(uint32_t *all_ips,int max_ips)
      return c;
 }
 
-        
\ No newline at end of file
+        
diff --git a/src/version/version.cpp b/src/version/version.cpp
index d1c8e5d..cedb24a 100644
--- a/src/version/version.cpp
+++ b/src/version/version.cpp
@@ -2,125 +2,23 @@
 // MultiChain code distributed under the GPLv3 license, see COPYING file.
 
 #include "multichain/multichain.h"
-#include "version/version.h"
-#include "custom/custom.h"
-
-int mc_State::VersionInfo(int version)
-{
-    int custom_version=custom_version_info(version);
-    if(custom_version != 0)
-    {
-        return custom_version;
-    }
-    
-    int this_build=20000104;
-    int this_protocol=20003;   
-    
-    if(version < 0)
-    {
-        return 0;
-    }
-    if(version < MULTICHAIN_VERSION_CODE_MIN_VALID)
-    {
-        switch(version)
-        {
-            case MULTICHAIN_VERSION_CODE_BUILD:                                 // last version
-                return -this_build;                                               
-            case MULTICHAIN_VERSION_CODE_PROTOCOL_THIS:                         // last protocol version
-                return this_protocol;
-            case MULTICHAIN_VERSION_CODE_PROTOCOL_MIN:
-                return 10004;                                                   // first supported version
-            case MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_DOWNGRADE:
-                return 10008;                                                   // cannot downgrade below this version
-            case MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_NO_DOWNGRADE:
-                return 20002;                                                   // if we are on this version or above, downgrades are forbidden
-            case MULTICHAIN_VERSION_CODE_PROTOCOL_FOR_RELEVANCE:                
-                return 0;                                                       // If not 0, defines relevant parameter set
-        }
-        return 0;        
-    }
-    if(version < 10002)return 10002;                                            // first version
-    if(version < 10004)return -10000201;                                        // last build supporting this version (negative)
-    if(version < 10012)return -this_build;                                      // supported by this version    
-    if(version < 20001)return 20001;                                            // next version
-    if(version < this_protocol+1)return -this_build;                            // supported by this version    
-        
-    return VersionInfo(MULTICHAIN_VERSION_CODE_BUILD)-1;                        // Created by the following builds
-}
 
-int mc_State::IsSupported(int version)
-{
-    void *ptr=mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL);
-    if(ptr)
-    {
-        if(strcmp((char*)ptr,"multichain"))
-        {
-            return 1;
-        }
-    }
-    
-    if(-VersionInfo(version) == GetNumericVersion())
-    {
-        return 1;
-    }
-    return 0;
-}
 
-int mc_State::IsDeprecated(int version)
-{
-    int build=-VersionInfo(version);
-    int is_protocol_multichain=1;
-    
-    void *ptr=mc_gState->m_NetworkParams->GetParam("chainprotocol",NULL);
-    if(ptr)
-    {
-        if(strcmp((char*)ptr,"multichain"))
-        {
-            is_protocol_multichain=0;
-        }
-    }
-    
-    if(is_protocol_multichain)
-    {
-        if(build > 0)
-        {
-            if(build < GetNumericVersion())
-            {
-                return 1;
-            }
-        }
-    }
-    return 0;
-}
-
-int mc_State::GetNumericVersion()
-{
-    return -VersionInfo(MULTICHAIN_VERSION_CODE_BUILD);
-}
-
-int mc_State::GetProtocolVersion()
-{
-    return VersionInfo(MULTICHAIN_VERSION_CODE_PROTOCOL_THIS);
-}
-
-int mc_State::MinProtocolVersion()
-{
-    return VersionInfo(MULTICHAIN_VERSION_CODE_PROTOCOL_MIN);
-}
+#include "version/version.h"
 
-int mc_State::MinProtocolDowngradeVersion()
+const char* mc_State::GetVersion()
 {
-    return VersionInfo(MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_DOWNGRADE);
+    return MULTICHAIN_BUILD_DESC;
 }
 
-int mc_State::MinProtocolForbiddenDowngradeVersion()
+const char* mc_State::GetFullVersion()
 {
-    return VersionInfo(MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_NO_DOWNGRADE);    
+    return MULTICHAIN_FULL_VERSION;
 }
 
-int mc_State::RelevantParamProtocolVersion()
+int mc_State::GetNumericVersion()
 {
-    return VersionInfo(MULTICHAIN_VERSION_CODE_PROTOCOL_FOR_RELEVANCE);        
+    return MULTICHAIN_BUILD_DESC_NUMERIC;
 }
 
 int mc_State::GetWalletDBVersion()
@@ -140,3 +38,7 @@ int mc_State::GetWalletDBVersion()
     return 1;
 }
 
+int mc_State::GetProtocolVersion()
+{
+    return MULTICHAIN_PROTOCOL_VERSION;
+}
diff --git a/src/version/version.h b/src/version/version.h
index 0688612..7fb48f3 100644
--- a/src/version/version.h
+++ b/src/version/version.h
@@ -6,12 +6,12 @@
 
 #define MULTICHAIN_VERSION_MAJOR     1
 #define MULTICHAIN_VERSION_MINOR     0
-#define MULTICHAIN_VERSION_REVISION  0
-#define MULTICHAIN_VERSION_STAGE     2
-#define MULTICHAIN_VERSION_BUILD     2
+#define MULTICHAIN_VERSION_REVISION  7
+#define MULTICHAIN_VERSION_STAGE     9
+#define MULTICHAIN_VERSION_BUILD     1
 
-#define MULTICHAIN_PROTOCOL_VERSION 10008
-#define MULTICHAIN_PROTOCOL_SUPPORTED "10004 - 10008, 20001"
+#define MULTICHAIN_PROTOCOL_VERSION 10011
+#define MULTICHAIN_MIN_DOWNGRADE_PROTOCOL_VERSION 10008
 
 
 #ifndef STRINGIZE
@@ -29,9 +29,8 @@
     DO_STRINGIZE(maj) "." DO_STRINGIZE(min) "." DO_STRINGIZE(rev) "." DO_STRINGIZE(build)
 
 
-#define MULTICHAIN_BUILD_DESC "1.0 beta 2"
-#define MULTICHAIN_BUILD_DESC_NUMERIC 10000202
-
+#define MULTICHAIN_BUILD_DESC "1.0.7"
+#define MULTICHAIN_BUILD_DESC_NUMERIC 10006901
 
 #ifndef MULTICHAIN_BUILD_DESC
 #ifdef BUILD_SUFFIX
@@ -50,13 +49,5 @@
 #endif
 
 
-#define MULTICHAIN_VERSION_CODE_PROTOCOL_THIS              0
-#define MULTICHAIN_VERSION_CODE_PROTOCOL_MIN               1
-#define MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_DOWNGRADE     2
-#define MULTICHAIN_VERSION_CODE_PROTOCOL_MIN_NO_DOWNGRADE  3
-#define MULTICHAIN_VERSION_CODE_PROTOCOL_FOR_RELEVANCE     4
-#define MULTICHAIN_VERSION_CODE_BUILD                     16
-#define MULTICHAIN_VERSION_CODE_MIN_VALID               1000
-
 #endif	/* MULTICHAINVERSION_H */
 
diff --git a/src/wallet/chunkcollector.cpp b/src/wallet/chunkcollector.cpp
deleted file mode 100644
index f1b72ed..0000000
--- a/src/wallet/chunkcollector.cpp
+++ /dev/null
@@ -1,817 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "multichain/multichain.h"
-#include "wallet/chunkcollector.h"
-
-void mc_ChunkEntityKey::Zero()
-{
-    memset(this,0, sizeof(mc_ChunkEntityKey));    
-}
-
-void mc_ChunkEntityValue::Zero()
-{
-    memset(this,0, sizeof(mc_ChunkEntityValue));    
-}
-
-
-void mc_ChunkCollectorRow::Zero()
-{
-    memset(this,0, sizeof(mc_ChunkCollectorRow));
-}
-
-void mc_ChunkCollectorDBRow::Zero()
-{
-    memset(this,0, sizeof(mc_ChunkCollectorDBRow));    
-}
-
-void mc_ChunkCollectorStat::Zero()
-{
-    memset(this,0, sizeof(mc_ChunkCollectorStat));    
-}    
-    
-void mc_ChunkCollector::Zero()
-{
-    m_DB=NULL;
-    m_ChunkDB=NULL;
-    m_KeyOffset=0;
-    m_KeyDBOffset=0;
-    m_KeySize=MC_TDB_TXID_SIZE+sizeof(int)+sizeof(mc_ChunkEntityKey)+3*sizeof(uint32_t);
-    m_KeyDBSize=MC_TDB_TXID_SIZE+sizeof(int)+sizeof(uint32_t)+MC_CDB_CHUNK_HASH_SIZE+sizeof(mc_TxEntity);   // 96
-    m_ValueOffset=m_KeySize;
-    m_ValueDBOffset=m_KeyDBSize;
-    m_ValueSize=sizeof(mc_ChunkEntityValue);
-    m_ValueDBSize=4*sizeof(uint32_t)+2*sizeof(int64_t);
-    m_TotalSize=m_KeySize+m_ValueSize;
-    m_TotalDBSize=m_KeyDBSize+m_ValueDBSize;
-    m_Name[0]=0;
-    m_DBName[0]=0;
-    m_NextAutoCommitTimestamp=0;
-    m_NextTryTimestamp=0;
-    m_MarkPool=NULL;
-    m_MemPool=NULL;
-    m_MemPoolNext=NULL;
-    m_MemPool1=NULL;
-    m_MemPool2=NULL;
-    
-    m_MaxMemPoolSize=MC_CCW_DEFAULT_MEMPOOL_SIZE;
-    m_AutoCommitDelay=MC_CCW_DEFAULT_AUTOCOMMIT_DELAY;
-    m_TimeoutRequest=(int)GetArg("-chunkrequesttimeout",MC_CCW_TIMEOUT_REQUEST);
-    if(m_TimeoutRequest <= MC_CCW_TIMEOUT_REQUEST_SHIFT)
-    {
-        m_TimeoutRequest=MC_CCW_TIMEOUT_REQUEST_SHIFT+1;
-    }
-    m_TimeoutQuery=(int)GetArg("-chunkquerytimeout",MC_CCW_TIMEOUT_QUERY);
-    m_TotalChunkCount=0;
-    m_TotalChunkSize=0;
-    
-    m_StatLast[0].Zero();
-    m_StatLast[1].Zero();
-    m_StatTotal[0].Zero();
-    m_StatTotal[1].Zero();
-    
-    m_Semaphore=NULL;
-    m_LockedBy=0;     
-    
-    m_InitMode=0;    
-}
-
-int mc_ChunkCollector::Destroy()
-{
-    if(m_DB)
-    {
-        m_DB->Close();
-        delete m_DB;    
-        m_DB=NULL;
-    }
-
-    if(m_MarkPool)
-    {
-        delete m_MarkPool;
-    }
-    
-    if(m_MemPool1)
-    {
-        delete m_MemPool1;
-    }
-    
-    if(m_MemPool2)
-    {
-        delete m_MemPool2;
-    }
-
-    if(m_Semaphore)
-    {
-        __US_SemDestroy(m_Semaphore);
-    }
-     
-    
-    Zero();
-    return MC_ERR_NOERROR;       
-}
-
-int mc_ChunkCollector::Lock(int write_mode,int allow_secondary)
-{        
-    uint64_t this_thread;
-    this_thread=__US_ThreadID();
-    
-    if(this_thread == m_LockedBy)
-    {
-        return allow_secondary;
-    }
-    
-    __US_SemWait(m_Semaphore); 
-    m_LockedBy=this_thread;
-    
-    return 0;
-}
-
-void mc_ChunkCollector::UnLock()
-{    
-    m_LockedBy=0;
-    __US_SemPost(m_Semaphore);
-}
-
-int mc_ChunkCollector::Lock()
-{        
-    return Lock(1,0);
-}
-
-void mc_ChunkCollector::SetDBRow(mc_ChunkCollectorRow* collect_row)
-{
-    m_DBRow.Zero();
-    m_DBRow.m_QueryNextAttempt=mc_SwapBytes32(collect_row->m_DBNextAttempt);
-    m_DBRow.m_Vout=collect_row->m_Vout;
-    memcpy(m_DBRow.m_TxID,collect_row->m_TxID,MC_TDB_TXID_SIZE);
-    memcpy(&(m_DBRow.m_Entity),&(collect_row->m_ChunkDef.m_Entity),sizeof(mc_TxEntity));
-    memcpy(m_DBRow.m_Hash,collect_row->m_ChunkDef.m_Hash,MC_CDB_CHUNK_HASH_SIZE);
-    m_DBRow.m_Size=collect_row->m_ChunkDef.m_Size;
-    m_DBRow.m_Flags=collect_row->m_ChunkDef.m_Flags;
-    m_DBRow.m_QueryAttempts=collect_row->m_State.m_QueryAttempts;
-    m_DBRow.m_Status=collect_row->m_State.m_Status;
-}
-
-void mc_ChunkCollector::GetDBRow(mc_ChunkCollectorRow* collect_row)
-{
-    collect_row->Zero();
-    collect_row->m_DBNextAttempt=mc_SwapBytes32(m_DBRow.m_QueryNextAttempt);
-    collect_row->m_State.m_QueryNextAttempt=collect_row->m_DBNextAttempt;    
-    collect_row->m_Vout=m_DBRow.m_Vout;
-    memcpy(collect_row->m_TxID,m_DBRow.m_TxID,MC_TDB_TXID_SIZE);
-    memcpy(&(collect_row->m_ChunkDef.m_Entity),&(m_DBRow.m_Entity),sizeof(mc_TxEntity));
-    memcpy(collect_row->m_ChunkDef.m_Hash,m_DBRow.m_Hash,MC_CDB_CHUNK_HASH_SIZE);
-    collect_row->m_ChunkDef.m_Size=m_DBRow.m_Size;
-    collect_row->m_ChunkDef.m_Flags=m_DBRow.m_Flags;
-    collect_row->m_State.m_QueryAttempts=m_DBRow.m_QueryAttempts;
-    collect_row->m_State.m_Status=m_DBRow.m_Status;
-    collect_row->m_State.m_Status |= MC_CCF_INSERTED;                
-}
-
-int mc_ChunkCollector::DeleteDBRow(mc_ChunkCollectorRow *collect_row)
-{       
-    SetDBRow(collect_row);
-    return m_DB->Delete((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);    
-}
-
-int mc_ChunkCollector::InsertDBRow(mc_ChunkCollectorRow *collect_row)
-{
-    collect_row->m_State.m_Status &= MC_CCF_ERROR_MASK;
-    SetDBRow(collect_row);
-    collect_row->m_State.m_Status |= MC_CCF_INSERTED;    
-    return m_DB->Write((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,(char*)&m_DBRow+m_ValueDBOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-}
-
-int mc_ChunkCollector::UpdateDBRow(mc_ChunkCollectorRow *collect_row)
-{
-    int err;    
-    collect_row->m_State.m_Status &= MC_CCF_ERROR_MASK;
-    SetDBRow(collect_row);
-    err=m_DB->Delete((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);    
-    if(err)
-    {
-        return err;
-    }
-    collect_row->m_DBNextAttempt=collect_row->m_State.m_QueryNextAttempt;
-    m_DBRow.m_QueryNextAttempt=mc_SwapBytes32(collect_row->m_DBNextAttempt);
-    collect_row->m_State.m_Status |= MC_CCF_INSERTED;    
-    return m_DB->Write((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,(char*)&m_DBRow+m_ValueDBOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-}
-
-int mc_ChunkCollector::SeekDB(void *dbrow)
-{
-    int err,value_len;   
-    unsigned char *ptr;
-    
-    err=MC_ERR_NOERROR;
-    ptr=(unsigned char*)m_DB->Read((char*)dbrow+m_KeyDBOffset,m_KeyDBSize,&value_len,MC_OPT_DB_DATABASE_SEEK_ON_READ,&err);
-    if(ptr==NULL)
-    {
-        return MC_ERR_NOT_FOUND;
-    }
-    
-    memcpy((unsigned char*)&m_DBRow+m_KeyDBOffset,(unsigned char*)dbrow,m_KeyDBSize);
-    memcpy((unsigned char*)&m_DBRow+m_ValueDBOffset,ptr,m_ValueDBSize);
-    memcpy(&m_LastDBRow,&m_DBRow,m_TotalDBSize);
-    
-    return err;
-}
-
-int mc_ChunkCollector::ReadFromDB(mc_Buffer *mempool,int rows)
-{
-    int err,mprow;   
-    mc_ChunkCollectorRow collect_row;
-    mc_ChunkDBRow chunk_def;
-    unsigned char *ptr;
-    int row;
-    
-    if(rows <= 0)    
-    {
-        return MC_ERR_NOERROR;
-    }
-    
-    err=MC_ERR_NOERROR;
-    
-    ptr=NULL;
-    row=mempool->GetCount();
-    while(row<rows)
-    {
-        ptr=(unsigned char*)m_DB->MoveNext(&err);
-        if(err)
-        {
-            return MC_ERR_CORRUPTED;            
-        }
-        if(ptr)
-        {
-            memcpy((char*)&m_DBRow,ptr,m_TotalDBSize);   
-            GetDBRow(&collect_row);
-            collect_row.m_State.m_Status |= MC_CCF_INSERTED;                
-            if(m_ChunkDB->GetChunkDef(&chunk_def,collect_row.m_ChunkDef.m_Hash,&(collect_row.m_ChunkDef.m_Entity),collect_row.m_TxID,collect_row.m_Vout) == MC_ERR_NOERROR)
-            {
-                collect_row.m_State.m_Status |= MC_CCF_DELETED;
-            }
-            mprow=mempool->Seek(&collect_row);
-            if(mprow < 0)
-            {
-                mempool->Add(&collect_row);
-                row++;
-            }
-        }
-        else
-        {
-            row=rows;
-        }
-    }
-    
-    if(mempool->GetCount() < rows)
-    {
-        if(mempool->GetCount() <= m_TotalChunkCount)
-        {
-            m_TotalChunkCount=mempool->GetCount();
-            m_TotalChunkSize=0;
-            for(row=0;row<m_MemPool->GetCount();row++)
-            {
-                m_TotalChunkSize+=((mc_ChunkCollectorRow *)m_MemPool->GetRow(row))->m_ChunkDef.m_Size;
-            }
-        }
-    }
-    
-    memcpy(&m_LastDBRow,&m_DBRow,m_TotalDBSize);
-    
-    return MC_ERR_NOERROR;
-}
-
-
-void mc_ChunkCollector::Dump(const char *message)
-{   
-    int i;
-    
-    if((m_InitMode & MC_WMD_DEBUG) == 0)
-    {
-        return;
-    }
-    unsigned char *ptr;
-    int dbvalue_len,err;
-    char ShortName[65];                                     
-    char FileName[MC_DCT_DB_MAX_PATH];                      
-    FILE *fHan;
-    
-    sprintf(ShortName,"chunks/collect");
-    mc_GetFullFileName(m_Name,ShortName,".dmp",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,FileName);
-    
-    fHan=fopen(FileName,"a");
-    if(fHan == NULL)
-    {
-        return;
-    }
-
-    mc_LogString(fHan,message);     
-    
-    if(m_DB)
-    {
-        fprintf(fHan,"\nDB\n");
-        m_DBRow.Zero();    
-        ptr=(unsigned char*)m_DB->Read((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,&dbvalue_len,MC_OPT_DB_DATABASE_SEEK_ON_READ,&err);
-        if(err)
-        {
-            return;
-        }
-
-        if(ptr)
-        {
-            memcpy((char*)&m_DBRow+m_ValueDBOffset,ptr,m_ValueDBSize);
-            while(ptr)
-            {
-                mc_MemoryDumpCharSizeToFile(fHan,(char*)&m_DBRow+m_KeyDBOffset,0,m_TotalDBSize,64);        
-                ptr=(unsigned char*)m_DB->MoveNext(&err);
-                if(ptr)
-                {
-                    memcpy((char*)&m_DBRow+m_KeyDBOffset,ptr,m_TotalDBSize);            
-                }
-            }
-        }
-    }
-
-    fprintf(fHan,"\nMempool\n");
-    for(i=0;i<m_MemPool->GetCount();i++)
-    {
-        mc_MemoryDumpCharSizeToFile(fHan,m_MemPool->GetRow(i),0,m_TotalSize,64);    
-    }
-    
-    fprintf(fHan,"\n<<<<<< \tChain height: %6d\t%s\n\n",mc_gState->m_Permissions->m_Block,message);
-    fclose(fHan);
-}
-
-int mc_ChunkCollector::Initialize(mc_ChunkDB *chunk_db,const char *name,uint32_t mode)
-{
-    int err=MC_ERR_NOERROR;    
-    if(name)
-    {
-        strcpy(m_Name,name);
-
-        m_DB=new mc_Database;
-
-        mc_GetFullFileName(name,"chunks/collect",".db",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,m_DBName);
-
-        m_DB->SetOption("KeySize",0,m_KeyDBSize);
-        m_DB->SetOption("ValueSize",0,m_ValueDBSize);
-
-
-        err=m_DB->Open(m_DBName,MC_OPT_DB_DATABASE_CREATE_IF_MISSING | MC_OPT_DB_DATABASE_TRANSACTIONAL | MC_OPT_DB_DATABASE_LEVELDB);
-
-        if(err)
-        {
-            return err;
-        }
-    }
-
-    m_InitMode=mode;
-    m_ChunkDB=chunk_db;
-    
-    
-    m_MarkPool=new mc_Buffer;                                                
-    err=m_MarkPool->Initialize(m_KeySize,m_TotalSize,MC_BUF_MODE_DEFAULT);
-    m_MemPool1=new mc_Buffer;                                                
-    err=m_MemPool1->Initialize(m_KeySize,m_TotalSize,MC_BUF_MODE_MAP);
-    m_MemPool2=new mc_Buffer;                                                
-    err=m_MemPool2->Initialize(m_KeySize,m_TotalSize,MC_BUF_MODE_MAP);
-    
-    m_MemPool=m_MemPool1;
-
-    m_DBRow.Zero();
-    
-    if(m_DB)
-    {
-        err=SeekDB(&m_DBRow);
-        if(err)
-        {
-            if(err != MC_ERR_NOT_FOUND)
-            {
-                return err;
-            }
-        }
-        if(err != MC_ERR_NOT_FOUND)
-        {
-            m_TotalChunkCount=m_DBRow.m_TotalChunkCount;
-            m_TotalChunkSize=m_DBRow.m_TotalChunkSize;
-            err=ReadFromDB(m_MemPool,m_MaxMemPoolSize);
-            if(err)
-            {
-                return err;
-            }
-        }
-        else
-        {
-            err=m_DB->Write((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,(char*)&m_DBRow+m_ValueDBOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            if(err)
-            {
-                return err;     
-            }              
-            err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            if(err)
-            {
-                return err;
-            }                            
-        }
-    }
-    
-    Dump("Initialize");
-    
-    return err;   
-}
-
-int mc_ChunkCollector::InsertChunk(                                                            // Adds chunk to mempool
-                 const unsigned char *hash,                                     // Chunk hash (before chopping)    
-                 const mc_TxEntity *entity,                                     // Parent entity
-                 const unsigned char *txid,
-                 const int vout,
-                 const uint32_t chunk_size)
-{
-    int err;
-    
-    Lock();
-    err=InsertChunkInternal(hash,entity,txid,vout,chunk_size);
-    UnLock();
-    
-    return err;    
-}
-
-int mc_ChunkCollector::Unsubscribe(mc_Buffer* lpEntities)
-{
-    Lock();
-    
-    int i,err;    
-    unsigned char *ptr;
-    mc_ChunkCollectorRow *row;
-    mc_ChunkCollectorRow collect_row;
-    int try_again,commit_required;
-    mc_TxEntity entity;
-    
-    commit_required=0;
-    for(i=0;i<m_MemPool->GetCount();i++)
-    {
-        row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(i);        
-        memcpy(&entity,&row->m_ChunkDef.m_Entity,sizeof(mc_TxEntity));
-        entity.m_EntityType |= MC_TET_CHAINPOS;
-        if(lpEntities->Seek(&entity) >= 0)    
-        {
-            row->m_State.m_Status |= MC_CCF_DELETED;
-            commit_required=1;
-        }        
-    }
-    
-    if(commit_required)
-    {
-        CommitInternal(0);            
-    }
-    
-    if(m_MemPool == m_MemPool1)
-    {
-        m_MemPoolNext=m_MemPool2;
-    }
-    else
-    {
-        m_MemPoolNext=m_MemPool1;        
-    }
-    
-    
-    try_again=1;
-    m_DBRow.Zero();    
-    if(m_DB)
-    {        
-        while(try_again)
-        {
-            m_MemPoolNext->Clear();
-            try_again=0;
-            err=SeekDB(&m_DBRow);
-
-            ptr=(unsigned char*)m_DB->MoveNext(&err);
-            while(ptr)
-            {
-                if(err)
-                {
-                    return MC_ERR_CORRUPTED;            
-                }
-                memcpy((char*)&m_DBRow,ptr,m_TotalDBSize);   
-                ptr=(unsigned char*)m_DB->MoveNext(&err);
-                GetDBRow(&collect_row);
-                memcpy(&entity,&collect_row.m_ChunkDef.m_Entity,sizeof(mc_TxEntity));
-                entity.m_EntityType |= MC_TET_CHAINPOS;
-                if(lpEntities->Seek(&entity) >= 0)    
-                {
-                    m_MemPoolNext->Add(&collect_row);
-                }
-                else
-                {
-                    memcpy(&m_LastDBRow,&m_DBRow,m_TotalDBSize);                       
-                }
-                if( (m_MemPoolNext->GetCount() >= 2*m_MaxMemPoolSize) || (ptr == NULL) )
-                {
-                    if(ptr)
-                    {
-                        try_again=1;
-                        ptr=NULL;
-                        memcpy(&m_DBRow,&m_LastDBRow,m_TotalDBSize);                        
-                    }
-                    if(m_MemPoolNext->GetCount())
-                    {
-                        commit_required=1;
-                        for(i=0;i<m_MemPoolNext->GetCount();i++)
-                        {
-                            row=(mc_ChunkCollectorRow *)m_MemPoolNext->GetRow(i);        
-                            m_TotalChunkCount--;
-                            m_TotalChunkSize-=row->m_ChunkDef.m_Size;
-                            if(row->m_State.m_Status & MC_CCF_INSERTED)
-                            {
-                                DeleteDBRow(row);                
-                            }            
-                        }
-                        m_DBRow.Zero();
-                        m_DBRow.m_TotalChunkSize=m_TotalChunkSize;
-                        m_DBRow.m_TotalChunkCount=m_TotalChunkCount;
-                        m_DB->Write((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,(char*)&m_DBRow+m_ValueDBOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-
-                        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-                        if(err)
-                        {
-                            return err;
-                        }                                        
-                    }
-                }                
-            }
-        }        
-    }
-    
-    m_MemPoolNext->Clear();    
-    
-    if(commit_required)
-    {
-        CommitInternal(1);    
-    }
-    
-    UnLock();    
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkCollector::InsertChunkInternal(                  
-                 const unsigned char *hash,   
-                 const mc_TxEntity *entity,   
-                 const unsigned char *txid,
-                 const int vout,
-                 const uint32_t chunk_size)
-{
-    mc_ChunkCollectorRow collect_row;
-    int mprow;
-    
-    collect_row.Zero();
-    memcpy(collect_row.m_ChunkDef.m_Hash,hash,MC_CDB_CHUNK_HASH_SIZE);
-    memcpy(&collect_row.m_ChunkDef.m_Entity,entity,sizeof(mc_TxEntity));
-    memcpy(collect_row.m_TxID,txid,MC_TDB_TXID_SIZE);
-    collect_row.m_Vout=vout;
-    collect_row.m_ChunkDef.m_Size=chunk_size;
-    collect_row.m_State.m_Status=MC_CCF_NEW;
-    
-    mprow=m_MemPool->Seek(&collect_row);
-    if(mprow<0)
-    {
-        m_MemPool->Add(&collect_row);
-        m_TotalChunkCount++;
-        m_TotalChunkSize+=chunk_size;
-        
-        if(m_MemPool->GetCount() >= 2*m_MaxMemPoolSize)
-        {
-            CommitInternal(0);
-        }
-    }
-    
-    return MC_ERR_NOERROR;
-}
-    
-int mc_ChunkCollector::MarkAndClear(uint32_t flag, int unmark)
-{
-    int i,mprow;
-    
-    mc_ChunkCollectorRow *row;
-    Lock();    
-    
-    for(i=0;i<m_MarkPool->GetCount();i++)
-    {
-        mprow=m_MemPool->Seek(m_MarkPool->GetRow(i));
-        if(mprow >= 0)
-        {
-            row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(mprow);
-            if(unmark)
-            {
-                row->m_State.m_Status &= ~flag;
-            }
-            else
-            {
-                row->m_State.m_Status |= flag;
-            }
-        }
-    }
-    
-    m_MarkPool->Clear();
-    UnLock();    
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkCollector::CopyFlags()
-{
-    int i,mprow;
-    
-    mc_ChunkCollectorRow *row;
-    mc_ChunkCollectorRow *mark_row;
-    Lock();    
-    
-    for(i=0;i<m_MarkPool->GetCount();i++)
-    {
-        mark_row=(mc_ChunkCollectorRow *)m_MarkPool->GetRow(i);
-        mprow=m_MemPool->Seek(mark_row);
-        if(mprow >= 0)
-        {
-            row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(mprow);
-            row->m_State.m_Status=mark_row->m_State.m_Status;
-        }
-    }
-    
-    m_MarkPool->Clear();
-    UnLock();    
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkCollector::FillMarkPoolByHash(const unsigned char *hash)
-{
-    int i;    
-    mc_ChunkCollectorRow *row;
-    
-    Lock();
-    
-    m_MarkPool->Clear();
-    
-    for(i=0;i<m_MemPool->GetCount();i++)
-    {
-        row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(i);        
-        if(memcmp(row->m_ChunkDef.m_Hash,hash,MC_CDB_CHUNK_HASH_SIZE) == 0)
-        {
-            m_MarkPool->Add(row);
-        }
-    }
-    
-    UnLock();        
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkCollector::FillMarkPoolByFlag(uint32_t flag, uint32_t not_flag)
-{
-    int i;    
-    mc_ChunkCollectorRow *row;
-    
-    Lock();
-    
-    m_MarkPool->Clear();
-    
-    for(i=0;i<m_MemPool->GetCount();i++)
-    {
-        row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(i);        
-        if(row->m_State.m_Status & flag)
-        {
-            if( (row->m_State.m_Status & not_flag) == 0)
-            {
-                m_MarkPool->Add(row);
-            }
-        }
-    }
-    
-    UnLock();        
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkCollector::Commit()
-{
-    int err;
-    
-    Lock();
-    err=CommitInternal(1);
-    UnLock();
-    
-    return err;        
-}
-
-int mc_ChunkCollector::CommitInternal(int fill_mempool)
-{
-    int i;    
-    mc_ChunkCollectorRow *row;
-    int err,commit_required;
-    uint32_t time_now;
-
-    err=MC_ERR_NOERROR;
-    
-    if(m_DB == NULL)
-    {
-        return MC_ERR_NOT_ALLOWED;
-    }
-    
-    Dump("Before Commit");
-    
-    time_now=mc_TimeNowAsUInt();
-    
-    if(m_MemPool == m_MemPool1)
-    {
-        m_MemPoolNext=m_MemPool2;
-    }
-    else
-    {
-        m_MemPoolNext=m_MemPool1;        
-    }
-    
-    m_MemPoolNext->Clear();
-    
-    commit_required=0;
-    
-    for(i=0;i<m_MemPool->GetCount();i++)
-    {
-        row=(mc_ChunkCollectorRow *)m_MemPool->GetRow(i);        
-        
-        if(row->m_State.m_Status & MC_CCF_DELETED)
-        {
-            m_TotalChunkCount--;
-            m_TotalChunkSize-=row->m_ChunkDef.m_Size;
-            if(row->m_State.m_Status & MC_CCF_INSERTED)
-            {
-                commit_required=1;
-                DeleteDBRow(row);                
-//                m_DB->Delete((char*)row+m_KeyOffset,m_KeySize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            }            
-        }
-        else
-        {
-            if( (row->m_State.m_Status & MC_CCF_INSERTED) == 0 )
-            {
-                commit_required=1;
-                InsertDBRow(row);
-            }
-            else
-            {
-                if(row->m_State.m_Status & MC_CCF_UPDATED)
-                {
-                    commit_required=1;
-                    UpdateDBRow(row);                
-                }
-            }
-/*            
-            if( ((row->m_State.m_Status & MC_CCF_INSERTED) == 0 ) || (row->m_State.m_Status & MC_CCF_UPDATED) )
-            {
-                
-                row->m_State.m_Status &= MC_CCF_ERROR_MASK;
-                m_DB->Write((char*)row+m_KeyOffset,m_KeySize,(char*)row+m_ValueOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-                row->m_State.m_Status |= MC_CCF_INSERTED;
-            }            
- */ 
-            if(!row->m_State.m_Query.IsZero() || 
-               ((fill_mempool != 0) && (row->m_State.m_QueryNextAttempt <= time_now) && (m_MemPoolNext->GetCount() < m_MaxMemPoolSize)) )
-            {
-                    m_MemPoolNext->Add(row);                                    
-            }
-        }
-    }    
-
-    if(commit_required)
-    {
-        m_DBRow.Zero();
-        m_DBRow.m_TotalChunkSize=m_TotalChunkSize;
-        m_DBRow.m_TotalChunkCount=m_TotalChunkCount;
-        m_DB->Write((char*)&m_DBRow+m_KeyDBOffset,m_KeyDBSize,(char*)&m_DBRow+m_ValueDBOffset,m_ValueDBSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        
-        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return err;
-        }                
-    }
-   
-    if(fill_mempool)
-    {
-        if(m_MemPoolNext->GetCount() < m_MaxMemPoolSize)
-        {
-            m_LastDBRow.Zero();
-            err=SeekDB(&m_LastDBRow);
-            if(err == MC_ERR_NOERROR)
-            {
-                ReadFromDB(m_MemPoolNext,m_MaxMemPoolSize);
-            }
-        }
-    }
-
-    m_MemPool->Clear();
-    m_MemPool=m_MemPoolNext;
-    
-    Dump("Commit");
-    
-    return err;
-}
-
diff --git a/src/wallet/chunkcollector.h b/src/wallet/chunkcollector.h
deleted file mode 100644
index ee2c3e2..0000000
--- a/src/wallet/chunkcollector.h
+++ /dev/null
@@ -1,208 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#ifndef MULTICHAIN_CHUNKCOLLECTOR_H
-#define MULTICHAIN_CHUNKCOLLECTOR_H
-
-#include "utils/declare.h"
-#include "protocol/relay.h"
-#include "wallet/chunkdb.h"
-#include "wallet/wallettxdb.h"
-
-#define MC_CCF_NONE                       0x00000000 
-#define MC_CCF_NEW                        0x00000000 
-#define MC_CCF_INSERTED                   0x00000001 
-#define MC_CCF_DELETED                    0x00000002 
-#define MC_CCF_SELECTED                   0x00000004 
-#define MC_CCF_UPDATED                    0x00000008 
-#define MC_CCF_WRONG_SIZE                 0x00010000 
-#define MC_CCF_ERROR_MASK                 0x00FF0000 
-#define MC_CCF_ALL                        0xFFFFFFFF
-
-#define MC_CCW_TIMEOUT_QUERY                      25
-#define MC_CCW_TIMEOUT_REQUEST                    10
-#define MC_CCW_TIMEOUT_REQUEST_SHIFT               2
-#define MC_CCW_MAX_CHUNKS_PER_QUERY             1000
-#define MC_CCW_DEFAULT_AUTOCOMMIT_DELAY          200
-#define MC_CCW_WORST_RESPONSE_SCORE       1048576000
-#define MC_CCW_DEFAULT_MEMPOOL_SIZE            60000
-#define MC_CCW_MAX_MBS_PER_SECOND                  8
-#define MC_CCW_MAX_DELAY_BETWEEN_COLLECTS       1000
-#define MC_CCW_QUERY_SPLIT                         4
-
-
-typedef struct mc_ChunkEntityKey
-{
-    unsigned char m_Hash[MC_CDB_CHUNK_HASH_SIZE];                               // Chunk hash
-    mc_TxEntity m_Entity;
-    uint32_t m_Size;
-    uint32_t m_Flags;
-    
-    void Zero();
-} mc_ChunkEntityKey;
-
-typedef struct mc_ChunkEntityValue
-{
-    uint32_t m_QueryAttempts;
-    uint32_t m_QueryNextAttempt;
-    uint32_t m_Status;
-    uint32_t m_Reserved1;
-    mc_OffchainMessageID m_Query;
-    mc_OffchainMessageID m_Request;
-    uint32_t m_QueryTimeStamp;
-    uint32_t m_QuerySilenceTimestamp;
-    uint32_t m_RequestTimeStamp;
-    uint32_t m_RequestPos;
-    
-    void Zero();
-} mc_ChunkEntityValue;
-
-typedef struct mc_ChunkCollectorDBRow
-{
-    uint32_t m_QueryNextAttempt;
-    int m_Vout;
-    unsigned char m_TxID[MC_TDB_TXID_SIZE];                               
-    mc_TxEntity m_Entity;
-    unsigned char m_Hash[MC_CDB_CHUNK_HASH_SIZE];                               // Chunk hash
-    
-    uint32_t m_Size;
-    uint32_t m_Flags;
-    uint32_t m_QueryAttempts;
-    uint32_t m_Status;
-    int64_t m_TotalChunkSize;
-    int64_t m_TotalChunkCount;                                                       
-    
-    void Zero();
-} mc_ChunkCollectorDBRow;
-
-typedef struct mc_ChunkCollectorRow
-{
-    mc_ChunkEntityKey m_ChunkDef;
-    uint32_t m_DBNextAttempt;
-    int m_Vout;
-    unsigned char m_TxID[MC_TDB_TXID_SIZE];                               
-    uint32_t m_Reserved1;
-    uint32_t m_Reserved2;        
-    mc_ChunkEntityValue m_State;
-    
-    void Zero();
-} mc_ChunkCollectorRow;
-
-typedef struct mc_ChunkCollectorStat
-{
-    int64_t m_Pending;
-    int64_t m_Delivered;
-    int64_t m_Sleeping;
-    int64_t m_Queried;
-    int64_t m_Requested;    
-    int64_t m_Unresponded;
-    int64_t m_Undelivered;
-    int64_t m_Baddelivered;
-    
-    void Zero();
-} mc_ChunkCollectorStat;
-
-typedef struct mc_ChunkCollector
-{    
-    mc_Database *m_DB;                                                          // Database object
-    mc_ChunkDB *m_ChunkDB;
-    uint32_t m_KeyOffset;                                                       
-    uint32_t m_KeyDBOffset;                                                       
-    uint32_t m_KeySize;                                                         
-    uint32_t m_KeyDBSize;                                                         
-    uint32_t m_ValueOffset;                                                     
-    uint32_t m_ValueDBOffset;                                                     
-    uint32_t m_ValueSize;                                                       
-    uint32_t m_ValueDBSize;                                                       
-    uint32_t m_TotalSize;                                                       
-    uint32_t m_TotalDBSize;                                                       
-    int64_t m_AutoCommitDelay;
-    int64_t m_NextAutoCommitTimestamp;
-    int64_t m_NextTryTimestamp;
-    int m_MaxMemPoolSize;
-    int m_TimeoutRequest;
-    int m_TimeoutQuery;
-    int64_t m_TotalChunkSize;
-    int64_t m_TotalChunkCount;                                                       
-    
-    mc_ChunkCollectorStat m_StatLast[2];
-    mc_ChunkCollectorStat m_StatTotal[2];
-    
-    char m_Name[MC_PRM_NETWORK_NAME_MAX_SIZE+1];                                // Chain name
-    char m_DBName[MC_DCT_DB_MAX_PATH];                                          // Full database name
-    
-    mc_Buffer *m_MarkPool;
-    mc_Buffer *m_MemPool;
-    mc_Buffer *m_MemPoolNext;
-    mc_Buffer *m_MemPool1;
-    mc_Buffer *m_MemPool2;
-    
-    mc_ChunkCollectorDBRow m_DBRow;
-    mc_ChunkCollectorDBRow m_LastDBRow;
-    
-    void *m_Semaphore;                                                          // mc_TxDB object semaphore
-    uint64_t m_LockedBy;                                                        // ID of the thread locking it
-    
-    uint32_t m_InitMode;    
-    
-    mc_ChunkCollector()
-    {
-        Zero();
-    }
-    
-    ~mc_ChunkCollector()
-    {
-        Destroy();
-    }
-
-    void SetDBRow(mc_ChunkCollectorRow *collect_row);
-    void GetDBRow(mc_ChunkCollectorRow *collect_row);
-    int DeleteDBRow(mc_ChunkCollectorRow *collect_row);
-    int UpdateDBRow(mc_ChunkCollectorRow *collect_row);
-    int InsertDBRow(mc_ChunkCollectorRow *collect_row);
-    int SeekDB(void *dbrow);
-    int ReadFromDB(mc_Buffer *mempool,int rows);
-    
-    int Initialize(                                                             // Initialization
-              mc_ChunkDB *chunk_db,
-              const char *name,                                                 // Chain name
-              uint32_t mode);                                                   // Unused
-    
-    int InsertChunk(                                                            // Adds chunk to mempool
-                 const unsigned char *hash,                                     // Chunk hash (before chopping)    
-                 const mc_TxEntity *entity,                                     // Parent entity
-                 const unsigned char *txid,
-                 const int vout,
-                 const uint32_t chunk_size);  
-    
-    int InsertChunkInternal(                  
-                 const unsigned char *hash,   
-                 const mc_TxEntity *entity,   
-                 const unsigned char *txid,
-                 const int vout,
-                 const uint32_t chunk_size);  
-
-    int MarkAndClear(uint32_t flag, int unmark);    
-    int CopyFlags();    
-    int FillMarkPoolByHash(const unsigned char *hash);    
-    int FillMarkPoolByFlag(uint32_t flag, uint32_t not_flag);    
-        
-    int Commit();                                                      
-    int CommitInternal(int fill_mempool); 
-    
-    int Unsubscribe(mc_Buffer* lpEntities);
-    
-    void Zero();    
-    int Destroy();
-    void Dump(const char *message);
-    
-    void LogString(const char *message);
-    
-    
-    int Lock();
-    int Lock(int write_mode, int allow_secondary);
-    void UnLock();    
-} mc_ChunkCollector;
-
-#endif /* MULTICHAIN_CHUNKCOLLECTOR_H */
-
diff --git a/src/wallet/chunkdb.cpp b/src/wallet/chunkdb.cpp
deleted file mode 100644
index 9a771f1..0000000
--- a/src/wallet/chunkdb.cpp
+++ /dev/null
@@ -1,2124 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#include "multichain/multichain.h"
-#include "wallet/chunkdb.h"
-
-#define MC_CDB_TMP_FLAG_SHOULD_COMMIT           0x00000001
-#define MC_CDB_FILE_PAGE_SIZE                   0x00100000
-
-unsigned char null_txid[MC_TDB_TXID_SIZE];
-
-void mc_SubscriptionFileDBRow::Zero()
-{
-    memset(this,0,sizeof(mc_SubscriptionFileDBRow));    
-    m_RecordType=MC_CDB_TYPE_FILE;
-}
-
-void mc_SubscriptionDBRow::Zero()
-{
-    memset(this,0,sizeof(mc_SubscriptionDBRow));    
-    m_RecordType=MC_CDB_TYPE_SUBSCRIPTION;    
-}
-
-void mc_ChunkDBStat::Zero()
-{
-    memset(this,0,sizeof(mc_ChunkDBStat));    
-    m_RecordType=MC_CDB_TYPE_DB_STAT;
-    m_ChunkDBVersion=1;
-}
-
-void mc_ChunkDBRow::Zero()
-{
-    memset(this,0,sizeof(mc_ChunkDBRow));        
-}
-
-void mc_ChunkDBRow::SwapPosBytes()
-{
-    unsigned char *ptr=(unsigned char *)&m_Pos;
-    unsigned char t;
-    t=ptr[0];
-    ptr[0]=ptr[3];
-    ptr[3]=t;
-    t=ptr[1];
-    ptr[1]=ptr[2];
-    ptr[2]=t;
-}
-
-void mc_ChunkDB::LogString(const char *message)
-{
-    FILE *fHan;
-    
-    fHan=fopen(m_LogFileName,"a");
-    if(fHan == NULL)
-    {
-        return;
-    }
-
-    mc_LogString(fHan,message);  
-    fclose(fHan);
-}
-
-void mc_ChunkDB::Zero()
-{
-    m_DirName[0]=0;
-    m_DBName[0]=0;
-    m_LogFileName[0]=0;
-    m_DB=NULL;
-    m_KeyOffset=0;
-    m_KeySize=40;
-    m_ValueOffset=40;
-    m_ValueSize=40;    
-    m_TotalSize=m_KeySize+m_ValueSize;
-    
-    m_Subscriptions=NULL;    
-    m_MemPool=NULL;
-    m_ChunkData=NULL;
-    m_TmpScript=NULL;
-    
-    m_Semaphore=NULL;
-    m_LockedBy=0;    
-}
-
-int mc_ChunkDB::Destroy()
-{
-    if(m_DB)
-    {
-        m_DB->Close();
-        delete m_DB;    
-        m_DB=NULL;
-    }
-    
-    if(m_Subscriptions)
-    {
-        delete m_Subscriptions;
-    }
-    
-    if(m_MemPool)
-    {
-        delete m_MemPool;
-    }
-    
-    if(m_ChunkData)
-    {
-        delete m_ChunkData;
-    }
-    
-    if(m_TmpScript)
-    {
-        delete m_TmpScript;
-    }
-    
-    if(m_Semaphore)
-    {
-        __US_SemDestroy(m_Semaphore);
-    }
-     
-    
-    Zero();
-    return MC_ERR_NOERROR;       
-}
-
-int mc_ChunkDB::Lock(int write_mode,int allow_secondary)
-{        
-    uint64_t this_thread;
-    this_thread=__US_ThreadID();
-    
-    if(this_thread == m_LockedBy)
-    {
-        if(allow_secondary == 0)
-        {
-            LogString("Secondary lock!!!");
-        }
-        return allow_secondary;
-    }
-    
-    __US_SemWait(m_Semaphore); 
-    m_LockedBy=this_thread;
-    
-    return 0;
-}
-
-void mc_ChunkDB::UnLock()
-{    
-    m_LockedBy=0;
-    __US_SemPost(m_Semaphore);
-}
-
-int mc_ChunkDB::Lock()
-{        
-    return Lock(1,0);
-}
-
-int mc_ChunkDB::AddSubscription(mc_SubscriptionDBRow *subscription)
-{
-    char enthex[33];
-    char dir_name[64];
-    int err;
-    switch(subscription->m_Entity.m_EntityType)
-    {
-        case MC_TET_STREAM:
-            sprintf_hex(enthex,subscription->m_Entity.m_EntityID,MC_AST_SHORT_TXID_SIZE);
-            sprintf(dir_name,"chunks/data/stream-%s",enthex);
-            break;
-        case MC_TET_AUTHOR:
-            sprintf(dir_name,"chunks/data/source");
-            break;
-        case MC_TET_NONE:
-            break;            
-        default:
-            return MC_ERR_NOT_SUPPORTED;
-    }
-    
-    if(subscription->m_Entity.m_EntityType != MC_TET_NONE)
-    {
-        mc_GetFullFileName(m_Name,dir_name,"",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,subscription->m_DirName);
-        mc_CreateDir(subscription->m_DirName);
-    }
-    else
-    {
-        subscription->m_DirName[0]=0x00;
-    }
-
-    if(subscription->m_SubscriptionID >= m_Subscriptions->GetCount())
-    {
-        err=m_Subscriptions->SetCount(subscription->m_SubscriptionID+1);
-        if(err)
-        {
-            return err;
-        }
-    }
-    
-    return m_Subscriptions->PutRow(subscription->m_SubscriptionID,subscription,(char*)subscription+m_ValueOffset);    
-}
-
-mc_SubscriptionDBRow *mc_ChunkDB::FindSubscription(const mc_TxEntity* entity)
-{
-    int row;
-    mc_SubscriptionDBRow subscription;
-
-    if(entity == NULL)
-    {
-        return  (mc_SubscriptionDBRow *)m_Subscriptions->GetRow(0);
-    }
-    
-    subscription.Zero();
-    
-    subscription.m_RecordType=MC_CDB_TYPE_SUBSCRIPTION;
-    memcpy(&subscription.m_Entity,entity,sizeof(mc_TxEntity));
-    
-    row=m_Subscriptions->Seek(&subscription);
-    if(row >= 0)
-    {
-        return  (mc_SubscriptionDBRow *)m_Subscriptions->GetRow(row);
-    }
-    
-    return NULL;
-}
-
-int mc_ChunkDB::AddEntityInternal(mc_TxEntity* entity, uint32_t flags)
-{
-    int err;
-    mc_SubscriptionDBRow subscription;
-    char msg[256];
-    char enthex[65];
-    
-    err=MC_ERR_NOERROR;
-    
-    subscription.Zero();
-    
-    subscription.m_RecordType=MC_CDB_TYPE_SUBSCRIPTION;
-    memcpy(&subscription.m_Entity,entity,sizeof(mc_TxEntity));
-    
-    subscription.m_Entity.m_EntityType &= MC_TET_TYPE_MASK;
-    
-    if(FindSubscription(&subscription.m_Entity))
-    {
-        return MC_ERR_NOERROR;
-    }
-    
-    subscription.m_Flags=flags;
-    subscription.m_SubscriptionID=m_DBStat.m_LastSubscription+1;
-    
-    err=AddSubscription(&subscription);
-    
-    if(err == MC_ERR_NOERROR)
-    {
-        m_DBStat.m_LastSubscription+=1;
-
-        err=m_DB->Write((char*)&subscription+m_KeyOffset,m_KeySize,(char*)&subscription+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-
-        if(err == MC_ERR_NOERROR)
-        {    
-            err=m_DB->Write((char*)&m_DBStat+m_KeyOffset,m_KeySize,(char*)&m_DBStat+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        }
-
-        if(err == MC_ERR_NOERROR)
-        {
-            err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);        
-        }
-
-        if(err)
-        {
-            m_DBStat.m_LastSubscription-=1;
-            m_Subscriptions->SetCount(m_Subscriptions->GetCount()-1);
-        }
-    }
-    
-    sprintf_hex(enthex,entity->m_EntityID,MC_TDB_ENTITY_ID_SIZE);
-
-    if(err)
-    {
-        sprintf(msg,"Could not add entity (%08X, %s), error: %d",entity->m_EntityType,enthex,err);        
-        LogString(msg);            
-    }
-    else
-    {
-        sprintf(msg,"Entity (%08X, %s) added successfully",entity->m_EntityType,enthex);
-        LogString(msg);
-    }
-    
-    return err;
-}
-
-int mc_ChunkDB::AddEntity(mc_TxEntity* entity, uint32_t flags)
-{
-    int err;
-    
-    Lock();
-    err=AddEntityInternal(entity,flags);
-    UnLock();
-    
-    return err;
-}
-
-int mc_ChunkDB::SourceChunksRecovery()                          
-{
-    int err;
-    mc_SubscriptionDBRow *subscription;
-    mc_ChunkDBRow chunk_def;
-    char FileName[MC_DCT_DB_MAX_PATH];    
-    int FileHan;
-    unsigned char* buf;
-    int chunk_found=0;
-    char msg[256];
-    
-    subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(1);
-    
-    SetFileName(FileName,subscription,subscription->m_LastFileID);
-    FileHan=open(FileName,_O_BINARY | O_RDONLY, S_IRUSR | S_IWUSR);
-    if(FileHan<=0)
-    {
-        return MC_ERR_NOERROR;
-    }
-    int64_t file_size=0;
-    int64_t file_offset=subscription->m_LastFileSize;
-    int64_t buf_offset,buf_tail,buf_size,offset,read_offset;    
-    uint32_t param_value_start;
-    size_t bytes;
-    int count=0;
-    buf_offset=0;
-    buf_tail=0;
-    file_size=lseek64(FileHan,0,SEEK_END);
-    lseek64(FileHan,file_offset,SEEK_SET);
-    m_TmpScript->Resize(MC_CDB_MAX_FILE_READ_BUFFER_SIZE,1);
-    buf=m_TmpScript->m_lpData;
-    chunk_def.Zero();
-    chunk_def.m_SubscriptionID=subscription->m_SubscriptionID;
-    
-    err=MC_ERR_NOERROR;
-    
-    sprintf(msg,"Starting source recovery, last file: %d, file_size: %ld, file offset: %ld",subscription->m_LastFileID,file_size,file_offset);        
-    LogString(msg);            
-    
-    while(file_offset<file_size)
-    {
-        buf_size=MC_CDB_MAX_FILE_READ_BUFFER_SIZE-buf_tail;
-        if(buf_size>file_size-file_offset)
-        {
-            buf_size=file_size-file_offset;
-        }
-        read_offset=file_offset;
-        if(read(FileHan,buf+buf_tail,buf_size) != buf_size)
-        {
-            err=MC_ERR_INTERNAL_ERROR;                    
-        }
-        if(err==MC_ERR_NOERROR)
-        {
-            file_offset+=buf_size;
-            buf_size+=buf_tail;
-            buf_tail=0;
-            buf_offset=0;
-
-            while(buf_offset < buf_size)
-            {
-                offset=mc_GetParamFromDetailsScriptErr(buf,buf_size,buf_offset,&param_value_start,&bytes,&err);
-                if(err)
-                {
-                    buf_tail=buf_size-buf_offset;
-                    if(param_value_start<buf_size)
-                    {
-                        if(param_value_start-buf_offset+bytes>MC_CDB_MAX_FILE_READ_BUFFER_SIZE)
-                        {
-                            buf_tail=0;
-                            file_offset+=param_value_start+bytes-buf_size;
-                            if(file_offset<file_size)
-                            {
-                                lseek64(FileHan,file_offset,SEEK_SET);
-                            }
-                        }
-                    }
-                    if(buf_tail)                                
-                    {
-                        memmove(buf,buf+buf_offset,buf_tail);
-                    }
-                    buf_offset=buf_size;
-                    err=MC_ERR_NOERROR;
-                }
-                else
-                {
-                    if(buf[buf_offset] != 0x00)
-                    {
-                        err= MC_ERR_CORRUPTED;
-                    }
-                    else
-                    {
-                        switch(buf[buf_offset+1])
-                        {
-                            case MC_ENT_SPRM_TIMESTAMP:
-                                if(chunk_found)
-                                {
-                                    chunk_def.m_InternalFileID=subscription->m_LastFileID;
-                                    chunk_def.m_InternalFileOffset=subscription->m_LastFileSize;
-                                    subscription->m_LastFileSize=read_offset+buf_offset;                                
-                                    chunk_def.m_HeaderSize=subscription->m_LastFileSize-chunk_def.m_InternalFileOffset-chunk_def.m_Size;
-                                    chunk_def.SwapPosBytes();
-                                    err=m_DB->Write((char*)&chunk_def+m_KeyOffset,m_KeySize,(char*)&chunk_def+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-                                    chunk_def.SwapPosBytes();
-                                    count++;
-                                    subscription->m_Count+=1;
-                                    subscription->m_FullSize+=chunk_def.m_Size;
-                                    m_DBStat.m_Count+=1;
-                                    m_DBStat.m_FullSize+=chunk_def.m_Size;
-                                    chunk_def.Zero();
-                                    chunk_def.m_SubscriptionID=subscription->m_SubscriptionID;
-                                }
-                                if(err==MC_ERR_NOERROR)
-                                {
-                                    chunk_found=1;
-                                }
-                                break;
-                            case MC_ENT_SPRM_CHUNK_HASH:
-                                memcpy(chunk_def.m_Hash,buf+param_value_start,bytes);
-                                break;
-                            case MC_ENT_SPRM_ITEM_COUNT:
-                                if(bytes != sizeof(uint32_t))
-                                {
-                                    err=MC_ERR_CORRUPTED;                                            
-                                }
-                                else
-                                {
-                                    chunk_def.m_Pos=(uint32_t)mc_GetLE(buf+param_value_start,bytes);
-                                }                                        
-                                break;
-                            case MC_ENT_SPRM_CHUNK_SIZE:
-                                if(bytes != sizeof(uint32_t))
-                                {
-                                    err=MC_ERR_CORRUPTED;                                            
-                                }
-                                else
-                                {
-                                    chunk_def.m_Size=(uint32_t)mc_GetLE(buf+param_value_start,bytes);
-                                }                                        
-                                break;
-                            case MC_ENT_SPRM_FILE_END:
-                                chunk_def.m_InternalFileID=subscription->m_LastFileID;
-                                chunk_def.m_InternalFileOffset=subscription->m_LastFileSize;
-                                subscription->m_LastFileSize=read_offset+buf_offset;                                
-                                chunk_def.m_HeaderSize=subscription->m_LastFileSize-chunk_def.m_InternalFileOffset-chunk_def.m_Size;
-                                sprintf(msg,"Found end marker at: %ld",read_offset+buf_offset);        
-                                LogString(msg);            
-                                offset=buf_size;
-                                file_offset=file_size;                                
-                                break;
-                        }
-                        buf_offset=offset;                            
-                    }
-                }
-                if(err==MC_ERR_NOERROR)
-                {
-                    if(count >= 1000)
-                    {
-                        if(err == MC_ERR_NOERROR)
-                        {
-                            err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);        
-                            count=0;
-                        }                            
-                    }
-                }
-                if(err)
-                {
-                    sprintf(msg,"Error %d on file offset %ld",err,read_offset+buf_offset);        
-                    LogString(msg);                                
-                    buf_offset=buf_size;
-                    file_offset=file_size;                                
-                }
-            }
-        }
-        else
-        {
-            sprintf(msg,"Read error %d on file offset %ld",err,read_offset+buf_offset);        
-            LogString(msg);                                
-            file_offset=file_size;
-        }
-    }
-        
-        
-    if(FileHan>0)
-    {
-        close(FileHan);
-    }
-
-    if(err == MC_ERR_NOERROR)
-    {
-        if(chunk_found)
-        {
-            if(chunk_def.m_HeaderSize == 0)
-            {
-                chunk_def.m_InternalFileID=subscription->m_LastFileID;
-                chunk_def.m_InternalFileOffset=subscription->m_LastFileSize;
-                subscription->m_LastFileSize=file_size;                                
-                chunk_def.m_HeaderSize=subscription->m_LastFileSize-chunk_def.m_InternalFileOffset-chunk_def.m_Size;
-            }
-            chunk_def.SwapPosBytes();
-            err=m_DB->Write((char*)&chunk_def+m_KeyOffset,m_KeySize,(char*)&chunk_def+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            chunk_def.SwapPosBytes();
-            subscription->m_Count+=1;
-            subscription->m_FullSize+=chunk_def.m_Size;
-            m_DBStat.m_Count+=1;
-            m_DBStat.m_FullSize+=chunk_def.m_Size;
-            count++;
-            if(err == MC_ERR_NOERROR)
-            {
-                err=m_DB->Write((char*)subscription+m_KeyOffset,m_KeySize,(char*)subscription+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            }
-            if(err == MC_ERR_NOERROR)
-            {
-                err=m_DB->Write((char*)&m_DBStat+m_KeyOffset,m_KeySize,(char*)&m_DBStat+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            }
-            if(err == MC_ERR_NOERROR)
-            {
-                err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL | MC_OPT_DB_DATABASE_SYNC_ON_COMMIT);
-            }                    
-        }
-    }
-
-    if(err)
-    {
-        sprintf(msg,"Source recovery completed with error %d",err);                        
-    }
-    else
-    {
-        if(chunk_found)
-        {
-            sprintf(msg,"Source recovery completed, chunks recovered");                    
-        }
-        else
-        {
-            sprintf(msg,"Source recovery completed, no recovery needed");                    
-        }
-    }
-    LogString(msg);                        
-    
-    Dump("SourceChunkRecovery");
-    return err;
-}
-
-int mc_ChunkDB::RemoveEntityInternal(mc_TxEntity *entity)                          
-{
-    int err;
-    mc_SubscriptionDBRow subscription;
-    mc_SubscriptionDBRow *old_subscription;
-    mc_ChunkDBRow chunk_def;
-    char msg[256];
-    char enthex[65];
-    char enthex_dir[65];
-    unsigned char* buf;
-    int FileHan;
-    char FileName[MC_DCT_DB_MAX_PATH];    
-    int chunk_found=0;
-    int count=0;
-    
-    err=MC_ERR_NOERROR;
-    sprintf_hex(enthex,entity->m_EntityID,MC_TDB_ENTITY_ID_SIZE);
-    
-    subscription.Zero();
-    subscription.m_RecordType=MC_CDB_TYPE_SUBSCRIPTION;
-    memcpy(&subscription.m_Entity,entity,sizeof(mc_TxEntity));
-    
-    subscription.m_Entity.m_EntityType &= MC_TET_TYPE_MASK;
-    sprintf_hex(enthex_dir,subscription.m_Entity.m_EntityID,MC_AST_SHORT_TXID_SIZE);
-    
-    old_subscription=FindSubscription(&subscription.m_Entity);
-    
-    if(old_subscription == NULL)
-    {
-        return MC_ERR_NOERROR;
-    }
-
-    CommitInternal(-4,0);
-    
-    memcpy(&subscription,old_subscription,sizeof(mc_SubscriptionDBRow));
-    subscription.m_Entity.m_EntityType |= MC_TET_DELETED;
-    
-    
-    err=m_DB->Write((char*)&subscription+m_KeyOffset,m_KeySize,(char*)&subscription+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-    if(err == MC_ERR_NOERROR)
-    {    
-        err=m_DB->Delete((char*)old_subscription+m_KeyOffset,m_KeySize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-    }
-    if(err == MC_ERR_NOERROR)
-    {
-        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);        
-    }
-    
-    if(err)
-    {
-        goto exitlbl;
-    }
-    
-    m_Subscriptions->PutRow(old_subscription->m_SubscriptionID,&subscription,(char*)&subscription+m_ValueOffset);
-    
-    sprintf(msg,"Entity (%08X, %s) unlinked successfully",entity->m_EntityType,enthex);
-    LogString(msg);
- 
-    m_TmpScript->Resize(MC_CDB_MAX_FILE_READ_BUFFER_SIZE,1);
-    buf=m_TmpScript->m_lpData;
-    
-    chunk_def.Zero();
-    chunk_def.m_SubscriptionID=old_subscription->m_SubscriptionID;
-    
-    for(int file_id=0;file_id<=old_subscription->m_LastFileID;file_id++)
-    {
-        err=MC_ERR_NOERROR;
-        
-        SetFileName(FileName,old_subscription,file_id);
-        FileHan=open(FileName,_O_BINARY | O_RDONLY, S_IRUSR | S_IWUSR);
-        if(FileHan<=0)
-        {
-            err=MC_ERR_INTERNAL_ERROR;
-        }
-    
-        if(err==MC_ERR_NOERROR)
-        {
-            int64_t file_size=0;
-            int64_t file_offset=0;
-            int64_t buf_offset,buf_tail,buf_size,offset;
-            uint32_t param_value_start;
-            size_t bytes;
-            buf_offset=0;
-            buf_tail=0;
-            file_size=lseek64(FileHan,0,SEEK_END);
-            lseek64(FileHan,0,SEEK_SET);
-            while(file_offset<file_size)
-            {
-                buf_size=MC_CDB_MAX_FILE_READ_BUFFER_SIZE-buf_tail;
-                if(buf_size>file_size-file_offset)
-                {
-                    buf_size=file_size-file_offset;
-                }
-                if(read(FileHan,buf+buf_tail,buf_size) != buf_size)
-                {
-                    err=MC_ERR_INTERNAL_ERROR;                    
-                }
-                if(err==MC_ERR_NOERROR)
-                {
-                    file_offset+=buf_size;
-                    buf_size+=buf_tail;
-                    buf_tail=0;
-                    buf_offset=0;
-                    
-                    while(buf_offset < buf_size)
-                    {
-                        offset=mc_GetParamFromDetailsScriptErr(buf,buf_size,buf_offset,&param_value_start,&bytes,&err);
-                        if(err)
-                        {
-                            buf_tail=buf_size-buf_offset;
-                            if(param_value_start<buf_size)
-                            {
-                                if(param_value_start-buf_offset+bytes>MC_CDB_MAX_FILE_READ_BUFFER_SIZE)
-                                {
-                                    buf_tail=0;
-                                    file_offset+=param_value_start+bytes-buf_size;
-                                    if(file_offset<file_size)
-                                    {
-                                        lseek64(FileHan,file_offset,SEEK_SET);
-                                    }
-                                }
-                            }
-                            if(buf_tail)                                
-                            {
-                                memmove(buf,buf+buf_offset,buf_tail);
-                            }
-                            buf_offset=buf_size;
-                            err=MC_ERR_NOERROR;
-                        }
-                        else
-                        {
-                            if(buf[buf_offset] != 0x00)
-                            {
-                                err= MC_ERR_CORRUPTED;
-                            }
-                            else
-                            {
-                                switch(buf[buf_offset+1])
-                                {
-                                    case MC_ENT_SPRM_CHUNK_HASH:
-                                        if(chunk_found)
-                                        {
-                                            chunk_def.SwapPosBytes();
-                                            err=m_DB->Delete((char*)&chunk_def+m_KeyOffset,m_KeySize,MC_OPT_DB_DATABASE_TRANSACTIONAL);                                            
-                                            chunk_def.SwapPosBytes();
-                                            count++;
-                                            chunk_def.Zero();
-                                            chunk_def.m_SubscriptionID=old_subscription->m_SubscriptionID;
-                                        }
-                                        if(err==MC_ERR_NOERROR)
-                                        {
-                                            if(bytes != MC_CDB_CHUNK_HASH_SIZE)
-                                            {
-                                                err=MC_ERR_CORRUPTED;
-                                            }
-                                            else
-                                            {
-                                                chunk_found=1;
-                                                memcpy(chunk_def.m_Hash,buf+param_value_start,bytes);
-                                            }
-                                        }
-                                        break;
-                                    case MC_ENT_SPRM_ITEM_COUNT:
-                                        if(bytes != sizeof(uint32_t))
-                                        {
-                                            err=MC_ERR_CORRUPTED;                                            
-                                        }
-                                        else
-                                        {
-                                            chunk_def.m_Pos=(uint32_t)mc_GetLE(buf+param_value_start,bytes);
-                                        }                                        
-                                        break;
-                                    case MC_ENT_SPRM_FILE_END:
-                                        offset=buf_size;
-                                        file_offset=file_size;                                
-                                        break;
-                                }
-                                buf_offset=offset;                            
-                            }
-                        }
-                        if(err==MC_ERR_NOERROR)
-                        {
-                            if(count >= 1000)
-                            {
-                                if(err == MC_ERR_NOERROR)
-                                {
-                                    err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);        
-                                    count=0;
-                                }                            
-                            }
-                        }
-                        if(err)
-                        {
-                            buf_offset=buf_size;
-                            file_offset=file_size;                                
-                        }
-                    }
-                }
-                else
-                {
-                    file_offset=file_size;
-                }
-            }
-        }
-        
-        
-        if(FileHan>0)
-        {
-            close(FileHan);
-        }
-    }
-    
-    if(err == MC_ERR_NOERROR)
-    {
-        if(chunk_found)
-        {
-            chunk_def.SwapPosBytes();
-            err=m_DB->Delete((char*)&chunk_def+m_KeyOffset,m_KeySize,MC_OPT_DB_DATABASE_TRANSACTIONAL);                                            
-            chunk_def.SwapPosBytes();
-            count++;
-        }
-    }
-    if(err == MC_ERR_NOERROR)
-    {
-        if(count)
-        {
-            err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);        
-            count=0;
-        }                            
-    }
-
-    if(err == MC_ERR_NOERROR)
-    {
-        char dir_name[64];
-        sprintf(dir_name,"chunks/data/stream-%s",enthex_dir);
-        
-        mc_RemoveDir(mc_gState->m_Params->NetworkName(),dir_name);
-    }
-exitlbl:
-            
-
-    if(err)
-    {
-        sprintf(msg,"Could not remove entity (%08X, %s), error: %d",entity->m_EntityType,enthex,err);        
-        LogString(msg);            
-    }
-    else
-    {
-        sprintf(msg,"Entity (%08X, %s) removed successfully",entity->m_EntityType,enthex);
-        LogString(msg);
-    }
-    
-    return err;
-}
-
-int mc_ChunkDB::RemoveEntity(mc_TxEntity *entity)                          
-{
-    int err;
-    
-    Lock();
-    err=RemoveEntityInternal(entity);    
-    UnLock();    
-    
-    return err;
-}
-
-
-int mc_ChunkDB::FindSubscription(const mc_TxEntity *entity,mc_SubscriptionDBRow *subscription)
-{
-    mc_SubscriptionDBRow *found;
-    
-    Lock();
-    found=FindSubscription(entity);
-    if(found)
-    {
-        memcpy(subscription,found,sizeof(mc_SubscriptionDBRow));
-    }    
-    UnLock();
-    
-    return found ? MC_ERR_NOERROR : MC_ERR_NOT_FOUND;
-}
-
-
-
-int mc_ChunkDB::Initialize(const char *name,uint32_t mode)
-{
-    int err,value_len,new_db;   
-    char msg[256];
-    
-    mc_SubscriptionDBRow subscription;
-    
-    unsigned char *ptr;
-    
-    err=MC_ERR_NOERROR;
-    
-    strcpy(m_Name,name);
-    
-    m_DB=new mc_Database;
-    
-    mc_GetFullFileName(name,"chunks","",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,m_DirName);
-    mc_CreateDir(m_DirName);
-    mc_GetFullFileName(name,"chunks/chunks",".db",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,m_DBName);
-    mc_GetFullFileName(name,"chunks/chunks",".log",MC_FOM_RELATIVE_TO_DATADIR,m_LogFileName);
-    
-    m_DB->SetOption("KeySize",0,m_KeySize);
-    m_DB->SetOption("ValueSize",0,m_ValueSize);
-    
-    
-    err=m_DB->Open(m_DBName,MC_OPT_DB_DATABASE_CREATE_IF_MISSING | MC_OPT_DB_DATABASE_TRANSACTIONAL | MC_OPT_DB_DATABASE_LEVELDB);
-    
-    if(err)
-    {
-        LogString("Initialize: Cannot open database");
-        return err;
-    }
-
-    m_Subscriptions=new mc_Buffer;
-    
-    m_Subscriptions->Initialize(m_KeySize,sizeof(mc_SubscriptionDBRow),MC_BUF_MODE_MAP);    
-    
-    
-    subscription.Zero();
-    
-    m_DBStat.Zero();
-    
-    ptr=(unsigned char*)m_DB->Read((char*)&m_DBStat+m_KeyOffset,m_KeySize,&value_len,MC_OPT_DB_DATABASE_SEEK_ON_READ,&err);
-    if(err)
-    {
-        LogString("Initialize: Cannot read from database");
-        return err;
-    }
-
-    new_db=1;
-    if(ptr)                                                                     
-    {        
-        new_db=0;
-        memcpy((char*)&m_DBStat+m_ValueOffset,ptr,m_ValueSize);
-        
-        m_Subscriptions->SetCount(m_DBStat.m_LastSubscription+1);
-        subscription.Zero();
-        AddSubscription(&subscription);
-        
-        ptr=(unsigned char*)m_DB->MoveNext(&err);
-//        ptr=(unsigned char*)m_DB->Read((char*)&subscription+m_KeyOffset,m_KeySize,&value_len,MC_OPT_DB_DATABASE_SEEK_ON_READ,&err);
-        if(err)
-        {
-            return err;
-        }
-
-        if(ptr)
-        {
-            memcpy((char*)&subscription,ptr,m_TotalSize);
-        }
-        
-        while(ptr)
-        {
-            if( (subscription.m_RecordType != MC_CDB_TYPE_SUBSCRIPTION) || 
-                (subscription.m_Zero != 0) || (subscription.m_Zero1 != 0) || (subscription.m_Zero2 != 0))
-            {
-                ptr=NULL;
-            }
-            if(ptr)
-            {
-                AddSubscription(&subscription);
-                if(subscription.m_SubscriptionID > m_DBStat.m_LastSubscription)
-                {
-                    m_DBStat.m_LastSubscription=subscription.m_SubscriptionID;
-                }
-                ptr=(unsigned char*)m_DB->MoveNext(&err);
-                if(err)
-                {
-                    LogString("Error on MoveNext");            
-                    return MC_ERR_CORRUPTED;            
-                }
-                if(ptr)
-                {
-                    memcpy((char*)&subscription,ptr,m_TotalSize);
-                }
-            }            
-        }
-    }
-    else
-    {
-        m_Subscriptions->SetCount(m_DBStat.m_LastSubscription+2);
-        subscription.Zero();
-        AddSubscription(&subscription);
-        
-        subscription.m_Entity.m_EntityType=MC_TET_AUTHOR;
-        subscription.m_SubscriptionID=1;
-        AddSubscription(&subscription);
-        
-        m_DBStat.m_LastSubscription=1;
-        
-        err=m_DB->Write((char*)&m_DBStat+m_KeyOffset,m_KeySize,(char*)&m_DBStat+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return err;
-        }        
-        
-        err=m_DB->Write((char*)&subscription+m_KeyOffset,m_KeySize,(char*)&subscription+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return err;
-        }        
-        
-        
-        err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL);
-        if(err)
-        {
-            return err;
-        }        
-    }
- 
-    m_DBStat.m_InitMode &= MC_WMD_MODE_MASK;
-    m_DBStat.m_InitMode |= mode;
-    
-    m_MemPool=new mc_Buffer;                                                // Key - entity with m_Pos set to 0 + txid
-    err=m_MemPool->Initialize(m_KeySize,m_TotalSize,MC_BUF_MODE_MAP);
-    
-    m_ChunkData=new mc_Script();
-    m_ChunkData->Clear();
-   
-    m_TmpScript=new mc_Script;
-    m_TmpScript->Clear();
-    
-    memset(null_txid,0,MC_TDB_TXID_SIZE);    
-    
-    m_Semaphore=__US_SemCreate();
-    if(m_Semaphore == NULL)
-    {
-        LogString("Initialize: Cannot initialize semaphore");
-        return MC_ERR_INTERNAL_ERROR;
-    }
-
-    Dump("Initialize");
-    
-    sprintf(msg, "Initialized. Chunks: %d",m_DBStat.m_Count);
-    LogString(msg);    
-    
-    if(new_db == 0)
-    {
-        SourceChunksRecovery();        
-    }
-    
-    return err;   
-}
-
-void mc_ChunkDB::Dump(const char *message)
-{
-    Dump(message,0);
-}
-
-void mc_ChunkDB::Dump(const char *message, int force)
-{    
-    if(force == 0)
-    {
-        if((m_DBStat.m_InitMode & MC_WMD_DEBUG) == 0)
-        {
-            return;
-        }
-    }
-    mc_ChunkDBRow dbrow;
-    
-    unsigned char *ptr;
-    int dbvalue_len,err,i;
-    char ShortName[65];                                     
-    char FileName[MC_DCT_DB_MAX_PATH];                      
-    FILE *fHan;
-    
-    sprintf(ShortName,"chunks/chunks");
-    mc_GetFullFileName(m_Name,ShortName,".dmp",MC_FOM_RELATIVE_TO_DATADIR | MC_FOM_CREATE_DIR,FileName);
-    
-    fHan=fopen(FileName,"a");
-    if(fHan == NULL)
-    {
-        return;
-    }
-
-    mc_LogString(fHan,message);     
-    
-    fprintf(fHan,"\nDB\n");
-    dbrow.Zero();    
-    ptr=(unsigned char*)m_DB->Read((char*)&dbrow+m_KeyOffset,m_KeySize,&dbvalue_len,MC_OPT_DB_DATABASE_SEEK_ON_READ,&err);
-    if(err)
-    {
-        return;
-    }
-
-    if(ptr)
-    {
-        memcpy((char*)&dbrow+m_ValueOffset,ptr,m_ValueSize);
-        while(ptr)
-        {
-            mc_MemoryDumpCharSizeToFile(fHan,(char*)&dbrow+m_KeyOffset,0,m_TotalSize,m_TotalSize);        
-            ptr=(unsigned char*)m_DB->MoveNext(&err);
-            if(ptr)
-            {
-                memcpy((char*)&dbrow+m_KeyOffset,ptr,m_TotalSize);            
-            }
-        }
-    }
-
-    fprintf(fHan,"\nMempool\n");
-    if(m_MemPool->GetCount())
-    {
-        mc_MemoryDumpCharSizeToFile(fHan,m_MemPool->GetRow(0),0,m_MemPool->GetCount()*m_TotalSize,m_TotalSize);    
-    }
-    
-    fprintf(fHan,"\nData\n");
-    if(m_ChunkData->m_Size)
-    {
-        mc_MemoryDumpCharSizeToFile(fHan,m_ChunkData->m_lpData,0,m_ChunkData->m_Size,m_TotalSize);    
-    }
-    
-    
-    fprintf(fHan,"\nSubscriptions\n");
-    
-    for(i=0;i<m_Subscriptions->GetCount();i++)
-    {
-        mc_MemoryDumpCharSizeToFile(fHan,m_Subscriptions->GetRow(i),0,m_TotalSize,m_TotalSize);    
-    }
-    
-    fprintf(fHan,"\n<<<<<< \tChain height: %6d\t%s\n\n",mc_gState->m_Permissions->m_Block,message);
-    fclose(fHan);
-}
-
-int mc_ScriptMatchesTxIDAndVOut(unsigned char *ptr,size_t bytes,const unsigned char *txid,const int vout)
-{
-    size_t value_size;
-    uint32_t offset;
-
-    if(ptr == NULL)
-    {
-        return MC_ERR_NOT_FOUND;
-    }
-    
-    offset=mc_FindSpecialParamInDetailsScript(ptr,bytes,MC_ENT_SPRM_SOURCE_TXID,&value_size);
-    if(offset != bytes)
-    {
-        if(memcmp(ptr+offset,txid,MC_TDB_TXID_SIZE) == 0)
-        {
-            if(vout >= 0)
-            {
-                offset=mc_FindSpecialParamInDetailsScript(ptr,bytes,MC_ENT_SPRM_SOURCE_VOUT,&value_size);
-                if(offset != bytes)
-                {
-                    if(mc_GetLE(ptr+offset,value_size) == vout)
-                    {
-                        return MC_ERR_NOERROR;                                                                
-                    }
-                }                            
-            }
-            else
-            {
-                return MC_ERR_NOERROR;                            
-            }
-        }
-    }
-
-    return MC_ERR_NOT_FOUND;
-}
-
-int mc_ChunkDB::GetChunkDefInternal(
-                        mc_ChunkDBRow *chunk_def,
-                        const unsigned char *hash,  
-                        const void *entity,
-                        const unsigned char *txid,
-                        const int vout,
-                        int *mempool_row)
-{
-    mc_SubscriptionDBRow *subscription;
-    int err,value_len,mprow; 
-    size_t bytes;
-    uint32_t on_disk_items=0;
-    uint32_t total_items=0;
-    unsigned char *ptr;
-    
-    err=MC_ERR_NOERROR;
-    
-    chunk_def->Zero();
-    
-    subscription=FindSubscription((mc_TxEntity*)entity);
-    
-    if(subscription == NULL)
-    {
-        return MC_ERR_NOT_FOUND;
-    }
-
-    if(mempool_row)
-    {
-        *mempool_row=-1;
-    }
-
-    memcpy(chunk_def->m_Hash,hash,MC_CDB_CHUNK_HASH_SIZE);
-    chunk_def->m_SubscriptionID=subscription->m_SubscriptionID;
-    chunk_def->m_Pos=0;
-    
-    mprow=m_MemPool->Seek((unsigned char*)chunk_def);
-    if(mprow >= 0)
-    {
-        if(mempool_row)
-        {
-            *mempool_row=mprow;
-        }
-        memcpy(chunk_def,(mc_ChunkDBRow *)m_MemPool->GetRow(mprow),sizeof(mc_ChunkDBRow));
-        if(txid)
-        {
-            on_disk_items=chunk_def->m_TmpOnDiskItems;
-            total_items=chunk_def->m_ItemCount;
-            while(chunk_def->m_Pos+on_disk_items < total_items)
-            {
-//                ptr=(unsigned char *)m_ChunkData->GetData(chunk_def->m_InternalFileOffset,&bytes);
-                if( (chunk_def->m_TxIDStart == 0) || (chunk_def->m_TxIDStart == (uint32_t)mc_GetLE((void*)txid,4)))
-                {
-                    ptr=GetChunkInternal(chunk_def,-1,-1,&bytes);
-                    if(mc_ScriptMatchesTxIDAndVOut(ptr,bytes,txid,vout) == MC_ERR_NOERROR)
-                    {
-                        return MC_ERR_NOERROR;
-                    }
-                }
-                chunk_def->m_Pos+=1;
-                if(chunk_def->m_Pos < total_items)
-                {
-                    mprow=m_MemPool->Seek((unsigned char*)chunk_def);
-                    if(mprow >= 0)
-                    {
-                        memcpy(chunk_def,(mc_ChunkDBRow *)m_MemPool->GetRow(mprow),sizeof(mc_ChunkDBRow));
-                    }
-                    else
-                    {
-                        chunk_def->m_Pos=total_items-on_disk_items;
-                    }
-                }
-            }
-        }
-        else
-        {
-            if(mempool_row)
-            {
-                *mempool_row=mprow;
-            }
-            return MC_ERR_NOERROR;
-        }
-        if(on_disk_items == 0)
-        {
-            err=MC_ERR_NOT_FOUND;            
-        }
-        else
-        {
-            mprow=-1;
-            chunk_def->m_Pos=0;
-        }
-    }
-    
-    if(mprow < 0)
-    {
-        chunk_def->SwapPosBytes();
-        ptr=(unsigned char*)m_DB->Read((char*)chunk_def+m_KeyOffset,m_KeySize,&value_len,MC_OPT_DB_DATABASE_NEXT_ON_READ,&err);
-        chunk_def->SwapPosBytes();
-        if(err)
-        {
-            return err;
-        }
-
-        if(ptr)
-        {
-            if(entity)
-            {
-                if(memcmp((char*)chunk_def+m_KeyOffset,ptr,m_KeySize))
-                {
-                    ptr=NULL;
-                }
-            }
-            else
-            {
-                if(memcmp(chunk_def->m_Hash,ptr,MC_CDB_CHUNK_HASH_SIZE))
-                {
-                    ptr=NULL;
-                }                
-            }
-        }
-        
-        if(ptr)                                                                     
-        {
-//            mc_DumpSize("E",chunk_def,m_TotalSize,40);
-//            mc_DumpSize("F",ptr,m_TotalSize,40);
-            memcpy((char*)chunk_def+m_ValueOffset,ptr+m_ValueOffset,m_ValueSize);        
-            on_disk_items=chunk_def->m_ItemCount;
-//            mc_DumpSize("G",chunk_def,m_TotalSize,40);
-            if(entity == NULL)
-            {
-                if(chunk_def->m_NextSubscriptionID == 0)
-                {
-                    chunk_def->m_NextSubscriptionID=((mc_ChunkDBRow*)ptr)->m_SubscriptionID;
-                }
-            }
-//            mc_DumpSize("H",chunk_def,m_TotalSize,40);
-            if(txid)
-            {
-//                ptr=GetChunkInternal(chunk_def,-1,-1,&bytes);
-                total_items=chunk_def->m_ItemCount;
-                while(chunk_def->m_Pos < on_disk_items)
-                {
-                    if( (chunk_def->m_TxIDStart == 0) || (chunk_def->m_TxIDStart == (uint32_t)mc_GetLE((void*)txid,4)))
-                    {
-                        ptr=GetChunkInternal(chunk_def,-1,-1,&bytes);
-                        if(mc_ScriptMatchesTxIDAndVOut(ptr,bytes,txid,vout) == MC_ERR_NOERROR)
-                        {
-                            return MC_ERR_NOERROR;
-                        }
-                    }
-                    chunk_def->m_Pos+=1;
-                    
-                    if(chunk_def->m_Pos < total_items)
-                    {
-                        chunk_def->SwapPosBytes();
-                        ptr=(unsigned char*)m_DB->Read((char*)chunk_def+m_KeyOffset,m_KeySize,&value_len,0,&err);
-                        chunk_def->SwapPosBytes();
-                        if(err)
-                        {
-                            return err;
-                        }
-                    
-                        if(ptr)
-                        {
-                            memcpy((char*)chunk_def+m_ValueOffset,ptr,m_ValueSize);        
-//                            ptr=GetChunkInternal(chunk_def,-1,-1,&bytes);
-                        }
-                        else
-                        {
-                            chunk_def->m_Pos=on_disk_items;
-                        }
-                    }
-                }
-                err=MC_ERR_NOT_FOUND;            
-            }
-            else
-            {
-/*                
-                if(entity == NULL)
-                {
-                    if(mempool_row)
-                    {
-                        while(chunk_def->m_NextSubscriptionID)
-                        {
-                            chunk_def->m_SubscriptionID=chunk_def->m_NextSubscriptionID;
-                            chunk_def->SwapPosBytes();
-                            ptr=(unsigned char*)m_DB->Read((char*)chunk_def+m_KeyOffset,m_KeySize,&value_len,0,&err);
-                            chunk_def->SwapPosBytes();
-                            if(err)
-                            {
-                                return err;
-                            }
-                    
-                            if(ptr)
-                            {
-                                memcpy((char*)chunk_def+m_ValueOffset,ptr,m_ValueSize);        
-                            }
-                            else
-                            {
-                                return MC_ERR_CORRUPTED;
-                            }                            
-                        }
-                    }
-                }
- */ 
-                return MC_ERR_NOERROR;                
-            }
-        }
-        else
-        {
-            err=MC_ERR_NOT_FOUND;
-        }
-    }
-    
-    return MC_ERR_NOT_FOUND;
-}
-
-int mc_ChunkDB::GetChunkDef(
-                        mc_ChunkDBRow *chunk_def,
-                        const unsigned char *hash,  
-                        const void *entity,
-                        const unsigned char *txid,
-                        const int vout)
-{
-    int err;
-    
-    Lock();
-    err=GetChunkDefInternal(chunk_def,hash,entity,txid,vout,NULL);
-    UnLock();
-    
-    return err;
-}
-
-int mc_ChunkDB::AddChunkInternal(                                                           
-                 const unsigned char *hash,                                     
-                 const mc_TxEntity *entity,                                     
-                 const unsigned char *txid,
-                 const int vout,
-                 const unsigned char *chunk,                                    
-                 const unsigned char *details,                                  
-                 const uint32_t chunk_size,                                     
-                 const uint32_t details_size,                                   
-                 const uint32_t flags)
-{
-    int err;
-    int add_null_row,add_entity_row;
-    int total_items,on_disk_items,pos;
-    int mempool_entity_row;
-    int mempool_last_null_row;
-    uint32_t timestamp;
-    size_t bytes;
-    const unsigned char *ptr;
-    char chunk_hex[65];
-    char msg[256];
-    char enthex[65];
-    
-    
-    mc_ChunkDBRow chunk_def;
-    mc_ChunkDBRow entity_chunk_def;
-    mc_ChunkDBRow null_chunk_def;
-    mc_SubscriptionDBRow *subscription;
-    
-    chunk_def.Zero();
-    
-    err=GetChunkDefInternal(&chunk_def,hash,entity,txid,vout,NULL);
-    if(err == MC_ERR_NOERROR)
-    {
-        return MC_ERR_FOUND;
-    }
-    if(err != MC_ERR_NOT_FOUND)
-    {
-        return err; 
-    }
-    
-    if( (m_ChunkData->m_Size + chunk_size + details_size + MC_CDB_MAX_CHUNK_EXTRA_SIZE > MC_CDB_MAX_CHUNK_DATA_POOL_SIZE) || 
-        (m_MemPool->GetCount() + 2 > MC_CDB_MAX_MEMPOOL_SIZE ) )
-    {
-        CommitInternal(-1,0);
-    }
-
-    subscription=FindSubscription(entity);
-    if(subscription == NULL)
-    {
-        LogString("Internal error: trying to add chunk to unsubscribed entity");
-        return MC_ERR_INTERNAL_ERROR;
-    }
-    if(subscription->m_SubscriptionID == 0)
-    {
-        LogString("Internal error: trying to add chunk to null entity");
-        return MC_ERR_INTERNAL_ERROR;        
-    }
-            
-    add_null_row=0;
-    add_entity_row=0;
-    total_items=0;
-    on_disk_items=0;
-    mempool_entity_row=-1;
-    
-    if(txid)
-    {
-        err=GetChunkDefInternal(&entity_chunk_def,hash,entity,NULL,-1,&mempool_entity_row);
-        if(err == MC_ERR_NOERROR)
-        {
-            total_items=entity_chunk_def.m_ItemCount;
-            on_disk_items=total_items;
-            if(entity_chunk_def.m_InternalFileID < 0)
-            {
-                on_disk_items=entity_chunk_def.m_TmpOnDiskItems;
-            }
-        }
-        else
-        {
-            if(err != MC_ERR_NOT_FOUND)
-            {
-                return err; 
-            }
-            entity_chunk_def.m_SubscriptionID=0;
-            add_entity_row=1;
-        }
-    }
-    else
-    {
-        add_entity_row=1;        
-    }
-
-    if(add_entity_row)
-    {
-        err=GetChunkDefInternal(&null_chunk_def,hash,NULL,NULL,-1,&mempool_last_null_row);
-        if(err == MC_ERR_NOT_FOUND)
-        {
-            add_null_row=1;
-        }  
-        else
-        {      
-            if(err != MC_ERR_NOERROR)
-            {
-                return err; 
-            }
-        }
-    }
-        
-    chunk_def.Zero();
-    memcpy(chunk_def.m_Hash,hash,MC_CDB_CHUNK_HASH_SIZE);
-    chunk_def.m_InternalFileID=-1;
-    chunk_def.m_InternalFileOffset=m_ChunkData->m_NumElements;
-    
-    m_TmpScript->Clear();    
-    m_TmpScript->AddElement();
-    
-    timestamp=mc_TimeNowAsUInt();
-    pos=total_items-on_disk_items;
-    
-    m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_TIMESTAMP,(unsigned char*)&timestamp,sizeof(timestamp));
-    m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_CHUNK_HASH,hash,MC_CDB_CHUNK_HASH_SIZE);
-    if(txid)
-    {
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_SOURCE_TXID,txid,MC_TDB_TXID_SIZE);
-        if(vout >= 0)
-        {
-            m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_SOURCE_VOUT,(unsigned char*)&vout,sizeof(vout));            
-        }
-    }
-/*    
-    else
-    {
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_SOURCE_TXID,null_txid,MC_TDB_TXID_SIZE);
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_SOURCE_VOUT,(unsigned char*)&vout,sizeof(vout));                    
-    }
- */ 
-    if(details_size)
-    {
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_CHUNK_DETAILS,details,details_size);        
-    }
-    if(total_items == 0)
-    {
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_CHUNK_SIZE,(unsigned char*)&chunk_size,sizeof(chunk_size));
-        if(chunk_size)
-        {
-            m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_CHUNK_DATA,chunk,chunk_size);                
-        }
-    }
-    else
-    {
-        m_TmpScript->SetSpecialParamValue(MC_ENT_SPRM_ITEM_COUNT,(unsigned char*)&total_items,sizeof(total_items));        
-    }
-
-    chunk_def.m_Size=chunk_size;
-    chunk_def.m_HeaderSize=m_TmpScript->m_Size-chunk_size;
-    chunk_def.m_Flags=flags;
-    
-    ptr=m_TmpScript->GetData(0,&bytes);
-    
-    m_ChunkData->SetElement(m_ChunkData->m_NumElements-1);
-    m_ChunkData->AddElement();
-    err=m_ChunkData->SetData(ptr,bytes);
-    if(err)
-    {
-        return err;
-    }
-        
-    if(add_null_row)
-    {
-        chunk_def.m_SubscriptionID=0;
-        chunk_def.m_Pos=0;
-        chunk_def.m_ItemCount=1;
-        chunk_def.m_TmpOnDiskItems=0;
-/*        
-        chunk_def.m_PrevSubscriptionID=0;
- */ 
-        chunk_def.m_NextSubscriptionID=subscription->m_SubscriptionID;
-        m_MemPool->Add(&chunk_def,(char*)&chunk_def+m_ValueOffset);        
-    }
-
-    chunk_def.m_SubscriptionID=subscription->m_SubscriptionID;
-    chunk_def.m_Pos=pos;
-    chunk_def.m_ItemCount=total_items+1;
-    chunk_def.m_TmpOnDiskItems=on_disk_items;
-    chunk_def.m_NextSubscriptionID=0;
-    if(txid)
-    {
-        chunk_def.m_TxIDStart=(uint32_t)mc_GetLE((void*)txid,4);
-    }
-    
-/*    
-    if(add_null_row)
-    {
-        chunk_def.m_PrevSubscriptionID=0;
-        chunk_def.m_NextSubscriptionID=0;
-    }
-    else
-    {
-        if(add_entity_row)
-        {
-            chunk_def.m_PrevSubscriptionID=entity_chunk_def.m_SubscriptionID;
-            chunk_def.m_NextSubscriptionID=0;
-        }
-        else
-        {
-            chunk_def.m_PrevSubscriptionID=entity_chunk_def.m_PrevSubscriptionID;
-            chunk_def.m_NextSubscriptionID=entity_chunk_def.m_NextSubscriptionID;            
-        }
-    }
-*/
-    
-    m_MemPool->Add(&chunk_def,(char*)&chunk_def+m_ValueOffset);
-    
-    if(mempool_entity_row >= 0)
-    {
-        ((mc_ChunkDBRow *)m_MemPool->GetRow(mempool_entity_row))->m_ItemCount += 1;        
-    }
-    
-    
-    if(mempool_last_null_row >= 0)
-    {
-        if(add_entity_row)
-        {
-            ((mc_ChunkDBRow *)m_MemPool->GetRow(mempool_last_null_row))->m_NextSubscriptionID = subscription->m_SubscriptionID;                    
-        }
-    }
-
-    
-    sprintf_hex(enthex,entity->m_EntityID,MC_TDB_ENTITY_ID_SIZE);
-    sprintf_hex(chunk_hex,hash,MC_CDB_CHUNK_HASH_SIZE);    
-    sprintf(msg,"New Chunk %s, size %d, flags %08X, entity (%08X, %s)",chunk_hex,chunk_size,flags,entity->m_EntityType,enthex);
-    LogString(msg);
- 
-/*        
-    if(entity->m_EntityType == MC_TET_AUTHOR)
-    {
-        if((m_DBStat.m_InitMode & MC_WMD_NO_CHUNK_FLUSH) == 0)
-        {
-            FlushLastChunk();
-//            CommitInternal(-2);
-        }
-    }
- */ 
-    
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkDB::AddChunk(                                                           
-                 const unsigned char *hash,                                     
-                 const mc_TxEntity *entity,                                     
-                 const unsigned char *txid,
-                 const int vout,
-                 const unsigned char *chunk,                                    
-                 const unsigned char *details,                                  
-                 const uint32_t chunk_size,                                     
-                 const uint32_t details_size,                                   
-                 const uint32_t flags)
-{
-    int err;
-    
-    Lock();
-    err=AddChunkInternal(hash,entity,txid,vout,chunk,details,chunk_size,details_size,flags);
-    UnLock();
-    
-    return err;
-}
-
-void mc_ChunkDB::SetFileName(char *FileName,
-                     mc_SubscriptionDBRow *subscription,
-                     uint32_t fileid)
-{
-    sprintf(FileName,"%s/chunks%06u.dat",subscription->m_DirName,fileid);    
-}
-
-
-
-
-unsigned char *mc_ChunkDB::GetChunkInternal(mc_ChunkDBRow *chunk_def,
-                                    int32_t offset,
-                                    int32_t len,
-                                    size_t *bytes)
-{
-    unsigned char *ptr;
-    size_t bytes_to_read;
-    int subscription_id;
-    mc_SubscriptionDBRow *subscription;
-    char FileName[MC_DCT_DB_MAX_PATH];    
-    int FileHan;
-    uint32_t read_from;
-    mc_ChunkDBRow chunk_def_zero;
-    
-    ptr=NULL;
-    if((offset >= 0) && (chunk_def->m_Pos > 0) )
-    {
-        subscription_id=chunk_def->m_SubscriptionID;
-        if(subscription_id == 0)
-        {
-            subscription_id=chunk_def->m_NextSubscriptionID;
-        }
-        subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(subscription_id);
-        
-        if(GetChunkDefInternal(&chunk_def_zero,chunk_def->m_Hash,&(subscription->m_Entity),NULL,0,NULL) == MC_ERR_NOERROR)
-        {
-            return GetChunkInternal(&chunk_def_zero,offset,len,bytes);
-        }
-        return NULL;
-    }
-    
-    FileHan=0;
-    if(chunk_def->m_InternalFileID < 0)
-    {
-        ptr=(unsigned char *)m_ChunkData->GetData(chunk_def->m_InternalFileOffset,&bytes_to_read);
-        read_from=0;
-        if(offset >= 0)
-        {
-            read_from+=chunk_def->m_HeaderSize+offset;
-            if(offset >= (int)chunk_def->m_Size)
-            {
-                return NULL;
-            }
-            bytes_to_read=chunk_def->m_Size-offset;
-        }
-        if(bytes)
-        {
-            *bytes=bytes_to_read;
-        }
-        return ptr+read_from;
-    }
-    else
-    {
-        subscription_id=chunk_def->m_SubscriptionID;
-        if(subscription_id == 0)
-        {
-            subscription_id=chunk_def->m_NextSubscriptionID;
-        }
-        subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(subscription_id);
-        SetFileName(FileName,subscription,chunk_def->m_InternalFileID);
-     
-        FileHan=open(FileName,_O_BINARY | O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
-        if(FileHan<=0)
-        {
-            return NULL;
-        }
-    
-        read_from=chunk_def->m_InternalFileOffset;
-        bytes_to_read=chunk_def->m_HeaderSize;
-        if(offset >= 0)
-        {
-            read_from+=chunk_def->m_HeaderSize+offset;
-            bytes_to_read=chunk_def->m_Size;
-            if(len>0)
-            {
-                bytes_to_read=len;
-            }
-        }
-        
-        if(lseek64(FileHan,read_from,SEEK_SET) != (int)read_from)
-        {
-            goto exitlbl;
-        }
-        
-        m_TmpScript->Clear();
-        if(m_TmpScript->Resize(bytes_to_read,1))
-        {
-            goto exitlbl;            
-        }
-    
-        if(read(FileHan,m_TmpScript->m_lpData,bytes_to_read) != (int)bytes_to_read)
-        {
-            goto exitlbl;
-        }
-        
-        ptr=m_TmpScript->m_lpData;        
-        if(bytes)
-        {
-            *bytes=bytes_to_read;
-        }
-}
-
-exitlbl:
-        
-    if(FileHan)
-    {        
-        close(FileHan);
-    }
-        
-    return ptr;
-}
-
-unsigned char *mc_ChunkDB::GetChunk(mc_ChunkDBRow *chunk_def,
-                                    int32_t offset,
-                                    int32_t len,
-                                    size_t *bytes)
-{
-    unsigned char *ptr;
-    
-    Lock();
-    ptr=GetChunkInternal(chunk_def,offset,len,bytes);
-    UnLock();
-    
-    return ptr;
-}
-
-
-int mc_ChunkDB::AddToFile(const void* chunk,                  
-                          uint32_t size,
-                          mc_SubscriptionDBRow *subscription,
-                          uint32_t fileid,
-                          uint32_t offset,
-                          uint32_t flush_mode)
-{
-    char FileName[MC_DCT_DB_MAX_PATH];         
-    int FileHan,err;
-    uint32_t tail_size,file_size,expected_end,new_file_size;
-    unsigned char tail[3];
-    
-    tail[0]=0x00;
-    tail[1]=MC_ENT_SPRM_FILE_END;
-    tail[2]=0x00;
-    
-    SetFileName(FileName,subscription,fileid);
-    err=MC_ERR_NOERROR;
-    FileHan=open(FileName,_O_BINARY | O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
-    
-    if(FileHan<=0)
-    {
-        return MC_ERR_INTERNAL_ERROR;
-    }
-    
-    expected_end=offset+size+3;
-    tail_size=0;
-    if( (offset == 0) || ( (expected_end % MC_CDB_FILE_PAGE_SIZE) != (offset % MC_CDB_FILE_PAGE_SIZE) ) )
-    {
-        file_size=lseek64(FileHan,0,SEEK_END);
-        new_file_size=((expected_end-1) / MC_CDB_FILE_PAGE_SIZE + 1) * MC_CDB_FILE_PAGE_SIZE;
-        if(new_file_size > file_size)
-        {
-            if(new_file_size > expected_end)
-            {
-                tail_size=new_file_size-expected_end;
-            }
-        }
-    }
-    
-    if(lseek64(FileHan,offset,SEEK_SET) != offset)
-    {
-        err=MC_ERR_INTERNAL_ERROR;
-        goto exitlbl;
-    }
-    
-    if(write(FileHan,chunk,size) != size)
-    {
-        err=MC_ERR_INTERNAL_ERROR;
-        return MC_ERR_INTERNAL_ERROR;
-    }
-
-    if(write(FileHan,tail,3) != 3)
-    {
-        err=MC_ERR_INTERNAL_ERROR;
-        return MC_ERR_INTERNAL_ERROR;
-    }
-    
-    if(tail_size)
-    {
-        unsigned char empty_buf[65536];
-        uint32_t empty_buf_size=65536;
-        memset(empty_buf,0,empty_buf_size);
-        while(tail_size)
-        {
-            if(empty_buf_size>tail_size)
-            {
-                empty_buf_size=tail_size;
-            }
-            if(write(FileHan,empty_buf,empty_buf_size) != empty_buf_size)
-            {
-                err=MC_ERR_INTERNAL_ERROR;
-                return MC_ERR_INTERNAL_ERROR;
-            }
-            tail_size-=empty_buf_size;
-        }        
-    }
-    
-exitlbl:
-
-    if(err == MC_ERR_NOERROR)
-    {
-        if(flush_mode)
-        {
-            __US_FlushFileWithMode(FileHan,flush_mode & MC_CDB_FLUSH_MODE_DATASYNC);            
-        }
-    }
-    close(FileHan);
-    return err;
-}
-
-int mc_ChunkDB::FlushDataFile(mc_SubscriptionDBRow *subscription,uint32_t fileid,uint32_t flush_mode)
-{
-    char FileName[MC_DCT_DB_MAX_PATH];         
-    int FileHan;
-    SetFileName(FileName,subscription,fileid);
-    
-    FileHan=open(FileName,_O_BINARY | O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
-    
-    if(FileHan<=0)
-    {
-        return MC_ERR_INTERNAL_ERROR;
-    }
-    __US_FlushFileWithMode(FileHan,flush_mode);
-    close(FileHan);
-    return MC_ERR_NOERROR;
-}
-
-int mc_ChunkDB::FlushSourceChunks(uint32_t flush_mode)
-{
-    mc_ChunkDBRow *chunk_def;
-    mc_SubscriptionDBRow *subscription;
-    int err,row,first_row,last_row;
-    int full_commit_required;
-    uint32_t size;
-    char msg[256];
-        
-    if(flush_mode & MC_CDB_FLUSH_MODE_COMMIT)
-    {
-        return Commit(-2,flush_mode);
-    }
-    
-    if( (flush_mode & MC_CDB_FLUSH_MODE_FILE) == 0)
-    {
-        return MC_ERR_NOERROR;
-    }
-
-    full_commit_required=0;
-    
-    Lock();
-    
-    err=MC_ERR_NOERROR;
-
-    row=m_MemPool->GetCount()-1;
-    first_row=m_MemPool->GetCount();
-    last_row=first_row;
-    
-    while(row >= 0)
-    {
-        chunk_def=(mc_ChunkDBRow *)m_MemPool->GetRow(row);
-        if(chunk_def->m_SubscriptionID == 1)
-        {
-            if( (chunk_def->m_StorageFlags & MC_CFL_STORAGE_FLUSHED) == 0)
-            {
-                first_row=row;
-                if(last_row == m_MemPool->GetCount())
-                {
-                    last_row=row;
-                }
-            }
-            else
-            {
-                row=0;
-            }
-        }
-        row--;
-    }
-        
-    subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(1);
-    
-    for(row=first_row;row<m_MemPool->GetCount();row++)
-    {
-        chunk_def=(mc_ChunkDBRow *)m_MemPool->GetRow(row);
-        if(chunk_def->m_SubscriptionID == 1)
-        {
-            size=chunk_def->m_Size+chunk_def->m_HeaderSize;
-            if(subscription->m_LastFileSize+size > MC_CDB_MAX_FILE_SIZE)                          // New file is needed
-            {
-                FlushDataFile(subscription,subscription->m_LastFileID,0);
-                subscription->m_LastFileID+=1;
-                subscription->m_LastFileSize=0;
-                full_commit_required=1;
-            }            
-
-            err=AddToFile(GetChunkInternal(chunk_def,-1,-1,NULL),size,
-                          subscription,subscription->m_LastFileID,subscription->m_LastFileSize,(row==last_row) ? flush_mode : 0);
-            if(err)
-            {
-                sprintf(msg,"Couldn't store key in file, error:  %d",err);
-                LogString(msg);
-                goto exitlbl;
-            }
-
-            chunk_def->m_InternalFileID=subscription->m_LastFileID;
-            chunk_def->m_InternalFileOffset=subscription->m_LastFileSize;
-            chunk_def->m_Pos+=chunk_def->m_TmpOnDiskItems;
-            chunk_def->m_StorageFlags |= MC_CFL_STORAGE_FLUSHED;
-
-            subscription->m_LastFileSize+=size;    
-            subscription->m_Count+=1;
-            subscription->m_FullSize+=chunk_def->m_Size;
-
-            m_DBStat.m_Count+=1;
-            m_DBStat.m_FullSize+=chunk_def->m_Size;            
-        }        
-    }
-    
-exitlbl:    
-    UnLock();
-
-    if(full_commit_required)
-    {
-        return Commit(-2,flush_mode);        
-    }
-
-    return err; 
-}
-
-int mc_ChunkDB::CommitInternal(int block,uint32_t flush_mode)
-{
-    int r,s;
-    int err;
-//    int last_file_id, last_file_offset;
-    uint32_t size;
-    int value_len;
-    unsigned char *ptr;
-    char msg[256];
-
-    mc_SubscriptionDBRow *subscription;
-    mc_ChunkDBRow *chunk_def;
-    mc_ChunkDBRow entity_chunk_def;
-    
-    err=MC_ERR_NOERROR;
-    
-    if(m_MemPool->GetCount() == 0)
-    {
-        goto exitlbl;
-    }
-    Dump("Before Commit");
-        
-//    last_file_id=-1;
-//    last_file_offset=0;
-    
-    for(r=0;r<m_MemPool->GetCount();r++)
-    {
-        chunk_def=(mc_ChunkDBRow *)m_MemPool->GetRow(r);
-        
-        if(chunk_def->m_SubscriptionID)
-        {
-            s=chunk_def->m_SubscriptionID;
-
-            subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(s);
-            subscription->m_TmpFlags |= MC_CDB_TMP_FLAG_SHOULD_COMMIT;
-
-            if( (chunk_def->m_StorageFlags & MC_CFL_STORAGE_FLUSHED) == 0)
-            {
-                size=chunk_def->m_Size+chunk_def->m_HeaderSize;
-                if(subscription->m_LastFileSize+size > MC_CDB_MAX_FILE_SIZE)                          // New file is needed
-                {
-                    FlushDataFile(subscription,subscription->m_LastFileID,flush_mode);
-                    subscription->m_LastFileID+=1;
-                    subscription->m_LastFileSize=0;
-                }            
-
-                err=AddToFile(GetChunkInternal(chunk_def,-1,-1,NULL),size,
-                              subscription,subscription->m_LastFileID,subscription->m_LastFileSize,0);
-                if(err)
-                {
-                    sprintf(msg,"Couldn't store key in file, error:  %d",err);
-                    LogString(msg);
-                    return err;
-                }
-
-                chunk_def->m_InternalFileID=subscription->m_LastFileID;
-                chunk_def->m_InternalFileOffset=subscription->m_LastFileSize;
-                chunk_def->m_Pos+=chunk_def->m_TmpOnDiskItems;
-
-                subscription->m_LastFileSize+=size;    
-                subscription->m_Count+=1;
-                subscription->m_FullSize+=chunk_def->m_Size;
-
-                m_DBStat.m_Count+=1;
-                m_DBStat.m_FullSize+=chunk_def->m_Size;
-            }
-
-            if(chunk_def->m_TmpOnDiskItems)
-            {
-                if(chunk_def->m_SubscriptionID)
-                {
-                entity_chunk_def.Zero();
-                memcpy(&entity_chunk_def,chunk_def,sizeof(mc_ChunkDBRow));
-                entity_chunk_def.m_Pos=0;
-                entity_chunk_def.m_TmpOnDiskItems=0;
-                entity_chunk_def.SwapPosBytes();
-                ptr=(unsigned char*)m_DB->Read((char*)&entity_chunk_def+m_KeyOffset,m_KeySize,&value_len,0,&err);
-                entity_chunk_def.SwapPosBytes();
-                if(err)
-                {
-                    goto exitlbl;
-                }
-                if(ptr)
-                {
-                    memcpy((char*)&entity_chunk_def+m_ValueOffset,ptr,m_ValueSize);
-                    entity_chunk_def.m_ItemCount=chunk_def->m_ItemCount;
-                    entity_chunk_def.SwapPosBytes();
-                    err=m_DB->Write((char*)&entity_chunk_def+m_KeyOffset,m_KeySize,(char*)&entity_chunk_def+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-                    entity_chunk_def.SwapPosBytes();
-                    if(err)
-                    {
-                        goto exitlbl;
-                    }                                                            
-                }
-                }
-            }
-
-            chunk_def->m_TmpOnDiskItems=0;
-            chunk_def->SwapPosBytes();
-            err=m_DB->Write((char*)chunk_def+m_KeyOffset,m_KeySize,(char*)chunk_def+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            chunk_def->SwapPosBytes();
-            if(err)
-            {
-                goto exitlbl;
-            }                                            
-        }
-    }
-    
-    for(s=0;s<m_Subscriptions->GetCount();s++)
-    {
-        subscription=(mc_SubscriptionDBRow *)m_Subscriptions->GetRow(s);
-        if(subscription->m_TmpFlags & MC_CDB_TMP_FLAG_SHOULD_COMMIT)            
-        {
-            subscription->m_TmpFlags=0;
-
-            FlushDataFile(subscription,subscription->m_LastFileID,flush_mode);
-
-            err=m_DB->Write((char*)subscription+m_KeyOffset,m_KeySize,(char*)subscription+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-            if(err)
-            {
-                goto exitlbl;
-            }                                            
-
-        }
-    }
-
-    err=m_DB->Write((char*)&m_DBStat+m_KeyOffset,m_KeySize,(char*)&m_DBStat+m_ValueOffset,m_ValueSize,MC_OPT_DB_DATABASE_TRANSACTIONAL);
-    if(err)
-    {
-        goto exitlbl;
-    }                                            
-        
-    err=m_DB->Commit(MC_OPT_DB_DATABASE_TRANSACTIONAL | MC_OPT_DB_DATABASE_SYNC_ON_COMMIT);
-    if(err)
-    {
-        goto exitlbl;
-    }
-    
-    
-exitlbl:
-    if(err)
-    {
-        sprintf(msg,"Could not commit new Block %d, Chunks: %d, Error: %d",block,m_MemPool->GetCount(),err);
-        LogString(msg);   
-    }
-    else
-    {
-        if(block >= -1)
-        {
-            sprintf(msg,"NewBlock %d, Chunks: %d,",block,m_MemPool->GetCount());
-            LogString(msg);   
-        }
-        m_MemPool->Clear();
-        m_ChunkData->Clear();
-    }
-    Dump("After Commit");
-        
-    return MC_ERR_NOERROR;    
-}
-
-int mc_ChunkDB::Commit(int block)
-{
-    int err;
-    
-    Lock();
-    err=CommitInternal(block,0);
-    UnLock();
-    
-    return err;
-}
-
-int mc_ChunkDB::Commit(int block,uint32_t flush_mode)
-{
-    int err;
-    
-    Lock();
-    err=CommitInternal(block,flush_mode);
-    UnLock();
-    
-    return err;
-}
-
diff --git a/src/wallet/chunkdb.h b/src/wallet/chunkdb.h
deleted file mode 100644
index 2d95f97..0000000
--- a/src/wallet/chunkdb.h
+++ /dev/null
@@ -1,254 +0,0 @@
-// Copyright (c) 2014-2017 Coin Sciences Ltd
-// MultiChain code distributed under the GPLv3 license, see COPYING file.
-
-#ifndef MULTICHAIN_CHUNKDB_H
-#define MULTICHAIN_CHUNKDB_H
-
-#include "utils/declare.h"
-#include "wallet/wallettxdb.h"
-
-#define MC_CDB_CHUNK_HASH_SIZE       32
-#define MC_CDB_ROW_SIZE              80
-#define MC_CDB_HEADER_SIZE           40
-
-
-#define MC_CDB_TYPE_DB_STAT           0x00000000 
-#define MC_CDB_TYPE_SUBSCRIPTION      0x01000000 
-#define MC_CDB_TYPE_FILE              0x02000000 
-
-#define MC_CDB_MAX_FILE_SIZE             0x08000000                             // Maximal data file size, 1GB
-#define MC_CDB_MAX_CHUNK_DATA_POOL_SIZE  0x8000000                              // Maximal size of chunk pool before commit, 128MB
-#define MC_CDB_MAX_FILE_READ_BUFFER_SIZE 0x0100000                              // Maximal size of chunk pool before commit, 1MB
-#define MC_CDB_MAX_CHUNK_EXTRA_SIZE      1024 
-#define MC_CDB_MAX_MEMPOOL_SIZE          1024 
-
-#define MC_CDB_FLUSH_MODE_NONE        0x00000000
-#define MC_CDB_FLUSH_MODE_FILE        0x00000001
-#define MC_CDB_FLUSH_MODE_COMMIT      0x00000002
-#define MC_CDB_FLUSH_MODE_DATASYNC    0x00000100
-
-#define MC_CFL_STORAGE_FLUSHED        0x01000000 
-
-
-/** File DB Row*/
-
-typedef struct mc_SubscriptionFileDBRow
-{
-    uint32_t m_SubscriptionID;                                                  // Should be Zero
-    uint32_t m_RecordType;                                                      // Should be MC_CDB_TYPE_FILE    
-    uint32_t m_FileID;                                                          // File ID
-    mc_TxEntity m_Entity;                                                       // Parent Entity
-    uint32_t m_Size;                                                            // File size
-    uint32_t m_StorageFlags;                                                    // Internal flags
-    uint32_t m_Count;                                                           // Total count
-    uint32_t m_FirstTimestamp;                                                  // Timestamp of the first record
-    uint32_t m_FirstOffset;                                                     // First data offset
-    uint32_t m_LastTimeStamp;                                                   // Timestamp of the last record
-    uint32_t m_LastOffset;                                                      // Last data file size
-    void Zero();
-} mc_SubscriptionFileDBRow;
-
-
-/** Entity DB Row*/
-
-typedef struct mc_SubscriptionDBRow
-{
-    uint32_t m_Zero;                                                            // Should be Zero
-    uint32_t m_RecordType;                                                      // Should be MC_CDB_TYPE_SUBSCRIPTION    
-    uint32_t m_Zero1;                                                           // Should be Zero
-    uint32_t m_Zero2;                                                           // Should be Zero
-    mc_TxEntity m_Entity;                                                       // Parent Entity
-    uint32_t m_Flags;                                                           // Flags passed from higher level
-    int32_t  m_SubscriptionID;                                                  // Subscription ID
-    uint32_t m_Count;                                                           // Total chunk count
-    uint32_t m_TmpFlags;           
-    int32_t  m_FirstFileID;                                                     // First data file ID/Reserved
-    uint32_t m_FirstFileOffset;                                                 // First data file offset/Reserved
-    int32_t  m_LastFileID;                                                      // Last data file ID
-    uint32_t m_LastFileSize;                                                    // Last data file size
-    uint64_t m_FullSize;                                                        // Total tx size
-
-    char m_DirName[MC_DCT_DB_MAX_PATH];                                         // Full file name
-    
-    void Zero();
-} mc_SubscriptionDBRow;
-
-typedef struct mc_ChunkDBStat
-{
-    uint32_t m_Zero;                                                            // Should be Zero
-    uint32_t m_RecordType;                                                      // Should be MC_CDB_TYPE_DB_STAT    
-    uint32_t m_Zero1;                                                           // Should be Zero
-    uint32_t m_Zero2;                                                           // Should be Zero
-    mc_TxEntity m_ZeroEntity;                                                   // Zero Entity
-    uint32_t m_InitMode;
-    int32_t  m_LastSubscription; 
-    uint32_t m_Count;                                                           // Total tx count
-    uint32_t m_ChunkDBVersion;
-    uint32_t m_Reserved1; 
-    uint32_t m_Reserved2; 
-    uint32_t m_Reserved3; 
-    uint32_t m_Reserved4; 
-    uint64_t m_FullSize;                                                        // Total tx size
-    void Zero();
-} mc_ChunkDBStat;
-
-
-/** Chunk DB Row **/
-
-typedef struct mc_ChunkDBRow
-{
-    unsigned char m_Hash[MC_CDB_CHUNK_HASH_SIZE];                               // Chunk hash
-    int32_t  m_SubscriptionID;                                                  // Subscription ID
-    uint32_t m_Pos;                                                             // Position of this record for subscription/hash
-    uint32_t m_Size;                                                            // Chunk Size
-    uint32_t m_Flags;                                                           // Flags passed from higher level
-    uint32_t m_HeaderSize;                                                      // Header size
-    uint32_t m_StorageFlags;                                                    // Internal flags
-    int32_t  m_ItemCount;                                                       // Number of times this chunk appears in subscription (if m_Pos=0)
-    int32_t  m_TmpOnDiskItems;
-    int32_t  m_InternalFileID;                                                  // Data file ID
-    uint32_t m_InternalFileOffset;                                              // Offset in the data file
-    uint32_t  m_TxIDStart;                                                       // First bytes of TxID
-    int32_t  m_NextSubscriptionID;                                              // Next Subscription ID for this hash
-    
-    void Zero();
-    void SwapPosBytes();
-} mc_ChunkDBRow;
-
-
-/** Chunk DB **/
-
-typedef struct mc_ChunkDB
-{    
-    mc_Database *m_DB;                                                          // Database object
-    uint32_t m_KeyOffset;                                                       
-    uint32_t m_KeySize;                                                         
-    uint32_t m_ValueOffset;                                                     
-    uint32_t m_ValueSize;                                                       
-    uint32_t m_TotalSize;                                                       
-    
-    mc_ChunkDBStat m_DBStat;                                                 
-    
-    char m_Name[MC_PRM_NETWORK_NAME_MAX_SIZE+1];                                // Chain name
-    char m_DirName[MC_DCT_DB_MAX_PATH];                                         // Chunk directory name
-    char m_DBName[MC_DCT_DB_MAX_PATH];                                          // Full database name
-    char m_LogFileName[MC_DCT_DB_MAX_PATH];                                     // Full log file name    
-    
-    mc_Buffer *m_Subscriptions;                                                 // List of import entities (mc_TxEntityStat)
-    mc_Buffer *m_MemPool;
-    mc_Script *m_ChunkData;
-    mc_Script *m_TmpScript;
-
-    void *m_Semaphore;                                                          // mc_TxDB object semaphore
-    uint64_t m_LockedBy;                                                        // ID of the thread locking it
-    
-    mc_ChunkDB()
-    {
-        Zero();
-    }
-    
-    ~mc_ChunkDB()
-    {
-        Destroy();
-    }
-    
-    int Initialize(                                                             // Initialization
-              const char *name,                                                 // Chain name
-              uint32_t mode);                                                   // Unused
-    
-    int AddSubscription(mc_SubscriptionDBRow *subscription);                          
-    int AddEntity(mc_TxEntity *entity,uint32_t flags);                          // Adds entity
-    int AddEntityInternal(mc_TxEntity *entity,uint32_t flags);                  
-    int RemoveEntity(mc_TxEntity *entity);                          
-    int RemoveEntityInternal(mc_TxEntity *entity);                          
-    int SourceChunksRecovery();                          
-    
-    mc_SubscriptionDBRow *FindSubscription(const mc_TxEntity *entity);                // Finds subscription
-    int FindSubscription(const mc_TxEntity *entity,mc_SubscriptionDBRow *subscription);   // Finds subscription
-    
-    int AddChunk(                                                               // Adds chunk to mempool
-                 const unsigned char *hash,                                     // Chunk hash (before chopping)    
-                 const mc_TxEntity *entity,                                     // Parent entity
-                 const unsigned char *txid,
-                 const int vout,
-                 const unsigned char *chunk,                                    // Chunk data
-                 const unsigned char *details,                                  // Chunk metadata
-                 const uint32_t chunk_size,                                     // Chunk size
-                 const uint32_t details_size,                                   // Chunk metadata size
-                 const uint32_t flags);                                         // Flags
-
-    int AddChunkInternal(                                                               // Adds chunk to mempool
-                 const unsigned char *hash,                                     // Chunk hash (before chopping)    
-                 const mc_TxEntity *entity,                                     // Parent entity
-                 const unsigned char *txid,
-                 const int vout,
-                 const unsigned char *chunk,                                    // Chunk data
-                 const unsigned char *details,                                  // Chunk metadata
-                 const uint32_t chunk_size,                                     // Chunk size
-                 const uint32_t details_size,                                   // Chunk metadata size
-                 const uint32_t flags);                                         // Flags
-
-    int GetChunkDefInternal(
-                    mc_ChunkDBRow *chunk_def,
-                    const unsigned char *hash,                                  // Chunk hash (before chopping)    
-                    const void *entity,
-                    const unsigned char *txid,
-                    const int vout,
-                    int *mempool_entity_row);
-            
-    
-    int GetChunkDef(
-                    mc_ChunkDBRow *chunk_def,
-                    const unsigned char *hash,                                  // Chunk hash (before chopping)    
-                    const void *entity,
-                    const unsigned char *txid,
-                    const int vout);
-    
-    unsigned char *GetChunkInternal(mc_ChunkDBRow *chunk_def,
-                                    int32_t offset,
-                                    int32_t len,
-                                    size_t *bytes);
-
-    unsigned char *GetChunk(mc_ChunkDBRow *chunk_def,
-                                    int32_t offset,
-                                    int32_t len,
-                                    size_t *bytes);
-    
-    void SetFileName(char *FileName,
-                     mc_SubscriptionDBRow *subscription,
-                     uint32_t fileid);
-    
-    int FlushDataFile(mc_SubscriptionDBRow *subscription,
-                                  uint32_t fileid,
-                                  uint32_t flush_mode);
-    
-    
-    int AddToFile(const void *chunk,                  
-                          uint32_t size,
-                          mc_SubscriptionDBRow *subscription,
-                          uint32_t fileid,
-                          uint32_t offset,
-                          uint32_t flush_mode);
-    
-    int Commit(int block);                                                               // Commit mempool to disk
-
-    int Commit(int block,uint32_t flush_mode);                                                               // Commit mempool to disk
-    int CommitInternal(int block,uint32_t flush_mode); 
-    
-    int FlushSourceChunks(uint32_t flush_mode);
-    
-    void Zero();    
-    int Destroy();
-    void Dump(const char *message);
-    void Dump(const char *message, int force);
-    
-    void LogString(const char *message);
-    
-    int Lock();
-    int Lock(int write_mode, int allow_secondary);
-    void UnLock();
-    
-} mc_ChunkDB;
-
-#endif /* MULTICHAIN_CHUNKDB_H */
-
diff --git a/src/wallet/wallet.cpp b/src/wallet/wallet.cpp
index d344607..8a733b2 100644
--- a/src/wallet/wallet.cpp
+++ b/src/wallet/wallet.cpp
@@ -1419,10 +1419,22 @@ mc_TxImport *StartImport(CWallet *lpWallet,bool fOnlyUnsynced, bool fOnlySubscri
         for(unsigned int i=0;i<vStreamsToImport.size();i++)
         {     
             bool take_it=false;
-            if(mc_gState->m_Assets->FindEntityByShortTxID(&stream_entity,vStreamsToImport[i].m_EntityID))
+            if( ( (vStreamsToImport[i].m_EntityType & MC_TET_TYPE_MASK) == MC_TET_ASSET ) &&
+                ( mc_gState->m_Features->ShortTxIDInTx() == 0) )    
             {
-                take_it=true;
-            }                
+                if(mc_gState->m_Assets->FindEntityByRef(&stream_entity,vStreamsToImport[i].m_EntityID))
+                {
+                    take_it=true;
+                }   
+            }
+            else
+            {
+                if(mc_gState->m_Assets->FindEntityByShortTxID(&stream_entity,vStreamsToImport[i].m_EntityID))
+                {
+                    take_it=true;
+                }                
+            }
+//            if(mc_gState->m_Assets->FindEntityByShortTxID(&stream_entity,vStreamsToImport[i].m_EntityID))
             if(take_it)
             {
                 ptr=(unsigned char *)stream_entity.GetRef();
@@ -3140,12 +3152,6 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, stri
 
         // Broadcast
 
-        if(mc_gState->m_WalletMode & MC_WMD_ADDRESS_TXS)
-        {
-//            pwalletTxsMain->m_ChunkDB->FlushSourceChunks(GetArg("-chunkflushmode",MC_CDB_FLUSH_MODE_COMMIT));
-            pwalletTxsMain->m_ChunkDB->FlushSourceChunks(GetArg("-flushsourcechunks",true) ? (MC_CDB_FLUSH_MODE_FILE | MC_CDB_FLUSH_MODE_DATASYNC) : MC_CDB_FLUSH_MODE_NONE);
-        }
-        
         if (!wtxNew.AcceptToMemoryPoolReturnReason(false,true,reject_reason))   // MCHN
         {
             // This must not fail. The transaction has already been signed and recorded.
@@ -3160,7 +3166,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, stri
                 SyncWithWallets(wtxNew, NULL);            
             }
         }
-    
+
         for (unsigned int i = 0; i < wtxNew.vin.size(); i++) 
         {
             COutPoint outp=wtxNew.vin[i].prevout;
diff --git a/src/wallet/wallet.h b/src/wallet/wallet.h
index e516220..61b0f41 100644
--- a/src/wallet/wallet.h
+++ b/src/wallet/wallet.h
@@ -69,7 +69,6 @@ struct mc_WalletTxs;
 #define MC_TFL_ALL_INPUTS_FROM_ME       0x00020000
 #define MC_TFL_IS_CHANGE                0x00040000
 #define MC_TFL_IS_SPENDABLE             0x00080000
-//#define MC_TFL_IS_EXTENSION             0x01000000                            // defined in walletdb.h
 #define MC_TFL_IS_MINE_FOR_THIS_SEND    0x10000000
 #define MC_TFL_IMPOSSIBLE               0x80000000
 
@@ -179,7 +178,6 @@ private:
     int nMaxAssetsPerGroup;
     int nOptimalGroupCount;
     int nMode;
-    int nSingleAssetGroupCount;
     void Clear();
     void Destroy();
     
@@ -188,7 +186,6 @@ private:
     int *lpTmpGroupBuffer;
     
     CAssetGroup *FindAndShiftBestGroup(int assets);
-    CAssetGroup *AddSingleAssetGroup(unsigned char *assetRef);
     
 public:
     
diff --git a/src/wallet/walletcoins.cpp b/src/wallet/walletcoins.cpp
index bdfb0ec..29189a2 100644
--- a/src/wallet/walletcoins.cpp
+++ b/src/wallet/walletcoins.cpp
@@ -11,11 +11,8 @@
 #include "script/sign.h"
 #include "utils/utilmoneystr.h"
 #include "rpc/rpcprotocol.h"
-#include "custom/custom.h"
 
 extern mc_WalletTxs* pwalletTxsMain;
-void MultiChainTransaction_SetTmpOutputScript(const CScript& script1);
-int64_t MultiChainTransaction_OffchainFee(int64_t total_offchain_size);
 
 using namespace std;
 
@@ -28,7 +25,6 @@ void CAssetGroupTree::Clear()
     nMaxAssetsPerGroup=0;
     nOptimalGroupCount=0;
     nMode=0;
-    nSingleAssetGroupCount=0;
     lpAssets=NULL;
     lpAssetGroups=NULL;
     lpTmpGroupBuffer=NULL;
@@ -56,12 +52,10 @@ void CAssetGroupTree::Dump()
     CAssetGroup *thisGroup;
     int *aptr;
     unsigned char *assetrefbin;
-    int i,j,s;
+    int i,j;
     
-    if(debug_print)printf("Asset Grouping. Assets: %d. Group Size: %d. Group Count: %d. Single-Asset Groups: %d.\n",
-            lpAssets->GetCount(),nAssetsPerGroup,lpAssetGroups->GetCount()-1,nSingleAssetGroupCount);
-    if(fDebug)LogPrint("mchn","mchn: Asset Grouping. Assets: %d. Group Size: %d. Group Count: %d. Single-Asset Groups: %d.\n",
-            lpAssets->GetCount(),nAssetsPerGroup,lpAssetGroups->GetCount()-1,nSingleAssetGroupCount);
+    if(debug_print)printf("Asset Grouping. Group Size: %d. Group Count: %d\n",nAssetsPerGroup,lpAssetGroups->GetCount()-1);
+    if(fDebug)LogPrint("mchn","mchn: Asset Grouping. Group Size: %d. Group Count: %d\n",nAssetsPerGroup,lpAssetGroups->GetCount()-1);
     for(i=1;i<lpAssetGroups->GetCount();i++)                                    
     {    
         thisGroup=(CAssetGroup*)lpAssetGroups->GetRow(i);
@@ -69,12 +63,7 @@ void CAssetGroupTree::Dump()
         {
             printf("Group: %4d. Asset Count: %d\n",i,thisGroup->nSize);
             aptr=(int*)(lpAssetGroups->GetRow(i)+sizeof(CAssetGroup));
-            s=thisGroup->nSize;
-            if(s<0)
-            {
-                s=1;
-            }
-            for(j=0;j<s;j++)
+            for(j=0;j<thisGroup->nSize;j++)
             {
                 assetrefbin=(unsigned char*)lpAssets->GetRow(aptr[j]);
                 
@@ -113,7 +102,8 @@ int CAssetGroupTree::Resize(int newAssets)
     CAssetGroup *thisGroup;
     
     n=nAssetsPerGroup;
-    while(nOptimalGroupCount*n < lpAssets->GetCount()+newAssets-nSingleAssetGroupCount)
+    
+    while(nOptimalGroupCount*n < lpAssets->GetCount()+newAssets)
     {
         n*=2;
     }
@@ -286,6 +276,7 @@ CAssetGroup *CAssetGroupTree::FindAndShiftBestGroup(int assets)
         thisGroup->nNextGroup=0;                                                // The group is full
     }
     
+    
     return thisGroup;    
 }
 
@@ -306,14 +297,13 @@ int CAssetGroupTree::GetGroup(mc_Buffer* assets, int addIfNeeded)
         return -1;
     }
 
-    int group_id,last_asset_count,new_asset_count,only_asset;
+    int group_id,last_asset_count,new_asset_count;
     int i,g;
     int *iptr;
     int *aptr;
     unsigned char *assetRef;
     CAssetGroup *thisGroup;
     
-    only_asset=-1;
     group_id=-2;                                                                // No assets in this buffer
     last_asset_count=lpAssets->GetCount();
     for(i=0;i<assets->GetCount();i++)
@@ -324,14 +314,6 @@ int CAssetGroupTree::GetGroup(mc_Buffer* assets, int addIfNeeded)
             (mc_GetABRefType(assetRef) != MC_AST_ASSET_REF_TYPE_GENESIS) )                    
 //        if(mc_GetLE(assetRef,4) > 0)                             
         {
-            if(only_asset == -1)
-            {
-                only_asset=i;
-            }
-            else
-            {
-                only_asset=-2;                                                  // More than one asset
-            }
             g=GetGroup(assetRef,0);
             if(g>0)
             {
@@ -379,17 +361,7 @@ int CAssetGroupTree::GetGroup(mc_Buffer* assets, int addIfNeeded)
     
     thisGroup=NULL;
     
-    if(only_asset >= 0)                                                         // Assets which cannot be combined with other
-    {
-        thisGroup=AddSingleAssetGroup(assets->GetRow(only_asset));
-        if(thisGroup)
-        {
-            return thisGroup->nThisGroup;            
-        }
-    }
-    
-//    Resize(new_asset_count - last_asset_count);
-    Resize(0);                                                                  // Assets already added
+    Resize(new_asset_count - last_asset_count);
 
     if(group_id > 0)                                                                // There are old assets, so we know what should be group id
     {
@@ -454,45 +426,6 @@ int CAssetGroupTree::GetGroup(mc_Buffer* assets, int addIfNeeded)
     return 0;
 }
 
-
-/*
- * Returns group id of the asset 
- * Adds single assets
- */
-
-CAssetGroup *CAssetGroupTree::AddSingleAssetGroup(unsigned char *assetRef)
-{
-    mc_EntityDetails entity;
-    int group_id,asset_id;
-    int *aptr;
-    
-    if(mc_gState->m_Assets->FindEntityByFullRef(&entity,assetRef))
-    {
-        if( entity.Permissions() & (MC_PTP_SEND | MC_PTP_RECEIVE) )
-        {
-            asset_id=lpAssets->GetCount()-1;
-            group_id=lpAssetGroups->GetCount();
-            CAssetGroup assetGroup;
-            assetGroup.nThisGroup=group_id;
-            assetGroup.nNextGroup=0;
-            assetGroup.nSize=-1;
-            memset(lpTmpGroupBuffer,0,nAssetsPerGroup*sizeof(int));
-            if(lpAssetGroups->Add(&assetGroup,lpTmpGroupBuffer))
-            {
-                return NULL;
-            }
-            *(int*)(lpAssets->GetRow(asset_id)+MC_AST_ASSET_QUANTITY_OFFSET)=group_id;
-            aptr=(int*)(lpAssetGroups->GetRow(group_id)+sizeof(CAssetGroup));
-            aptr[0]=asset_id;
-            nSingleAssetGroupCount++;
-            return (CAssetGroup *)(lpAssetGroups->GetRow(group_id));
-        }
-    }
-    
-    return NULL;
-}
-
-
 /*
  * Returns group id of the asset 
  * Adds to the groups if addIfNeeded==1
@@ -561,21 +494,46 @@ void DebugPrintAssetTxOut(uint256 hash,int index,unsigned char* assetrefbin,int6
 {
     string txid=hash.GetHex();
     
-    if(debug_print)
+    
+    if(mc_gState->m_Features->ShortTxIDInTx())
     {
-        printf("TxOut: %s-%d ",txid.c_str(),index);        
-        if(mc_GetABRefType(assetrefbin) == MC_AST_ASSET_REF_TYPE_SPECIAL)
+        if(debug_print)
         {
-            printf("Special:        %08x%08x",(uint32_t)mc_GetLE(assetrefbin,4),(uint32_t)mc_GetLE(assetrefbin+4,4));
+            printf("TxOut: %s-%d ",txid.c_str(),index);        
+            if(mc_GetABRefType(assetrefbin) == MC_AST_ASSET_REF_TYPE_SPECIAL)
+            {
+                printf("Special:        %08x%08x",(uint32_t)mc_GetLE(assetrefbin,4),(uint32_t)mc_GetLE(assetrefbin+4,4));
+            }
+            else
+            {
+                for(int i=MC_AST_SHORT_TXID_OFFSET+MC_AST_SHORT_TXID_SIZE-1;i>=MC_AST_SHORT_TXID_OFFSET;i--)
+                {
+                    printf("%02x",assetrefbin[i]);
+                }
+            }
+            printf(" %ld\n",quantity);        
         }
-        else
+    }
+    else
+    {
+        string assetref="";
+        if(mc_GetABRefType(assetrefbin) == MC_AST_ASSET_REF_TYPE_SHORT_TXID)
         {
-            for(int i=MC_AST_SHORT_TXID_OFFSET+MC_AST_SHORT_TXID_SIZE-1;i>=MC_AST_SHORT_TXID_OFFSET;i--)
+            for(int i=0;i<8;i++)
             {
-                printf("%02x",assetrefbin[i]);
+                assetref += strprintf("%02x",assetrefbin[MC_AST_SHORT_TXID_OFFSET+MC_AST_SHORT_TXID_SIZE-i-1]);
             }
         }
-        printf(" %ld\n",quantity);        
+        else
+        {
+            assetref += itostr((int)mc_GetLE(assetrefbin,4));
+            assetref += "-";
+            assetref += itostr((int)mc_GetLE(assetrefbin+4,4));
+            assetref += "-";
+            assetref += itostr((int)mc_GetLE(assetrefbin+8,2));
+        }
+        
+        if(debug_print)printf("TxOut: %s-%d %s %ld\n",txid.c_str(),index,assetref.c_str(),quantity);
     }
 }
 
@@ -793,8 +751,7 @@ bool FindRelevantCoins(CWallet *lpWallet,
         
         out_i=out.i;
         tmp_amounts->Clear();
-        if(custom_good_for_coin_selection(txout.scriptPubKey) &&
-            ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,mapSpecialEntity,strError))
+        if(ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,mapSpecialEntity,strError))
         {
                                                                                 // All coins are taken, possible future optimization
 /*            
@@ -838,30 +795,8 @@ bool FindRelevantCoins(CWallet *lpWallet,
             }
             if(is_relevant)
             {
-                if(mc_gState->m_Features->PerAssetPermissions())
-                {
-                    CTxDestination addressRet;        
-
-                    if(allowed & MC_PTP_SEND)
-                    {
-                        if(ExtractDestinationScriptValid(txout.scriptPubKey, addressRet))
-                        {
-                            string strPerAssetFailReason;
-
-                            vector<CTxDestination> addressRets;
-                            addressRets.push_back(addressRet);
-
-                            if(!mc_VerifyAssetPermissions(tmp_amounts,addressRets,1,MC_PTP_SEND,strPerAssetFailReason) || 
-                               !mc_VerifyAssetPermissions(tmp_amounts,addressRets,1,MC_PTP_RECEIVE,strPerAssetFailReason))
-                            {
-                                allowed -= MC_PTP_SEND;                                
-                            }
-                        }
-                    }
-                }
-                    
                 if(allowed & MC_PTP_SEND)
-                {                    
+                {
                     if(!InsertCoinIntoMatrix(coin_id,hash,out_i,tmp_amounts,out_amounts,in_amounts,in_map,in_row,in_size,in_special_row,pure_native))
                     {
                         strFailReason=_("Internal error: Cannot update input amount matrix");
@@ -921,6 +856,7 @@ bool FindCoinsToCombine(CWallet *lpWallet,
     int full_count,this_count,pure_native_count;
     CAmount total_native;
     int total_native_hit;
+    
     vector <pair<int,int> > active_groups;                                      // Groups found in UTXOs
     
     group_count=lpWallet->lpAssetGroups->GroupCount();
@@ -945,8 +881,7 @@ bool FindCoinsToCombine(CWallet *lpWallet,
             uint256 hash=out.GetHashAndTxOut(txout);
             out_i=out.i;
             tmp_amounts->Clear();
-            if(custom_good_for_coin_selection(txout.scriptPubKey) && 
-                    ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,strError))
+            if(ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,strError))
             {
                 if( (required & MC_PTP_ISSUE) == 0 )                            // Ignore txouts containing unconfirmed geneses
                 {
@@ -1056,8 +991,7 @@ bool FindCoinsToCombine(CWallet *lpWallet,
             uint256 hash=out.GetHashAndTxOut(txout);
             out_i=out.i;
             tmp_amounts->Clear();
-            if(custom_good_for_coin_selection(txout.scriptPubKey) &&
-                    ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,strError))
+            if(ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,&allowed,&required,strError))
             {
                 if( (required & MC_PTP_ISSUE) == 0 )                            // Ignore txouts containing unconfirmed geneses
                 {
@@ -1499,8 +1433,6 @@ CAmount BuildAssetTransaction(CWallet *lpWallet,
     CAmount nTotalChangeValue=0;
     CAmount default_change_output;
     CAmount change_amount;
-    CAmount mandatory_fee=0;
-    int64_t total_offchain_size=0;
         
     for(int i=0;i<change_amounts->GetCount();i++)                               // Finding relevant asset groups and calculating native currency total 
     {
@@ -1592,26 +1524,6 @@ CAmount BuildAssetTransaction(CWallet *lpWallet,
     else
     {
         default_change_output=182;   // 34 + 148 (see CTxOut.IsDust for explanation)
-        if(MCP_WITH_NATIVE_CURRENCY == 0)
-        {
-            default_change_output=0;
-        }
-    }
-    
-    if(MIN_OFFCHAIN_FEE)
-    {
-        total_offchain_size=0;
-        BOOST_FOREACH (const PAIRTYPE(CScript, CAmount)& s, vecSend)            // Original outputs
-        {
-            MultiChainTransaction_SetTmpOutputScript(s.first);
-            mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(NULL,NULL,NULL,&total_offchain_size);            
-        }
-        mandatory_fee=MultiChainTransaction_OffchainFee(total_offchain_size);
-    }
-    
-    if(nFeeRet == 0)
-    {
-        nFeeRet=mandatory_fee;
     }
     
     missing_amount=nFeeRet+(change_count+extra_change_count)*default_change_output-nTotalInValue;
@@ -1638,9 +1550,12 @@ CAmount BuildAssetTransaction(CWallet *lpWallet,
             txNew.vout.push_back(txout);
         }
 
-        int assets_per_opdrop;
+        int assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
         
-        assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+        if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+        {
+            assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+        }
  
         size_t elem_size;
         const unsigned char *elem;
@@ -1880,7 +1795,7 @@ CAmount BuildAssetTransaction(CWallet *lpWallet,
                 break;
         }
 
-        CAmount nFeeNeeded = lpWallet->GetMinimumFee(nBytes, nTxConfirmTarget, mempool)+mandatory_fee;
+        CAmount nFeeNeeded = lpWallet->GetMinimumFee(nBytes, nTxConfirmTarget, mempool);
 
         // If we made it here and we aren't even able to meet the relay fee on the next pass, give up
         // because we must be at the maximum allowed fee.
@@ -1918,139 +1833,6 @@ CAmount BuildAssetTransaction(CWallet *lpWallet,
     return 0;
 }
 
-bool CheckOutputPermissions(const vector<pair<CScript, CAmount> >& vecSend,mc_Buffer *tmp_amounts,std::string& strFailReason,int *eErrorCode)
-{
-    int receive_required;
-    int64_t quantity;
-    int err;
-    bool fIsMaybePurePermission,fIsGenesis;
-    
-    BOOST_FOREACH (const PAIRTYPE(CScript, CAmount)& s, vecSend)            
-    {
-        txnouttype typeRet;
-        int nRequiredRet;
-        vector<CTxDestination> addressRets;
-        if(!ExtractDestinations(s.first,typeRet,addressRets,nRequiredRet))
-        {
-            if(typeRet != TX_NULL_DATA)
-            {
-                strFailReason="Non-standard outputs are not supported in coin selection";
-                *eErrorCode=RPC_INTERNAL_ERROR;
-                return false;
-            }
-        }
-        if(addressRets.size()>0)
-        {
-            receive_required=addressRets.size();
-            if(typeRet == TX_MULTISIG)
-            {
-                receive_required-=nRequiredRet;
-                receive_required+=1;
-                if(receive_required>(int)addressRets.size())
-                {
-                    receive_required=addressRets.size();
-                }
-            }
-            
-            CScript::const_iterator pc1 = s.first.begin();
-
-            mc_gState->m_TmpScript->Clear();
-            mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(s.first.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-            
-            tmp_amounts->Clear();
-            if(!mc_ExtractOutputAssetQuantities(tmp_amounts,strFailReason,true))   
-            {
-                *eErrorCode=RPC_INTERNAL_ERROR;
-                return false;
-            }
-            if(!mc_VerifyAssetPermissions(tmp_amounts,addressRets,receive_required,MC_PTP_RECEIVE,strFailReason))
-            {
-                *eErrorCode=RPC_NOT_ALLOWED;
-                return false;
-            }
-            
-            fIsMaybePurePermission=true;
-            fIsGenesis=false;
-            for (int e = 0; e < mc_gState->m_TmpScript->GetNumElements(); e++)
-            {
-                mc_gState->m_TmpScript->SetElement(e);
-                err=mc_gState->m_TmpScript->GetAssetGenesis(&quantity);
-                if(err == 0)
-                {
-                    fIsGenesis=true;
-                    fIsMaybePurePermission=false;
-                }         
-                err=mc_gState->m_TmpScript->GetRawData(NULL,NULL);              
-                if(err == 0)
-                {
-                    fIsMaybePurePermission=false;
-                }
-            }
-
-            if(tmp_amounts->GetCount())                                         
-            {
-                if(fIsGenesis)
-                {
-                    strFailReason="Asset issuance and asset transfer are not allowed in one output";
-                    *eErrorCode=RPC_NOT_ALLOWED;
-                    return false;                    
-                }
-                fIsMaybePurePermission=false;                
-            }
-            
-            if(s.second > 0)
-            {
-                fIsMaybePurePermission=false;    
-            }
-            
-            if(!fIsMaybePurePermission)
-                
-            {
-                if( (s.second > 0) || 
-                    (tmp_amounts->GetCount() > 0) ||
-                    (mc_gState->m_Features->AnyoneCanReceiveEmpty() == 0) )
-                {
-                    for(int a=0;a<(int)addressRets.size();a++)
-                    {                            
-                        CKeyID *lpKeyID=boost::get<CKeyID> (&addressRets[a]);
-                        CScriptID *lpScriptID=boost::get<CScriptID> (&addressRets[a]);
-                        if((lpKeyID == NULL) && (lpScriptID == NULL))
-                        {
-                            strFailReason="Wrong destination type";
-                            *eErrorCode=RPC_INTERNAL_ERROR;
-                            return false;
-                        }
-                        unsigned char* ptr=NULL;
-                        if(lpKeyID != NULL)
-                        {
-                            ptr=(unsigned char*)(lpKeyID);
-                        }
-                        else
-                        {
-                            ptr=(unsigned char*)(lpScriptID);
-                        }
-
-                        bool fCanReceive=mc_gState->m_Permissions->CanReceive(NULL,ptr);
-
-                        if(fCanReceive)                        
-                        {
-                            receive_required--;
-                        }                                    
-                    }
-                    if(receive_required>0)
-                    {
-                        strFailReason="One of the outputs doesn't have receive permission";
-                        *eErrorCode=RPC_INSUFFICIENT_PERMISSIONS;
-                        return false;
-                    }
-                }
-            }            
-        }            
-    }
-    
-    return true;
-}
-
 bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript, CAmount> >& vecSend,
                                 CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, std::string& strFailReason, const CCoinControl* coinControl,
                                 const set<CTxDestination>* addresses,int min_conf,int min_inputs,int max_inputs,const vector<COutPoint>* lpCoinsToUse,uint32_t flags,int *eErrorCode)
@@ -2134,11 +1916,6 @@ bool CreateAssetGroupingTransaction(CWallet *lpWallet, const vector<pair<CScript
     required=0;
     if(vecSend.size())
     {
-        if(!CheckOutputPermissions(vecSend,tmp_amounts,strFailReason,eErrorCode))
-        {
-            goto exitlbl;
-        }
-                
         required=0;
         if( (addresses == NULL) || (addresses->size() != 1) )
         {
@@ -2697,14 +2474,17 @@ bool CWallet::InitializeUnspentList()
 
     lpAssetGroups=new CAssetGroupTree;
 
-    int assets_per_opdrop;
+    int assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
 
-    assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+    if(mc_gState->m_Features->VerifySizeOfOpDropElements())
+    {
+        assets_per_opdrop=(MAX_SCRIPT_ELEMENT_SIZE-4)/(mc_gState->m_NetworkParams->m_AssetRefSize+MC_AST_ASSET_QUANTITY_SIZE);
+    }
 
     int max_assets_per_group=assets_per_opdrop*MCP_STD_OP_DROP_COUNT;
 
     lpAssetGroups->Initialize(1,max_assets_per_group,32,1);
-    
+
     vector <COutput> vCoins;
 
     mc_Buffer *tmp_amounts;
@@ -2728,22 +2508,8 @@ bool CWallet::InitializeUnspentList()
             ParseMultichainTxOutToBuffer(hash,txout,tmp_amounts,lpScript,NULL,NULL,strError);
         }
         asset_count=tmp_amounts->GetCount();
-        if(mc_gState->m_Features->PerAssetPermissions())
-        {
-            mc_EntityDetails entity;
-            for(int i=0;i<tmp_amounts->GetCount();i++)
-            {
-                if(mc_gState->m_Assets->FindEntityByFullRef(&entity,tmp_amounts->GetRow(i)))
-                {
-                    if( entity.Permissions() & (MC_PTP_SEND | MC_PTP_RECEIVE) )
-                    {
-                        asset_count--;
-                    }
-                }
-            }
-        }
-        if(asset_count > 0)                                                     // Resize asset grouping to prevent crazy autocombine on 
-                                                                                 // already autocombined with higher assets-per-group setting   
+        if(asset_count)                                         // Resize asset grouping to prevent crazy autocombine on 
+                                                                            // already autocombined with higher assets-per-group setting   
         {
             lpAssetGroups->Resize(asset_count);
         }
diff --git a/src/wallet/wallettxdb.cpp b/src/wallet/wallettxdb.cpp
index 6c2521a..6e68379 100644
--- a/src/wallet/wallettxdb.cpp
+++ b/src/wallet/wallettxdb.cpp
@@ -6,11 +6,23 @@
 
 #define MC_TDB_MAX_TXS_FILE_SIZE             0x8000000                          // Maximal data file size, 128MB
 
-void mc_TxEntityRowExtension::Zero()
+void sprintf_hex(char *hex,const unsigned char *bin,int size)
 {
-    memset(this,0,sizeof(mc_TxEntityRowExtension));    
+    int i;
+    for(i=0;i<size;i++)
+    {
+        sprintf(hex+(i*2),"%02x",bin[size-1-i]);
+    }
+    
+    hex[64]=0;      
+}
+
+int IsCSkipped(int type)
+{
+    return 0;
 }
 
+
 void mc_TxEntity::Zero()
 {
     memset(this,0,sizeof(mc_TxEntity));
@@ -99,7 +111,7 @@ int mc_TxImport::Init(int generation,int block)
     m_Entities=new mc_Buffer;
     m_TmpEntities=new mc_Buffer;
     
-    m_TmpEntities->Initialize(sizeof(mc_TxEntity),sizeof(mc_TxEntity)+sizeof(mc_TxEntityRowExtension),MC_BUF_MODE_MAP);    
+    m_TmpEntities->Initialize(sizeof(mc_TxEntity),sizeof(mc_TxEntity),MC_BUF_MODE_MAP);    
     return m_Entities->Initialize(sizeof(mc_TxEntity),sizeof(mc_TxEntityStat),MC_BUF_MODE_MAP);    
 }
 
@@ -523,18 +535,10 @@ int mc_TxDB::Destroy()
 }
 
 void mc_TxDB::Dump(const char *message)
-{
-    Dump(message,0);
-}
-
-void mc_TxDB::Dump(const char *message, int force)
 {    
-    if(force == 0)
+    if((m_Mode & MC_WMD_DEBUG) == 0)
     {
-        if((m_Mode & MC_WMD_DEBUG) == 0)
-        {
-            return;
-        }
+        return;
     }
     mc_TxEntityRow edbRow;
     
@@ -882,6 +886,11 @@ int mc_TxDB::DecrementSubKey(
     
     err=MC_ERR_NOERROR;
     
+    if(IsCSkipped(entity->m_EntityType))
+    {
+        return err;
+    }
+    
     imp=m_Imports;
     mempool=m_MemPools[0];
     if(import)                                                                  // Find import
@@ -950,8 +959,7 @@ int mc_TxDB::IncrementSubKey(
               mc_TxEntity *parent_entity,                                       
               mc_TxEntity *entity,                                              
               const unsigned char *subkey_hash,                                 
-              const unsigned char *tx_hash,          
-              mc_TxEntityRowExtension *extension,
+              const unsigned char *tx_hash,                                     
               int block,                                                        
               uint32_t flags,                                                   
               int newtx)
@@ -968,6 +976,11 @@ int mc_TxDB::IncrementSubKey(
     
     err=MC_ERR_NOERROR;
     
+    if(IsCSkipped(entity->m_EntityType))
+    {
+        return err;
+    }
+    
     imp=m_Imports;
     mempool=m_MemPools[0];
     if(import)                                                                  // Find import
@@ -1038,15 +1051,6 @@ int mc_TxDB::IncrementSubKey(
         erow.m_TempPos=last_pos+1;        
         erow.m_Block=block;
         erow.m_Flags=flags;
-        if(extension)
-        {
-            if(extension->m_Count)
-            {
-                memcpy(erow.m_TxId+MC_TEE_OFFSET_IN_TXID,extension,MC_TEE_SIZE_IN_EXTENSION);                
-                erow.m_Flags |= MC_TFL_IS_EXTENSION;
-            }
-        }
-        
         mempool->Add(&erow,(unsigned char*)&erow+MC_TDB_ENTITY_KEY_SIZE+MC_TDB_TXID_SIZE);        
         
         if(last_pos == 0)
@@ -1069,6 +1073,29 @@ exitlbl:
     return err;
 }
 
+int mc_TxDB::SetTxCache(                                                             // Returns tx definition if found, error if not found
+              const unsigned char *hash)
+{
+    m_TxCachedDef.Zero();
+    m_TxCachedFlags=MC_TCF_ERROR;
+    
+    int err=GetTx(&m_TxCachedDef,hash,IsCSkipped(MC_TET_GETDB_ADD_TX));    
+    if(err == MC_ERR_NOERROR)
+    {
+        m_TxCachedFlags=MC_TCF_FOUND;   
+    }
+    else
+    {
+        if (err == MC_ERR_NOT_FOUND)
+        {
+            m_TxCachedFlags=MC_TCF_NOT_FOUND;
+        }
+    }
+    
+    return MC_ERR_NOERROR;
+}
+
+
 /*
  * Adds tx to specific import
  */
@@ -1092,7 +1119,7 @@ int mc_TxDB::AddTx(mc_TxImport *import,
     char txtype[16];
     char msg[256];
     
-    int newtx,duplicate,isrelevant,ondisk,i,mprow,size,ext_flag;
+    int newtx,duplicate,isrelevant,ondisk,i,mprow,size;
     uint32_t LastFileID,LastFileSize; 
     mc_TxImport *imp;
     mc_Buffer *mempool;
@@ -1101,7 +1128,6 @@ int mc_TxDB::AddTx(mc_TxImport *import,
     mc_TxEntityRow erow;
     mc_TxDefRow txdef;
     mc_TxDefRow *lptxdef;
-    mc_TxEntityRowExtension *extension;
     
     err=MC_ERR_NOERROR;
 
@@ -1145,7 +1171,20 @@ int mc_TxDB::AddTx(mc_TxImport *import,
 
     newtx=0;
     ondisk=0;
-    err=GetTx(&txdef,hash);
+//    err=GetTx(&txdef,hash,IsCSkipped(MC_TET_GETDB_ADD_TX));
+    if(m_TxCachedFlags & MC_TCF_FOUND)
+    {
+        memcpy(&txdef,&(m_TxCachedDef),sizeof(mc_TxDefRow));
+    }
+    if(m_TxCachedFlags & MC_TCF_NOT_FOUND)
+    {
+        err=MC_ERR_NOT_FOUND;
+    }
+    if(m_TxCachedFlags & MC_TCF_ERROR)
+    {
+        err=MC_ERR_INTERNAL_ERROR;
+    }
+    
     if(err == MC_ERR_NOT_FOUND)                                                 // Tx is not found, neither on disk, nor in the mempool    
     {
         err=MC_ERR_NOERROR;
@@ -1246,6 +1285,11 @@ int mc_TxDB::AddTx(mc_TxImport *import,
             }
         }
         
+        if(IsCSkipped(((mc_TxEntity*)entities->GetRow(i))->m_EntityType))
+        {
+            isrelevant=0;
+        }
+        
         if(isrelevant)
         {
             stat=imp->GetEntity(imp->FindEntity((mc_TxEntity*)entities->GetRow(i)));
@@ -1261,19 +1305,11 @@ int mc_TxDB::AddTx(mc_TxImport *import,
             memcpy(&erow.m_Entity,&stat->m_Entity,sizeof(mc_TxEntity));
             erow.m_Generation=stat->m_Generation;
             memcpy(erow.m_TxId,hash,MC_TDB_TXID_SIZE);
-            ext_flag=0;
-            extension=(mc_TxEntityRowExtension*)(entities->GetRow(i)+sizeof(mc_TxEntity));
-            if(extension->m_Count)
-            {
-                memcpy(erow.m_TxId+MC_TEE_OFFSET_IN_TXID,extension,MC_TEE_SIZE_IN_EXTENSION);                
-                ext_flag = MC_TFL_IS_EXTENSION;
-            }
-            
             mprow=mempool->Seek(&erow);
             if(mprow >= 0)                                                      // Update block and flags if found in mempool
             {
                 ((mc_TxEntityRow*)(mempool->GetRow(mprow)))->m_Block=block;
-                ((mc_TxEntityRow*)(mempool->GetRow(mprow)))->m_Flags=flags | ext_flag;                
+                ((mc_TxEntityRow*)(mempool->GetRow(mprow)))->m_Flags=flags;                
             }
             else
             {
@@ -1283,7 +1319,7 @@ int mc_TxDB::AddTx(mc_TxImport *import,
                    ((erow.m_Entity.m_EntityType & MC_TET_ORDERMASK) != MC_TET_TIMERECEIVED)) // Ordered by chain position - add always   
                 {                        
                     erow.m_Block=block;
-                    erow.m_Flags=flags | ext_flag;
+                    erow.m_Flags=flags;
                     stat->m_LastPos+=1;
                     erow.m_TempPos=stat->m_LastPos;                             // Will be copied to m_LastPos on commit. m_LastPos=0 to allow Seek() above
                     mempool->Add(&erow,(unsigned char*)&erow+MC_TDB_ENTITY_KEY_SIZE+MC_TDB_TXID_SIZE);
@@ -1446,6 +1482,13 @@ int mc_TxDB::SaveTxFlag(const unsigned char *hash,uint32_t flag,int set_flag)
 
 int mc_TxDB::GetTx(mc_TxDefRow *txdef,
               const unsigned char *hash)
+{
+    return GetTx(txdef,hash,0);
+}
+
+int mc_TxDB::GetTx(mc_TxDefRow *txdef,
+              const unsigned char *hash,
+              int skip_db)
 {
     int err,value_len,mprow; 
     unsigned char *ptr;
@@ -1476,6 +1519,11 @@ int mc_TxDB::GetTx(mc_TxDefRow *txdef,
         return MC_ERR_NOERROR;
     }
     
+    if(skip_db)
+    {
+        return MC_ERR_NOT_FOUND;
+    }
+    
     memcpy(txdef->m_TxId,hash, MC_TDB_TXID_SIZE);
     ptr=(unsigned char*)m_Database->m_DB->Read((char*)txdef+m_Database->m_KeyOffset,m_Database->m_KeySize,&value_len,0,&err);
     if(err)
@@ -2020,6 +2068,11 @@ int mc_TxDB::GetList(
     
     txs->Clear();
     
+    if(IsCSkipped(entity->m_EntityType))
+    {
+        return MC_ERR_NOT_SUPPORTED;
+    }
+    
     int row;
     mc_TxEntityStat *stat;
     
@@ -2141,6 +2194,11 @@ int mc_TxDB::GetList(
     
     txs->Clear();
     
+    if(IsCSkipped(entity->m_EntityType))
+    {
+        return MC_ERR_NOT_SUPPORTED;
+    }
+    
     mempool=m_MemPools[import-m_Imports];
     
     first=from;
diff --git a/src/wallet/wallettxdb.h b/src/wallet/wallettxdb.h
index de57b43..e2cc3c3 100644
--- a/src/wallet/wallettxdb.h
+++ b/src/wallet/wallettxdb.h
@@ -29,17 +29,16 @@
 #define MC_TET_STREAM_KEY                       0x00000006
 #define MC_TET_STREAM_PUBLISHER                 0x00000007
 #define MC_TET_ASSET                            0x00000008
-#define MC_TET_AUTHOR                           0x00000009
 #define MC_TET_SUBKEY_STREAM_KEY                0x00000046
 #define MC_TET_SUBKEY_STREAM_PUBLISHER          0x00000047
 #define MC_TET_SUBKEY                           0x00000040
-#define MC_TET_TYPE_MASK                        0x040000FF
+#define MC_TET_TYPE_MASK                        0x000000FF
 #define MC_TET_CHAINPOS                         0x00000100
 #define MC_TET_TIMERECEIVED                     0x00000200
 #define MC_TET_ORDERMASK                        0x0000FF00
 #define MC_TET_DB_STAT                          0x01000000
 #define MC_TET_IMPORT                           0x02000000
-#define MC_TET_DELETED                          0x04000000
+#define MC_TET_GETDB_ADD_TX                     0x10000000
 #define MC_TET_SPECIALMASK                      0xFF000000
 
 #define MC_EFL_NOT_IN_SYNC                      0x01000000
@@ -52,10 +51,12 @@
 #define MC_SFL_NODATA           0x01000000
 #define MC_SFL_SUBKEY           0x02000000
 
-#define MC_TEE_OFFSET_IN_TXID                  24
-#define MC_TEE_SIZE_IN_EXTENSION                8
 
-#define MC_TFL_IS_EXTENSION             0x01000000
+#define MC_TCF_NOT_CACHED                    0x00000000
+#define MC_TCF_ERROR                         0x00000001
+#define MC_TCF_FOUND                         0x00000002
+#define MC_TCF_NOT_FOUND                     0x00000004
+
 
 /** Entity - wallet, address, stream, etc. **/
 
@@ -68,16 +69,6 @@ typedef struct mc_TxEntity
     int IsSubscription();
 } mc_TxEntity;
 
-typedef struct mc_TxEntityRowExtension
-{
-    uint32_t m_Output;
-    uint32_t m_Count;
-    uint32_t m_TmpLastCount;
-    uint32_t m_Reserved;
-    void Zero();
-} mc_TxEntityRowExtension;
-
-
 /** Entity row pos->txid **/
 
 typedef struct mc_TxEntityRow
@@ -245,7 +236,9 @@ typedef struct mc_TxDB
     uint32_t m_Mode;
     void *m_Semaphore;                                                          // mc_TxDB object semaphore
     uint64_t m_LockedBy;                                                        // ID of the thread locking it
-
+    mc_TxDefRow m_TxCachedDef;                                                              
+    uint32_t m_TxCachedFlags;                                                              
+    
     mc_TxDB()
     {
         Zero();
@@ -285,10 +278,9 @@ typedef struct mc_TxDB
               mc_TxEntity *entity,                                              // Subkey entity
               const unsigned char *subkey_hash,                                 // Subkey hash
               const unsigned char *tx_hash,                                     // Tx hash (before chopping)    
-              mc_TxEntityRowExtension *extension,                               // Tx extension for storing multiple items per tx
               int block,                                                        // Block we are processing now, -1 for mempool
               uint32_t flags,                                                   // Flags passed by the higher level                
-              int newtx                                                         // New tx flag    
+              int newtx                                                         // New tx flag
     );
     
     int DecrementSubKey(
@@ -311,10 +303,18 @@ typedef struct mc_TxDB
               uint32_t timestamp,                                               // timestamp to be stored as timereceived
               mc_Buffer *entities);                                             // List of relevant entities for this tx
     
+    int SetTxCache(                                                             // Returns tx definition if found, error if not found
+              const unsigned char *hash);                                       // Input. Tx hash
+    
     int GetTx(                                                                  // Returns tx definition if found, error if not found
               mc_TxDefRow *txdef,                                               // Output. Tx def
               const unsigned char *hash);                                       // Input. Tx hash
     
+    int GetTx(                                                                  // Returns tx definition if found, error if not found
+              mc_TxDefRow *txdef,                                               // Output. Tx def
+              const unsigned char *hash,                                        // Input. Tx hash
+              int skip_db);                                       
+    
     int GetList(
                 mc_TxImport *import,                                            // Import object, if NULL - chain
                 mc_TxEntity *entity,                                            // Returns Txs in range for specific entity
@@ -388,7 +388,6 @@ typedef struct mc_TxDB
     void Zero();    
     int Destroy();
     void Dump(const char *message);
-    void Dump(const char *message, int force);
     
     int Lock(int write_mode, int allow_secondary);
     void UnLock();
diff --git a/src/wallet/wallettxs.cpp b/src/wallet/wallettxs.cpp
index bf81943..c4e712e 100644
--- a/src/wallet/wallettxs.cpp
+++ b/src/wallet/wallettxs.cpp
@@ -207,10 +207,7 @@ void mc_WalletTxs::Zero()
 {
     int i;
     m_Database=NULL;
-    m_ChunkDB=NULL;
-    m_ChunkCollector=NULL;
     m_lpWallet=NULL;
-    m_ChunkBuffer=NULL;
     for(i=0;i<MC_TDB_MAX_IMPORTS;i++)
     {
         m_UTXOs[i].clear();
@@ -243,27 +240,12 @@ int mc_WalletTxs::Initialize(
 {
     int err,i;
     
-    m_ChunkDB=new mc_ChunkDB;
-
-    err=m_ChunkDB->Initialize(name,mode);
-
-    if(err)
-    {
-        return err;
-    }
-    
-    m_ChunkCollector=new mc_ChunkCollector;
-    
-    err=m_ChunkCollector->Initialize(m_ChunkDB,name,mode);
-    if(err)
-    {
-        return err;
-    }   
     
     m_Database=new mc_TxDB;
+    
     m_Mode=mode;
     err=m_Database->Initialize(name,mode);
-            
+    
     if(err == MC_ERR_NOERROR)
     {
         m_Mode=m_Database->m_DBStat.m_InitMode;
@@ -291,8 +273,6 @@ int mc_WalletTxs::Initialize(
         }
         LoadUnconfirmedSends(m_Database->m_DBStat.m_Block,m_Database->m_DBStat.m_Block);
     }    
-    
-    m_ChunkBuffer=(unsigned char*)mc_New(MAX_CHUNK_SIZE);
     return err;
 }
 
@@ -306,28 +286,11 @@ int mc_WalletTxs::SetMode(uint32_t mode, uint32_t mask)
 
 int mc_WalletTxs::Destroy()
 {
-    
     if(m_Database)
     {
         delete m_Database;
     }
 
-    if(m_ChunkCollector)
-    {
-        m_ChunkCollector->Commit();
-        delete m_ChunkCollector;
-    }    
-    
-    if(m_ChunkDB)
-    {
-        m_ChunkDB->Commit(-1);
-        delete m_ChunkDB;
-    }
-
-    if(m_ChunkBuffer)
-    {
-        mc_Delete(m_ChunkBuffer);
-    }
     Zero();
     return MC_ERR_NOERROR;    
     
@@ -361,22 +324,8 @@ int mc_WalletTxs::AddEntity(mc_TxEntity *entity,uint32_t flags)
         return MC_ERR_INTERNAL_ERROR;
     }
     m_Database->Lock(1,0);
-    err=m_Database->AddEntity(entity,flags);    
+    err=m_Database->AddEntity(entity,flags);
     m_Database->UnLock();
-    
-    if(err == MC_ERR_NOERROR)
-    {
-        if(mc_gState->m_Features->Chunks())
-        {
-            switch(entity->m_EntityType & MC_TET_TYPE_MASK)
-            {
-                case MC_TET_STREAM:
-                    err=m_ChunkDB->AddEntity(entity,flags);
-                    break;
-            }
-        }
-    }
-    
     return err;
 }
 
@@ -502,20 +451,6 @@ int mc_WalletTxs::Commit(mc_TxImport *import)
     {        
         imp=import;
     }    
-    if(mc_gState->m_Features->Chunks())
-    {
-        if(imp->m_ImportID == 0)
-        {
-            if(err == MC_ERR_NOERROR)
-            {
-                err=m_ChunkDB->Commit(imp->m_Block+1);
-            }
-            if(m_ChunkCollector)
-            {
-                err=m_ChunkCollector->Commit();
-            }                
-        }
-    }    
     m_Database->Lock(1,0);
     
     if(err == MC_ERR_NOERROR)
@@ -760,42 +695,36 @@ int mc_WalletTxs::RollBackSubKeys(mc_TxImport *import,int block,mc_TxEntityStat
 
                             mc_gState->m_TmpScript->Clear();
                             mc_gState->m_TmpScript->SetScript((unsigned char*)(&pc1[0]),(size_t)(script1.end()-pc1),MC_SCR_TYPE_SCRIPTPUBKEY);
-                            mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(NULL);
-                            if( (mc_gState->m_TmpScript->IsOpReturnScript() != 0 ) && (mc_gState->m_TmpScript->GetNumElements() >= 3) )
+                            if( (mc_gState->m_TmpScript->IsOpReturnScript() != 0 ) && (mc_gState->m_TmpScript->GetNumElements() == 3) )
                             {
-                                mc_gState->m_TmpScript->DeleteDuplicatesInRange(1,mc_gState->m_TmpScript->GetNumElements()-1);
                                 unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
                                 mc_gState->m_TmpScript->SetElement(0);
 
                                 if( (mc_gState->m_TmpScript->GetEntity(short_txid) == 0) &&           
                                     (memcmp(short_txid,parent_entity->m_Entity.m_EntityID,MC_AST_SHORT_TXID_SIZE) == 0) )    
                                 {
+                                    mc_gState->m_TmpScript->SetElement(1);
+                                    if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
+                                    {
+                                        err=MC_ERR_INTERNAL_ERROR;
+                                        goto exitlbl;                                                                                                                                        
+                                    }                    
+
+                                    subkey_hash160=Hash160(item_key,item_key+item_key_size);
+                                    mc_GetCompoundHash160(&stream_subkey_hash160,parent_entity->m_Entity.m_EntityID,&subkey_hash160);
+
                                     entity.Zero();
                                     memcpy(entity.m_EntityID,short_txid,MC_AST_SHORT_TXID_SIZE);
                                     entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_CHAINPOS;
-                                    
-                                    for(int e=mc_gState->m_TmpScript->GetNumElements()-2;e>=1;e--)
+                                    subkey_entity.Zero();
+                                    memcpy(subkey_entity.m_EntityID,&stream_subkey_hash160,MC_TDB_ENTITY_ID_SIZE);
+                                    subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_CHAINPOS;
+                                    err= m_Database->DecrementSubKey(imp,&entity,&subkey_entity);
+                                    if(err)
                                     {
-                                        mc_gState->m_TmpScript->SetElement(e);
-                                        if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
-                                        {
-                                            err=MC_ERR_INTERNAL_ERROR;
-                                            goto exitlbl;                                                                                                                                        
-                                        }                    
-
-                                        subkey_hash160=Hash160(item_key,item_key+item_key_size);
-                                        mc_GetCompoundHash160(&stream_subkey_hash160,parent_entity->m_Entity.m_EntityID,&subkey_hash160);
-
-                                        subkey_entity.Zero();
-                                        memcpy(subkey_entity.m_EntityID,&stream_subkey_hash160,MC_TDB_ENTITY_ID_SIZE);
-                                        subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_CHAINPOS;
-                                        err= m_Database->DecrementSubKey(imp,&entity,&subkey_entity);
-                                        if(err)
-                                        {
-                                            goto exitlbl;
-                                        }
+                                        goto exitlbl;
                                     }
-                                    
+                            
                                     publishers_set.clear();
                                     for (j = 0; j < (int)wtx.vin.size(); ++j)
                                     {
@@ -1303,9 +1232,9 @@ int mc_WalletTxs::GetListSize(mc_TxEntity *entity,int generation,int *confirmed)
     return res;                
 }
 
-int mc_WalletTxs::Unsubscribe(mc_Buffer* lpEntities,bool purge)
+int mc_WalletTxs::Unsubscribe(mc_Buffer* lpEntities)
 {
-    int err,j;
+    int err;
     if((m_Mode & MC_WMD_TXS) == 0)
     {
         return MC_ERR_NOT_SUPPORTED;
@@ -1316,29 +1245,8 @@ int mc_WalletTxs::Unsubscribe(mc_Buffer* lpEntities,bool purge)
     }
     m_Database->Lock(1,0);    
     err=m_Database->Unsubscribe(lpEntities);
-    if(err==MC_ERR_NOERROR)
-    {
-        if(mc_gState->m_Features->Chunks())
-        {
-            if(purge)
-            {
-                if(m_ChunkDB)
-                {
-                    for(j=0;j<lpEntities->GetCount();j++)                                       
-                    {
-                        m_ChunkDB->RemoveEntity((mc_TxEntity*)lpEntities->GetRow(j));
-                    }
-                }
-            }
-        }
-    }
     if(fDebug)LogPrint("wallet","wtxs: Unsubscribed from %d entities\n",lpEntities->GetCount());
     m_Database->UnLock();
-    
-    if(m_ChunkCollector)
-    {
-        m_ChunkCollector->Unsubscribe(lpEntities);
-    }
     return err;                        
 }
 
@@ -1955,7 +1863,7 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CTransaction& tx,int block,CDi
 
 int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskTxPos* block_pos,uint32_t block_tx_index,uint256 block_hash)
 {
-    int err,i,j,entcount,lockres,entpos,base_row;
+    int err,i,j,entcount,lockres,entpos;
     mc_TxImport *imp;
     mc_TxEntity entity;
     mc_TxEntity subkey_entity;
@@ -1963,9 +1871,6 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
     mc_TxEntity input_entity;
     mc_TxEntity *lpent;
     mc_TxDefRow txdef;
-    mc_TxEntityRowExtension extension;
-    mc_TxEntityRowExtension *lpext;
-    
     const CWalletTx *fullTx;
     const CWalletTx *storedTx;
     CWalletTx stx;
@@ -1975,7 +1880,6 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
     uint160 subkey_hash160;
     uint160 stream_subkey_hash160;
     set<uint160> publishers_set;
-    map<uint160,int> subkey_count_map;
     
     int import_pos;
     bool fFound;
@@ -2025,11 +1929,19 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
     
     fFound=false;
     txdef.Zero();
+    
+    m_Database->SetTxCache((unsigned char*)&hash);
+    if(m_Database->m_TxCachedFlags == MC_TCF_FOUND)
+    {
+        fFound=true;
+        memcpy(&txdef,&(m_Database->m_TxCachedDef),sizeof(mc_TxDefRow));
+    }
+/*    
     if(m_Database->GetTx(&txdef,(unsigned char*)&hash) == MC_ERR_NOERROR)
     {
         fFound=true;        
     }
-    
+*/    
     if(!fFound)
     {
         for(i=0;i<(int)tx.vout.size();i++)                                      // Checking that tx has long OP_RETURN
@@ -2328,17 +2240,8 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
         }
         else
         {
-            unsigned char *chunk_hashes;
-            unsigned char *chunk_found;
-            int chunk_count,chunk_err;
-            int chunk_size,chunk_shift;
-            size_t chunk_bytes;
-            
-            mc_gState->m_TmpScript->ExtractAndDeleteDataFormat(NULL,&chunk_hashes,&chunk_count,NULL);
-            if(mc_gState->m_TmpScript->GetNumElements() >= 3) // 2 OP_DROPs + OP_RETURN - item key
+            if(mc_gState->m_TmpScript->GetNumElements() == 3) // 2 OP_DROPs + OP_RETURN - item key
             {
-                mc_gState->m_TmpScript->DeleteDuplicatesInRange(1,mc_gState->m_TmpScript->GetNumElements()-1);
-                
                 unsigned char short_txid[MC_AST_SHORT_TXID_SIZE];
                 mc_gState->m_TmpScript->SetElement(0);
                                                                             
@@ -2349,111 +2252,45 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
                     entity.m_EntityType=MC_TET_STREAM | MC_TET_CHAINPOS;
                     if(imp->FindEntity(&entity) >= 0)    
                     {
-                        if(chunk_hashes)
+                        if(imp->m_TmpEntities->Seek(&entity) < 0)
                         {
-                            mc_ChunkDBRow chunk_def;
-                            mc_TxEntity chunk_entity;
-                            chunk_entity.Zero();
-                            memcpy(chunk_entity.m_EntityID,short_txid,MC_AST_SHORT_TXID_SIZE);
-                            chunk_entity.m_EntityType=MC_TET_STREAM;            
-                            for(int chunk=0;chunk<chunk_count;chunk++)
+                            imp->m_TmpEntities->Add(&entity,NULL);
+                            
+                            mc_gState->m_TmpScript->SetElement(1);
+                            if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
                             {
-                                chunk_size=(int)mc_GetVarInt(chunk_hashes,MC_CDB_CHUNK_HASH_SIZE+16,-1,&chunk_shift);
-                                chunk_hashes+=chunk_shift;
-                                if(m_ChunkDB->GetChunkDef(&chunk_def,chunk_hashes,&chunk_entity,(unsigned char*)&hash,i) != MC_ERR_NOERROR)
-                                {
-                                    if(m_ChunkDB->GetChunkDef(&chunk_def,chunk_hashes,NULL,NULL,-1) == MC_ERR_NOERROR)
-                                    {
-                                        chunk_found=m_ChunkDB->GetChunk(&chunk_def,0,-1,&chunk_bytes);
-                                        if(chunk_found)
-                                        {
-                                            memcpy(m_ChunkBuffer,chunk_found,chunk_size);
-                                            chunk_err=m_ChunkDB->AddChunk(chunk_hashes,&chunk_entity,(unsigned char*)&hash,i,m_ChunkBuffer,NULL,chunk_size,0,0);
-                                            if(chunk_err)
-                                            {
-                                                err=chunk_err;
-                                                goto exitlbl;
-                                            }
-                                        }
-                                        else
-                                        {
-                                            err=MC_ERR_CORRUPTED;
-                                            goto exitlbl;      
-                                        }
-                                    }
-                                    else
-                                    {
-                                        m_ChunkCollector->InsertChunk(chunk_hashes,&chunk_entity,(unsigned char*)&hash,i,chunk_size);
-                                        // Feeding async chunk retriever here
-                                    }
-                                }
-                                chunk_hashes+=MC_CDB_CHUNK_HASH_SIZE;
-                            }
-                        }
-//                        if(imp->m_TmpEntities->Seek(&entity) < 0)
-                        {
-                            extension.Zero();
-                            extension.m_Output=i;
-                            base_row=imp->m_TmpEntities->Seek(&entity);
-                            if(base_row >= 0)
+                                err=MC_ERR_INTERNAL_ERROR;
+                                goto exitlbl;                                                                                                                                        
+                            }                    
+
+                            subkey_hash160=Hash160(item_key,item_key+item_key_size);
+                            subkey_hash256=0;
+                            memcpy(&subkey_hash256,&subkey_hash160,sizeof(subkey_hash160));
+                            err=m_Database->AddSubKeyDef(imp,(unsigned char*)&subkey_hash256,item_key,item_key_size,MC_SFL_SUBKEY);
+                            if(err)
                             {
-                                lpext=(mc_TxEntityRowExtension*)(imp->m_TmpEntities->GetRow(base_row)+sizeof(mc_TxEntity));
-                                lpext->m_TmpLastCount+=1;
-                                extension.m_Count=lpext->m_TmpLastCount;
+                                goto exitlbl;
                             }
+
+                            mc_GetCompoundHash160(&stream_subkey_hash160,entity.m_EntityID,&subkey_hash160);
                             
-                            imp->m_TmpEntities->Add(&entity,&extension);
-                            
-                            extension.m_Count=0;
-                            for(int e=1;e<mc_gState->m_TmpScript->GetNumElements()-1;e++)
+                            entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_CHAINPOS;
+                            subkey_entity.Zero();
+                            memcpy(subkey_entity.m_EntityID,&stream_subkey_hash160,MC_TDB_ENTITY_ID_SIZE);
+                            subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_CHAINPOS;
+                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,block,0,fFound ? 0 : 1);
+                            if(err)
                             {
-                                mc_gState->m_TmpScript->SetElement(e);
-                                if(mc_gState->m_TmpScript->GetItemKey(item_key,&item_key_size))   // Item key
-                                {
-                                    err=MC_ERR_INTERNAL_ERROR;
-                                    goto exitlbl;                                                                                                                                        
-                                }                    
-
-                                subkey_hash160=Hash160(item_key,item_key+item_key_size);
-                                subkey_hash256=0;
-                                memcpy(&subkey_hash256,&subkey_hash160,sizeof(subkey_hash160));
-                                err=m_Database->AddSubKeyDef(imp,(unsigned char*)&subkey_hash256,item_key,item_key_size,MC_SFL_SUBKEY);
-                                if(err)
-                                {
-                                    goto exitlbl;
-                                }
-
-                                mc_GetCompoundHash160(&stream_subkey_hash160,entity.m_EntityID,&subkey_hash160);
-
-                                map<uint160,int>::iterator it = subkey_count_map.find(stream_subkey_hash160);
-                                if (it == subkey_count_map.end())
-                                {
-                                    subkey_count_map.insert(make_pair(stream_subkey_hash160,0));
-                                }
-                                else
-                                {
-                                    it->second += 1;
-                                    extension.m_Count=it->second;
-                                }
-                                
-                                entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_CHAINPOS;
-                                subkey_entity.Zero();
-                                memcpy(subkey_entity.m_EntityID,&stream_subkey_hash160,MC_TDB_ENTITY_ID_SIZE);
-                                subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_CHAINPOS;
-                                err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,&extension,block,0,fFound ? 0 : 1);
-                                if(err)
-                                {
-                                    goto exitlbl;
-                                }
-
-                                entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_TIMERECEIVED;
-                                subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_TIMERECEIVED;
-                                err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,&extension,block,0,fFound ? 0 : 1);
-                                if(err)
-                                {
-                                    goto exitlbl;
-                                }                           
+                                goto exitlbl;
                             }
+                            
+                            entity.m_EntityType=MC_TET_STREAM_KEY | MC_TET_TIMERECEIVED;
+                            subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_KEY | MC_TET_TIMERECEIVED;
+                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,block,0,fFound ? 0 : 1);
+                            if(err)
+                            {
+                                goto exitlbl;
+                            }                           
 
                             publishers_set.clear();
                             for (j = 0; j < (int)tx.vin.size(); ++j)
@@ -2489,22 +2326,11 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
                                             
                                             mc_GetCompoundHash160(&stream_subkey_hash160,entity.m_EntityID,&subkey_hash160);
                             
-                                            map<uint160,int>::iterator it = subkey_count_map.find(stream_subkey_hash160);
-                                            if (it == subkey_count_map.end())
-                                            {
-                                                subkey_count_map.insert(make_pair(stream_subkey_hash160,0));
-                                            }
-                                            else
-                                            {
-                                                it->second += 1;
-                                                extension.m_Count=it->second;
-                                            }
-                                            
                                             entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_CHAINPOS;
                                             subkey_entity.Zero();
                                             memcpy(subkey_entity.m_EntityID,&stream_subkey_hash160,MC_TDB_ENTITY_ID_SIZE);
                                             subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_PUBLISHER | MC_TET_CHAINPOS;
-                                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,&extension,block,0,fFound ? 0 : 1);
+                                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,block,0,fFound ? 0 : 1);
                                             if(err)
                                             {
                                                 goto exitlbl;
@@ -2512,7 +2338,7 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
                             
                                             entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_TIMERECEIVED;
                                             subkey_entity.m_EntityType=MC_TET_SUBKEY_STREAM_PUBLISHER | MC_TET_TIMERECEIVED;
-                                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,&extension,block,0,fFound ? 0 : 1);
+                                            err= m_Database->IncrementSubKey(imp,&entity,&subkey_entity,(unsigned char*)&subkey_hash160,(unsigned char*)&hash,block,0,fFound ? 0 : 1);
                                             if(err)
                                             {
                                                 goto exitlbl;
@@ -2573,8 +2399,25 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
     if(fNewAsset)
     {
         entity.Zero();
-        entity.m_EntityType=MC_TET_ASSET | MC_TET_CHAINPOS;
-        memcpy(entity.m_EntityID,(unsigned char*)&hash+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        if(mc_gState->m_Features->ShortTxIDInTx())
+        {
+            entity.m_EntityType=MC_TET_ASSET | MC_TET_CHAINPOS;
+            memcpy(entity.m_EntityID,(unsigned char*)&hash+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        }
+        else
+        {
+            if(block >= 0)
+            {
+                entity.m_EntityType=MC_TET_ASSET | MC_TET_CHAINPOS;
+                int tx_offset=sizeof(CBlockHeader)+block_pos->nTxOffset;
+                mc_PutLE(entity.m_EntityID,&block,4);
+                mc_PutLE(entity.m_EntityID+4,&tx_offset,4);
+                for(i=0;i<MC_ENT_REF_PREFIX_SIZE;i++)
+                {
+                    entity.m_EntityID[8+i]=*((unsigned char*)&hash+MC_ENT_KEY_SIZE-1-i);
+                }
+            }
+        }
         if(entity.m_EntityType)
         {
             if(imp->FindEntity(&entity) >= 0)    
@@ -2609,7 +2452,14 @@ int mc_WalletTxs::AddTx(mc_TxImport *import,const CWalletTx& tx,int block,CDiskT
     {
         ptrOut=mc_gState->m_TmpAssetsOut->GetRow(i);
         entity.Zero();
-        memcpy(entity.m_EntityID,ptrOut+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        if(mc_gState->m_Features->ShortTxIDInTx())
+        {
+            memcpy(entity.m_EntityID,ptrOut+MC_AST_SHORT_TXID_OFFSET,MC_AST_SHORT_TXID_SIZE);
+        }
+        else
+        {
+            memcpy(entity.m_EntityID,ptrOut,MC_AST_ASSET_REF_SIZE);            
+        }
         entity.m_EntityType=MC_TET_ASSET | MC_TET_CHAINPOS;
         fRelevantEntity=false;
         if(imp->FindEntity(&entity) >= 0)    
@@ -2805,13 +2655,7 @@ exitlbl:
             entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_CHAINPOS;
             m_Database->AddEntity(imp,&entity,0);
             entity.m_EntityType=MC_TET_STREAM_PUBLISHER | MC_TET_TIMERECEIVED;
-            m_Database->AddEntity(imp,&entity,0); 
-
-            if(mc_gState->m_Features->Chunks())
-            {
-                entity.m_EntityType=MC_TET_STREAM;
-                m_ChunkDB->AddEntity(&entity,0);
-            }            
+            m_Database->AddEntity(imp,&entity,0);            
         }       
     }
     
diff --git a/src/wallet/wallettxs.h b/src/wallet/wallettxs.h
index 53c0821..a9b5573 100644
--- a/src/wallet/wallettxs.h
+++ b/src/wallet/wallettxs.h
@@ -11,8 +11,6 @@
 #include "wallet/wallet.h"
 #include "multichain/multichain.h"
 #include "wallet/wallettxdb.h"
-#include "wallet/chunkdb.h"
-#include "wallet/chunkcollector.h"
 
 #define MC_TDB_MAX_OP_RETURN_SIZE             256
 
@@ -48,16 +46,13 @@ typedef struct mc_WalletCachedAddTx
 typedef struct mc_WalletTxs
 {
     mc_TxDB *m_Database;
-    mc_ChunkDB *m_ChunkDB;
-    mc_ChunkCollector *m_ChunkCollector;
     CWallet *m_lpWallet;
     uint32_t m_Mode;
     std::map<COutPoint, mc_Coin> m_UTXOs[MC_TDB_MAX_IMPORTS];    
     std::map<uint256,CWalletTx> m_UnconfirmedSends;
     std::vector<uint256> m_UnconfirmedSendsHashes;
     std::map<uint256, CWalletTx> vAvailableCoins;    
- 
-    unsigned char* m_ChunkBuffer;
+    
     mc_WalletTxs()
     {
         Zero();
@@ -136,7 +131,7 @@ typedef struct mc_WalletTxs
     int GetRow(
                mc_TxEntityRow *erow);
     
-    int Unsubscribe(mc_Buffer *lpEntities,bool purge);                          // List of the entities to unsubscribe from
+    int Unsubscribe(mc_Buffer *lpEntities);                                     // List of the entities to unsubscribe from
     
     mc_TxImport *StartImport(                                                   // Starts new import
                              mc_Buffer *lpEntities,                             // List of entities to import
